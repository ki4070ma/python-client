{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Appium Python Client An extension library for adding Selenium 3.0 draft and Mobile JSON Wire Protocol Specification draft functionality to the Python language bindings, for use with the mobile testing framework Appium . Getting the Appium Python client There are three ways to install and use the Appium Python client. Install from PyPi , as 'Appium-Python-Client' . shell pip install Appium-Python-Client You can see the history from here Install from source, via PyPi . From 'Appium-Python-Client' , download and unarchive the source tarball (Appium-Python-Client-X.X.tar.gz). shell tar -xvf Appium-Python-Client-X.X.tar.gz cd Appium-Python-Client-X.X python setup.py install Install from source via GitHub . shell git clone git@github.com:appium/python-client.git cd python-client python setup.py install Development Style Guide: https://www.python.org/dev/peps/pep-0008/ autopep8 helps to format code automatically $ python -m autopep8 -r --global-config .config-pep8 -i . isort helps to order imports automatically $ python -m isort -rc . When you use newly 3rd party modules, add it to .isort.cfg to keep import order correct Docstring style: Google Style Refer link You can customise CHANGELOG.rst with commit messages following .gitchangelog.rc It generates readable changelog Setup pip install --user pipenv python -m pipenv lock --clear If you experience the below error, then refer pypa/pipenv#187 to solve it. Locking Failed! unknown locale: UTF-8 python -m pipenv install --dev --system pre-commit install Run tests You can run all of tests running on CI via tox in your local. $ tox You also can run particular tests like below. Unit $ py.test test/unit Run with pytest-xdist $ py.test -n 2 test/unit Functional $ py.test test/functional/ios/find_by_ios_class_chain_tests.py In parallel for iOS Create simulators named 'iPhone 6s - 8100' and 'iPhone 6s - 8101' Install test libraries via pip $ pip install pytest pytest-xdist Run tests $ py.test -n 2 test/functional/ios/find_by_ios_class_chain_tests.py Release Follow below steps. $ pip install twine $ pip install git+git://github.com/vaab/gitchangelog.git # Getting via GitHub repository is necessary for Python 3.7 # Type the new version number and 'yes' if you can publish it # You can test the command with DRY_RUN $ DRY_RUN = 1 ./release.sh $ ./release.sh # release Usage The Appium Python Client is fully compliant with the Selenium 3.0 specification draft, with some helpers to make mobile testing in Python easier. The majority of the usage remains as it has been for Selenium 2 (WebDriver), and as the official Selenium Python bindings begins to implement the new specification that implementation will be used underneath, so test code can be written that is utilizable with both bindings. To use the new functionality now, and to use the superset of functions, instead of including the Selenium webdriver module in your test code, use that from Appium instead. from appium import webdriver From there much of your test code will work with no change. As a base for the following code examples, the following sets up the UnitTest environment: # Android environment import unittest from appium import webdriver desired_caps = {} desired_caps [ 'platformName' ] = 'Android' desired_caps [ 'platformVersion' ] = '8.1' desired_caps [ 'automationName' ] = 'uiautomator2' desired_caps [ 'deviceName' ] = 'Android Emulator' desired_caps [ 'app' ] = PATH ( '../../../apps/selendroid-test-app.apk' ) self . driver = webdriver . Remote ( 'http://localhost:4723/wd/hub' , desired_caps ) # iOS environment import unittest from appium import webdriver desired_caps = {} desired_caps [ 'platformName' ] = 'iOS' desired_caps [ 'platformVersion' ] = '11.4' desired_caps [ 'automationName' ] = 'xcuitest' desired_caps [ 'deviceName' ] = 'iPhone Simulator' desired_caps [ 'app' ] = PATH ( '../../apps/UICatalog.app.zip' ) self . driver = webdriver . Remote ( 'http://localhost:4723/wd/hub' , desired_caps ) Changed or added functionality The methods that do change are... Direct Connect URLs If your Selenium/Appium server decorates the new session capabilities response with the following keys: directConnectProtocol directConnectHost directConnectPort directConnectPath Then python client will switch its endpoint to the one specified by the values of those keys. import unittest from appium import webdriver desired_caps = {} desired_caps [ 'platformName' ] = 'iOS' desired_caps [ 'platformVersion' ] = '11.4' desired_caps [ 'automationName' ] = 'xcuitest' desired_caps [ 'deviceName' ] = 'iPhone Simulator' desired_caps [ 'app' ] = PATH ( '../../apps/UICatalog.app.zip' ) self . driver = webdriver . Remote ( 'http://localhost:4723/wd/hub' , desired_caps , direct_connection = True ) Switching between 'Native' and 'Webview' For mobile testing the Selenium methods for switching between windows was previously commandeered for switching between native applications and webview contexts. Methods explicitly for this have been added to the Selenium 3 specification, so moving forward these 'context' methods are to be used. To get the current context, rather than calling driver.current_window_handle you use current = driver . current_context The available contexts are not retrieved using driver.window_handles but with driver . contexts Finally, to switch to a new context, rather than driver.switch_to.window(name) , use the comparable context method context_name = \"WEBVIEW_1\" driver . switch_to . context ( context_name ) Finding elements by iOS UIAutomation search This allows elements in iOS applications to be found using recursive element search using the UIAutomation library. This method is supported on iOS devices that still support UIAutomation, that is, versions which predate XCUITEST. Adds the methods driver.find_element_by_ios_uiautomation and driver.find_elements_by_ios_uiautomation . el = self . driver . find_element_by_ios_uiautomation ( '.elements()[0]' ) self . assertEqual ( 'UICatalog' , el . get_attribute ( 'name' )) els = self . driver . find_elements_by_ios_uiautomation ( '.elements()' ) self . assertIsInstance ( els , list ) Finding elements by Android UIAutomator search This allows elements in an Android application to be found using recursive element search using the UIAutomator library. Adds the methods driver.find_element_by_android_uiautomator and driver.find_elements_by_android_uiautomator . el = self . driver . find_element_by_android_uiautomator ( 'new UiSelector().description(\"Animation\")' ) self . assertIsNotNone ( el ) els = self . driver . find_elements_by_android_uiautomator ( 'new UiSelector().clickable(true)' ) self . assertIsInstance ( els , list ) Finding elements by Android viewtag search This method allows finding elements using View#tags . This method works with Espresso Driver . Adds the methods driver.find_element_by_android_viewtag and driver.find_elements_by_android_viewtag . el = self . driver . find_element_by_android_viewtag ( 'a tag name' ) self . assertIsNotNone ( el ) els = self . driver . find_elements_by_android_viewtag ( 'a tag name' ) self . assertIsInstance ( els , list ) Finding elements by iOS predicates This method allows finding elements using iOS predicates. The methods take a string in the format of a predicate, including element type and the value of fields. Adds the methods driver.find_element_by_ios_predicate and find_elements_by_ios_predicate . el = self . driver . find_element_by_ios_predicate ( 'wdName == \"Buttons\"' ) self . assertIsNotNone ( el ) els = self . driver . find_elements_by_ios_predicate ( 'wdValue == \"SearchBar\" AND isWDDivisible == 1' ) self . assertIsInstance ( els , list ) Finding elements by iOS class chain This method is only for XCUITest driver This method allows finding elements using iOS class chain. The methods take a string in the format of a class chain, including element type. Adds the methods driver.find_element_by_ios_class_chain and find_elements_by_ios_class_chain . el = self . driver . find_element_by_ios_class_chain ( 'XCUIElementTypeWindow/XCUIElementTypeButton[3]' ) self . assertIsNotNone ( el ) els = self . driver . find_elements_by_ios_class_chain ( 'XCUIElementTypeWindow/XCUIElementTypeButton' ) self . assertIsInstance ( els , list ) Finding elements by Accessibility ID Allows for elements to be found using the \"Accessibility ID\". The methods take a string representing the accessibility id or label attached to a given element, e.g., for iOS the accessibility identifier and for Android the content-description. Adds the methods driver.find_element_by_accessibility_id and find_elements_by_accessibility_id . el = self . driver . find_element_by_accessibility_id ( 'Animation' ) self . assertIsNotNone ( el ) els = self . driver . find_elements_by_accessibility_id ( 'Animation' ) self . assertIsInstance ( els , list ) Touch actions In order to accommodate mobile touch actions, and touch actions involving multiple pointers, the Selenium 3.0 draft specifies \"touch gestures\" and \"multi actions\" , which build upon the touch actions. move_to: note that use keyword arguments if no element The API is built around TouchAction objects, which are chains of one or more actions to be performed in a sequence. The actions are: perform The perform method sends the chain to the server in order to be enacted. It also empties the action chain, so the object can be reused. It will be at the end of all single action chains, but is unused when writing multi-action chains. tap The tap method stands alone, being unable to be chained with other methods. If you need a tap -like action that starts a longer chain, use press . It can take either an element with an optional x-y offset, or absolute x-y coordinates for the tap, and an optional count. el = self . driver . find_element_by_accessibility_id ( 'Animation' ) action = TouchAction ( self . driver ) action . tap ( el ) . perform () el = self . driver . find_element_by_accessibility_id ( 'Bouncing Balls' ) self . assertIsNotNone ( el ) press long_press release move_to wait cancel Multi-touch actions In addition to chains of actions performed within a single gesture, it is also possible to perform multiple chains at the same time, to simulate multi-finger actions. This is done through building a MultiAction object that comprises a number of individual TouchAction objects, one for each \"finger\". Given two lists next to each other, we can scroll them independently but simultaneously: els = self . driver . find_elements_by_class_name ( 'listView' ) a1 = TouchAction () a1 . press ( els [ 0 ]) \\ . move_to ( x = 10 , y = 0 ) . move_to ( x = 10 , y =- 75 ) . move_to ( x = 10 , y =- 600 ) . release () a2 = TouchAction () a2 . press ( els [ 1 ]) \\ . move_to ( x = 10 , y = 10 ) . move_to ( x = 10 , y =- 300 ) . move_to ( x = 10 , y =- 600 ) . release () ma = MultiAction ( self . driver , els [ 0 ]) ma . add ( a1 , a2 ) ma . perform (); Appium-Specific touch actions There are a small number of operations that mobile testers need to do quite a bit that can be relatively complicated to build using the Touch and Multi-touch Action API. For these we provide some convenience methods in the Appium client. driver.tap This method, on the WebDriver object, allows for tapping with multiple fingers, simply by passing in an array of x-y coordinates to tap. el = self . driver . find_element_by_name ( 'Touch Paint' ) action . tap ( el ) . perform () # set up array of two coordinates positions = [] positions . append (( 100 , 200 )) positions . append (( 100 , 400 )) self . driver . tap ( positions ) driver.swipe Swipe from one point to another point. Application management methods There are times when you want, in your tests, to manage the running application, such as installing or removing an application, etc. Backgrounding an application The method driver.background_app sends the running application to the background for the specified amount of time, in seconds. After that time, the application is brought back to the foreground. driver . background_app ( 1 ) sleep ( 2 ) el = driver . find_element_by_name ( 'Animation' ) assertIsNotNone ( el ) Checking if an application is installed To check if an application is currently installed on the device, use the device.is_app_installed method. This method takes the bundle id of the application and return True or False . assertFalse ( self . driver . is_app_installed ( 'sdfsdf' )) assertTrue ( self . driver . is_app_installed ( 'com.example.android.apis' )) Installing an application To install an uninstalled application on the device, use device.install_app , sending in the path to the application file or archive. assertFalse ( driver . is_app_installed ( 'io.selendroid.testapp' )) driver . install_app ( '/Users/isaac/code/python-client/test/apps/selendroid-test-app.apk' ) assertTrue ( driver . is_app_installed ( 'io.selendroid.testapp' )) Removing an application If you need to remove an application from the device, use device.remove_app , passing in the application id. assertTrue ( driver . is_app_installed ( 'com.example.android.apis' )) driver . remove_app ( 'com.example.android.apis' ) assertFalse ( driver . is_app_installed ( 'com.example.android.apis' )) Closing and Launching an application To launch the application specified in the desired capabilities, call driver.launch_app . Closing that application is initiated by driver.close_app el = driver . find_element_by_name ( 'Animation' ) assertIsNotNone ( el ) driver . close_app (); try : driver . find_element_by_name ( 'Animation' ) except Exception as e : pass # should not exist driver . launch_app () el = driver . find_element_by_name ( 'Animation' ) assertIsNotNone ( el ) Resetting an application To reset the running application, use driver.reset . el = driver . find_element_by_name ( 'App' ) el . click () driver . reset () sleep ( 5 ) el = driver . find_element_by_name ( 'App' ) assertIsNotNone ( el ) Other methods Start an arbitrary activity The driver.start_activity method opens arbitrary activities on a device. If the activity is not part of the application under test, it will also launch the activity's application. driver . start_activity ( 'com.foo.app' , '.MyActivity' ) Retrieving application strings The property method driver.app_strings returns the application strings from the application on the device. strings = driver . app_strings Sending a key event to an Android device The driver.keyevent method sends a keycode to the device. The keycodes can be found here . Android only. # sending 'Home' key event driver . press_keycode ( 3 ) Hiding the keyboard in iOS To hide the keyboard from view in iOS, use driver.hide_keyboard . If a key name is sent, the keyboard key with that name will be pressed. If no arguments are passed in, the keyboard will be hidden by tapping on the screen outside the text field, thus removing focus from it. # get focus on text field, so keyboard comes up el = driver . find_element_by_class_name ( 'android.widget.TextView' ) el . set_value ( 'Testing' ) el = driver . find_element_by_class_name ( 'keyboard' ) assertTrue ( el . is_displayed ()) driver . hide_keyboard ( 'Done' ) assertFalse ( el . is_displayed ()) # get focus on text field, so keyboard comes up el = driver . find_element_by_class_name ( 'android.widget.TextView' ) el . set_value ( 'Testing' ) el = driver . find_element_by__name ( 'keyboard' ) assertTrue ( el . is_displayed ()) driver . hide_keyboard () assertFalse ( el . is_displayed ()) Retrieving the current running package and activity The property method driver.current_package returns the name of the current package running on the device. package = driver . current_package assertEquals ( 'com.example.android.apis' , package ) The property method driver.current_activity returns the name of the current activity running on the device. activity = driver . current_activity assertEquals ( '.ApiDemos' , activity ) Set a value directly on an element Sometimes one needs to directly set the value of an element on the device. To do this, the method driver.set_value or element.set_value is invoked. el = driver . find_element_by_class_name ( 'android.widget.EditText' ) driver . set_value ( el , 'Testing' ) text = el . get_attribute ( 'text' ) assertEqual ( 'Testing' , text ) el . set_value ( 'More testing' ) text = el . get_attribute ( 'text' ) assertEqual ( 'More testing' , text ) Retrieve a file from the device To retrieve the contents of a file from the device, use driver.pull_file , which returns the contents of the specified file encoded in Base64 . # pulling the strings file for our application data = driver . pull_file ( 'data/local/tmp/strings.json' ) strings = json . loads ( data . decode ( 'base64' , 'strict' )) assertEqual ( 'You can \\' t wipe my data, you are a monkey!' , strings [ u 'monkey_wipe_data' ]) Place a file on the device To put a file onto the device at a particular place, use the driver.push_file method, which takes the path and the data, encoded as Base64 , to be written to the file. path = 'data/local/tmp/test_push_file.txt' data = 'This is the contents of the file to push to the device.' driver . push_file ( path , data . encode ( 'base64' )) data_ret = driver . pull_file ( 'data/local/tmp/test_push_file.txt' ) . decode ( 'base64' ) self . assertEqual ( data , data_ret ) End test coverage There is functionality in the Android emulator to instrument certain activities. For information on this, see the Appium docs . To end this coverage and retrieve the data, use driver.end_test_coverage , passing in the intent that is being instrumentalized, and the path to the coverage.ec file on the device. coverage_ec_file = driver . end_test_coverage ( intent = 'android.intent.action.MAIN' , path = '' ) Lock the device To lock the device for a certain amount of time, on iOS, use driver.lock . The argument is the number of seconds to wait before unlocking. Shake the device To shake the device, use driver.shake . Appium Settings Settings are a new concept introduced by appium. They are currently not a part of the Mobile JSON Wire Protocol, or the Webdriver spec. Settings are a way to specify the behavior of the appium server. Settings are: Mutable, they can be changed during a session Only relevant during the session they are applied. They are reset for each new session. Control the way the appium server behaves during test automation. They do not apply to controlling the app or device under test. See the docs for more information. To get settings: settings = driver . get_settings () To set settings: driver . update_settings ({ \"some setting\" : \"the value\" })","title":"Home"},{"location":"#appium-python-client","text":"An extension library for adding Selenium 3.0 draft and Mobile JSON Wire Protocol Specification draft functionality to the Python language bindings, for use with the mobile testing framework Appium .","title":"Appium Python Client"},{"location":"#getting-the-appium-python-client","text":"There are three ways to install and use the Appium Python client. Install from PyPi , as 'Appium-Python-Client' . shell pip install Appium-Python-Client You can see the history from here Install from source, via PyPi . From 'Appium-Python-Client' , download and unarchive the source tarball (Appium-Python-Client-X.X.tar.gz). shell tar -xvf Appium-Python-Client-X.X.tar.gz cd Appium-Python-Client-X.X python setup.py install Install from source via GitHub . shell git clone git@github.com:appium/python-client.git cd python-client python setup.py install","title":"Getting the Appium Python client"},{"location":"#development","text":"Style Guide: https://www.python.org/dev/peps/pep-0008/ autopep8 helps to format code automatically $ python -m autopep8 -r --global-config .config-pep8 -i . isort helps to order imports automatically $ python -m isort -rc . When you use newly 3rd party modules, add it to .isort.cfg to keep import order correct Docstring style: Google Style Refer link You can customise CHANGELOG.rst with commit messages following .gitchangelog.rc It generates readable changelog Setup pip install --user pipenv python -m pipenv lock --clear If you experience the below error, then refer pypa/pipenv#187 to solve it. Locking Failed! unknown locale: UTF-8 python -m pipenv install --dev --system pre-commit install","title":"Development"},{"location":"#run-tests","text":"You can run all of tests running on CI via tox in your local. $ tox You also can run particular tests like below.","title":"Run tests"},{"location":"#unit","text":"$ py.test test/unit Run with pytest-xdist $ py.test -n 2 test/unit","title":"Unit"},{"location":"#functional","text":"$ py.test test/functional/ios/find_by_ios_class_chain_tests.py","title":"Functional"},{"location":"#in-parallel-for-ios","text":"Create simulators named 'iPhone 6s - 8100' and 'iPhone 6s - 8101' Install test libraries via pip $ pip install pytest pytest-xdist Run tests $ py.test -n 2 test/functional/ios/find_by_ios_class_chain_tests.py","title":"In parallel for iOS"},{"location":"#release","text":"Follow below steps. $ pip install twine $ pip install git+git://github.com/vaab/gitchangelog.git # Getting via GitHub repository is necessary for Python 3.7 # Type the new version number and 'yes' if you can publish it # You can test the command with DRY_RUN $ DRY_RUN = 1 ./release.sh $ ./release.sh # release","title":"Release"},{"location":"#usage","text":"The Appium Python Client is fully compliant with the Selenium 3.0 specification draft, with some helpers to make mobile testing in Python easier. The majority of the usage remains as it has been for Selenium 2 (WebDriver), and as the official Selenium Python bindings begins to implement the new specification that implementation will be used underneath, so test code can be written that is utilizable with both bindings. To use the new functionality now, and to use the superset of functions, instead of including the Selenium webdriver module in your test code, use that from Appium instead. from appium import webdriver From there much of your test code will work with no change. As a base for the following code examples, the following sets up the UnitTest environment: # Android environment import unittest from appium import webdriver desired_caps = {} desired_caps [ 'platformName' ] = 'Android' desired_caps [ 'platformVersion' ] = '8.1' desired_caps [ 'automationName' ] = 'uiautomator2' desired_caps [ 'deviceName' ] = 'Android Emulator' desired_caps [ 'app' ] = PATH ( '../../../apps/selendroid-test-app.apk' ) self . driver = webdriver . Remote ( 'http://localhost:4723/wd/hub' , desired_caps ) # iOS environment import unittest from appium import webdriver desired_caps = {} desired_caps [ 'platformName' ] = 'iOS' desired_caps [ 'platformVersion' ] = '11.4' desired_caps [ 'automationName' ] = 'xcuitest' desired_caps [ 'deviceName' ] = 'iPhone Simulator' desired_caps [ 'app' ] = PATH ( '../../apps/UICatalog.app.zip' ) self . driver = webdriver . Remote ( 'http://localhost:4723/wd/hub' , desired_caps )","title":"Usage"},{"location":"#changed-or-added-functionality","text":"The methods that do change are...","title":"Changed or added functionality"},{"location":"#direct-connect-urls","text":"If your Selenium/Appium server decorates the new session capabilities response with the following keys: directConnectProtocol directConnectHost directConnectPort directConnectPath Then python client will switch its endpoint to the one specified by the values of those keys. import unittest from appium import webdriver desired_caps = {} desired_caps [ 'platformName' ] = 'iOS' desired_caps [ 'platformVersion' ] = '11.4' desired_caps [ 'automationName' ] = 'xcuitest' desired_caps [ 'deviceName' ] = 'iPhone Simulator' desired_caps [ 'app' ] = PATH ( '../../apps/UICatalog.app.zip' ) self . driver = webdriver . Remote ( 'http://localhost:4723/wd/hub' , desired_caps , direct_connection = True )","title":"Direct Connect URLs"},{"location":"#switching-between-native-and-webview","text":"For mobile testing the Selenium methods for switching between windows was previously commandeered for switching between native applications and webview contexts. Methods explicitly for this have been added to the Selenium 3 specification, so moving forward these 'context' methods are to be used. To get the current context, rather than calling driver.current_window_handle you use current = driver . current_context The available contexts are not retrieved using driver.window_handles but with driver . contexts Finally, to switch to a new context, rather than driver.switch_to.window(name) , use the comparable context method context_name = \"WEBVIEW_1\" driver . switch_to . context ( context_name )","title":"Switching between 'Native' and 'Webview'"},{"location":"#finding-elements-by-ios-uiautomation-search","text":"This allows elements in iOS applications to be found using recursive element search using the UIAutomation library. This method is supported on iOS devices that still support UIAutomation, that is, versions which predate XCUITEST. Adds the methods driver.find_element_by_ios_uiautomation and driver.find_elements_by_ios_uiautomation . el = self . driver . find_element_by_ios_uiautomation ( '.elements()[0]' ) self . assertEqual ( 'UICatalog' , el . get_attribute ( 'name' )) els = self . driver . find_elements_by_ios_uiautomation ( '.elements()' ) self . assertIsInstance ( els , list )","title":"Finding elements by iOS UIAutomation search"},{"location":"#finding-elements-by-android-uiautomator-search","text":"This allows elements in an Android application to be found using recursive element search using the UIAutomator library. Adds the methods driver.find_element_by_android_uiautomator and driver.find_elements_by_android_uiautomator . el = self . driver . find_element_by_android_uiautomator ( 'new UiSelector().description(\"Animation\")' ) self . assertIsNotNone ( el ) els = self . driver . find_elements_by_android_uiautomator ( 'new UiSelector().clickable(true)' ) self . assertIsInstance ( els , list )","title":"Finding elements by Android UIAutomator search"},{"location":"#finding-elements-by-android-viewtag-search","text":"This method allows finding elements using View#tags . This method works with Espresso Driver . Adds the methods driver.find_element_by_android_viewtag and driver.find_elements_by_android_viewtag . el = self . driver . find_element_by_android_viewtag ( 'a tag name' ) self . assertIsNotNone ( el ) els = self . driver . find_elements_by_android_viewtag ( 'a tag name' ) self . assertIsInstance ( els , list )","title":"Finding elements by Android viewtag search"},{"location":"#finding-elements-by-ios-predicates","text":"This method allows finding elements using iOS predicates. The methods take a string in the format of a predicate, including element type and the value of fields. Adds the methods driver.find_element_by_ios_predicate and find_elements_by_ios_predicate . el = self . driver . find_element_by_ios_predicate ( 'wdName == \"Buttons\"' ) self . assertIsNotNone ( el ) els = self . driver . find_elements_by_ios_predicate ( 'wdValue == \"SearchBar\" AND isWDDivisible == 1' ) self . assertIsInstance ( els , list )","title":"Finding elements by iOS predicates"},{"location":"#finding-elements-by-ios-class-chain","text":"This method is only for XCUITest driver This method allows finding elements using iOS class chain. The methods take a string in the format of a class chain, including element type. Adds the methods driver.find_element_by_ios_class_chain and find_elements_by_ios_class_chain . el = self . driver . find_element_by_ios_class_chain ( 'XCUIElementTypeWindow/XCUIElementTypeButton[3]' ) self . assertIsNotNone ( el ) els = self . driver . find_elements_by_ios_class_chain ( 'XCUIElementTypeWindow/XCUIElementTypeButton' ) self . assertIsInstance ( els , list )","title":"Finding elements by iOS class chain"},{"location":"#finding-elements-by-accessibility-id","text":"Allows for elements to be found using the \"Accessibility ID\". The methods take a string representing the accessibility id or label attached to a given element, e.g., for iOS the accessibility identifier and for Android the content-description. Adds the methods driver.find_element_by_accessibility_id and find_elements_by_accessibility_id . el = self . driver . find_element_by_accessibility_id ( 'Animation' ) self . assertIsNotNone ( el ) els = self . driver . find_elements_by_accessibility_id ( 'Animation' ) self . assertIsInstance ( els , list )","title":"Finding elements by Accessibility ID"},{"location":"#touch-actions","text":"In order to accommodate mobile touch actions, and touch actions involving multiple pointers, the Selenium 3.0 draft specifies \"touch gestures\" and \"multi actions\" , which build upon the touch actions. move_to: note that use keyword arguments if no element The API is built around TouchAction objects, which are chains of one or more actions to be performed in a sequence. The actions are:","title":"Touch actions"},{"location":"#perform","text":"The perform method sends the chain to the server in order to be enacted. It also empties the action chain, so the object can be reused. It will be at the end of all single action chains, but is unused when writing multi-action chains.","title":"perform"},{"location":"#tap","text":"The tap method stands alone, being unable to be chained with other methods. If you need a tap -like action that starts a longer chain, use press . It can take either an element with an optional x-y offset, or absolute x-y coordinates for the tap, and an optional count. el = self . driver . find_element_by_accessibility_id ( 'Animation' ) action = TouchAction ( self . driver ) action . tap ( el ) . perform () el = self . driver . find_element_by_accessibility_id ( 'Bouncing Balls' ) self . assertIsNotNone ( el )","title":"tap"},{"location":"#press","text":"","title":"press"},{"location":"#long_press","text":"","title":"long_press"},{"location":"#release_1","text":"","title":"release"},{"location":"#move_to","text":"","title":"move_to"},{"location":"#wait","text":"","title":"wait"},{"location":"#cancel","text":"","title":"cancel"},{"location":"#multi-touch-actions","text":"In addition to chains of actions performed within a single gesture, it is also possible to perform multiple chains at the same time, to simulate multi-finger actions. This is done through building a MultiAction object that comprises a number of individual TouchAction objects, one for each \"finger\". Given two lists next to each other, we can scroll them independently but simultaneously: els = self . driver . find_elements_by_class_name ( 'listView' ) a1 = TouchAction () a1 . press ( els [ 0 ]) \\ . move_to ( x = 10 , y = 0 ) . move_to ( x = 10 , y =- 75 ) . move_to ( x = 10 , y =- 600 ) . release () a2 = TouchAction () a2 . press ( els [ 1 ]) \\ . move_to ( x = 10 , y = 10 ) . move_to ( x = 10 , y =- 300 ) . move_to ( x = 10 , y =- 600 ) . release () ma = MultiAction ( self . driver , els [ 0 ]) ma . add ( a1 , a2 ) ma . perform ();","title":"Multi-touch actions"},{"location":"#appium-specific-touch-actions","text":"There are a small number of operations that mobile testers need to do quite a bit that can be relatively complicated to build using the Touch and Multi-touch Action API. For these we provide some convenience methods in the Appium client.","title":"Appium-Specific touch actions"},{"location":"#drivertap","text":"This method, on the WebDriver object, allows for tapping with multiple fingers, simply by passing in an array of x-y coordinates to tap. el = self . driver . find_element_by_name ( 'Touch Paint' ) action . tap ( el ) . perform () # set up array of two coordinates positions = [] positions . append (( 100 , 200 )) positions . append (( 100 , 400 )) self . driver . tap ( positions )","title":"driver.tap"},{"location":"#driverswipe","text":"Swipe from one point to another point.","title":"driver.swipe"},{"location":"#application-management-methods","text":"There are times when you want, in your tests, to manage the running application, such as installing or removing an application, etc.","title":"Application management methods"},{"location":"#backgrounding-an-application","text":"The method driver.background_app sends the running application to the background for the specified amount of time, in seconds. After that time, the application is brought back to the foreground. driver . background_app ( 1 ) sleep ( 2 ) el = driver . find_element_by_name ( 'Animation' ) assertIsNotNone ( el )","title":"Backgrounding an application"},{"location":"#checking-if-an-application-is-installed","text":"To check if an application is currently installed on the device, use the device.is_app_installed method. This method takes the bundle id of the application and return True or False . assertFalse ( self . driver . is_app_installed ( 'sdfsdf' )) assertTrue ( self . driver . is_app_installed ( 'com.example.android.apis' ))","title":"Checking if an application is installed"},{"location":"#installing-an-application","text":"To install an uninstalled application on the device, use device.install_app , sending in the path to the application file or archive. assertFalse ( driver . is_app_installed ( 'io.selendroid.testapp' )) driver . install_app ( '/Users/isaac/code/python-client/test/apps/selendroid-test-app.apk' ) assertTrue ( driver . is_app_installed ( 'io.selendroid.testapp' ))","title":"Installing an application"},{"location":"#removing-an-application","text":"If you need to remove an application from the device, use device.remove_app , passing in the application id. assertTrue ( driver . is_app_installed ( 'com.example.android.apis' )) driver . remove_app ( 'com.example.android.apis' ) assertFalse ( driver . is_app_installed ( 'com.example.android.apis' ))","title":"Removing an application"},{"location":"#closing-and-launching-an-application","text":"To launch the application specified in the desired capabilities, call driver.launch_app . Closing that application is initiated by driver.close_app el = driver . find_element_by_name ( 'Animation' ) assertIsNotNone ( el ) driver . close_app (); try : driver . find_element_by_name ( 'Animation' ) except Exception as e : pass # should not exist driver . launch_app () el = driver . find_element_by_name ( 'Animation' ) assertIsNotNone ( el )","title":"Closing and Launching an application"},{"location":"#resetting-an-application","text":"To reset the running application, use driver.reset . el = driver . find_element_by_name ( 'App' ) el . click () driver . reset () sleep ( 5 ) el = driver . find_element_by_name ( 'App' ) assertIsNotNone ( el )","title":"Resetting an application"},{"location":"#other-methods","text":"","title":"Other methods"},{"location":"#start-an-arbitrary-activity","text":"The driver.start_activity method opens arbitrary activities on a device. If the activity is not part of the application under test, it will also launch the activity's application. driver . start_activity ( 'com.foo.app' , '.MyActivity' )","title":"Start an arbitrary activity"},{"location":"#retrieving-application-strings","text":"The property method driver.app_strings returns the application strings from the application on the device. strings = driver . app_strings","title":"Retrieving application strings"},{"location":"#sending-a-key-event-to-an-android-device","text":"The driver.keyevent method sends a keycode to the device. The keycodes can be found here . Android only. # sending 'Home' key event driver . press_keycode ( 3 )","title":"Sending a key event to an Android device"},{"location":"#hiding-the-keyboard-in-ios","text":"To hide the keyboard from view in iOS, use driver.hide_keyboard . If a key name is sent, the keyboard key with that name will be pressed. If no arguments are passed in, the keyboard will be hidden by tapping on the screen outside the text field, thus removing focus from it. # get focus on text field, so keyboard comes up el = driver . find_element_by_class_name ( 'android.widget.TextView' ) el . set_value ( 'Testing' ) el = driver . find_element_by_class_name ( 'keyboard' ) assertTrue ( el . is_displayed ()) driver . hide_keyboard ( 'Done' ) assertFalse ( el . is_displayed ()) # get focus on text field, so keyboard comes up el = driver . find_element_by_class_name ( 'android.widget.TextView' ) el . set_value ( 'Testing' ) el = driver . find_element_by__name ( 'keyboard' ) assertTrue ( el . is_displayed ()) driver . hide_keyboard () assertFalse ( el . is_displayed ())","title":"Hiding the keyboard in iOS"},{"location":"#retrieving-the-current-running-package-and-activity","text":"The property method driver.current_package returns the name of the current package running on the device. package = driver . current_package assertEquals ( 'com.example.android.apis' , package ) The property method driver.current_activity returns the name of the current activity running on the device. activity = driver . current_activity assertEquals ( '.ApiDemos' , activity )","title":"Retrieving the current running package and activity"},{"location":"#set-a-value-directly-on-an-element","text":"Sometimes one needs to directly set the value of an element on the device. To do this, the method driver.set_value or element.set_value is invoked. el = driver . find_element_by_class_name ( 'android.widget.EditText' ) driver . set_value ( el , 'Testing' ) text = el . get_attribute ( 'text' ) assertEqual ( 'Testing' , text ) el . set_value ( 'More testing' ) text = el . get_attribute ( 'text' ) assertEqual ( 'More testing' , text )","title":"Set a value directly on an element"},{"location":"#retrieve-a-file-from-the-device","text":"To retrieve the contents of a file from the device, use driver.pull_file , which returns the contents of the specified file encoded in Base64 . # pulling the strings file for our application data = driver . pull_file ( 'data/local/tmp/strings.json' ) strings = json . loads ( data . decode ( 'base64' , 'strict' )) assertEqual ( 'You can \\' t wipe my data, you are a monkey!' , strings [ u 'monkey_wipe_data' ])","title":"Retrieve a file from the device"},{"location":"#place-a-file-on-the-device","text":"To put a file onto the device at a particular place, use the driver.push_file method, which takes the path and the data, encoded as Base64 , to be written to the file. path = 'data/local/tmp/test_push_file.txt' data = 'This is the contents of the file to push to the device.' driver . push_file ( path , data . encode ( 'base64' )) data_ret = driver . pull_file ( 'data/local/tmp/test_push_file.txt' ) . decode ( 'base64' ) self . assertEqual ( data , data_ret )","title":"Place a file on the device"},{"location":"#end-test-coverage","text":"There is functionality in the Android emulator to instrument certain activities. For information on this, see the Appium docs . To end this coverage and retrieve the data, use driver.end_test_coverage , passing in the intent that is being instrumentalized, and the path to the coverage.ec file on the device. coverage_ec_file = driver . end_test_coverage ( intent = 'android.intent.action.MAIN' , path = '' )","title":"End test coverage"},{"location":"#lock-the-device","text":"To lock the device for a certain amount of time, on iOS, use driver.lock . The argument is the number of seconds to wait before unlocking.","title":"Lock the device"},{"location":"#shake-the-device","text":"To shake the device, use driver.shake .","title":"Shake the device"},{"location":"#appium-settings","text":"Settings are a new concept introduced by appium. They are currently not a part of the Mobile JSON Wire Protocol, or the Webdriver spec. Settings are a way to specify the behavior of the appium server. Settings are: Mutable, they can be changed during a session Only relevant during the session they are applied. They are reset for each new session. Control the way the appium server behaves during test automation. They do not apply to controlling the app or device under test. See the docs for more information. To get settings: settings = driver . get_settings () To set settings: driver . update_settings ({ \"some setting\" : \"the value\" })","title":"Appium Settings"},{"location":"docs/roadmap/","text":"Appium Python Client Plan This library will be a simple extension of the official Python bindings, through subclassing, to add the new methods. I would like to maintain the same package structure, so that switching to the Appium library would be a matter of changing the import. The official client allows for three ways to interact with the server: with the selenium class, with the webdriver.Remote class, and with specific browser classes, which subclass webdriver.Remote in webdriver.* classes. It seems like we would not need to update the browser classes for our use case, and the first is for RC, which we don't support. Thus we can subclass the official webdriver.Remote classes and add the new methods. Otherwise we would need to use composition, since we have to change the base class and subclasses. Usage will remain as it currently is, using the first two methods from above, other than importing from Appium: from appium import webdriver desired_caps = {} # ... driver = webdriver . Remote ( 'http://localhost:4723/wd/hub' , desired_caps ) print driver . get_window_size () elem = driver . find_element_by_name ( 'Graphics' ) elem . click () driver . quit () As Selenium catches up, the methods can be seemlessly removed from the Appium client. Any methods outside of the spec can remain and be used without issue, should the user choose.","title":"Roadmap"},{"location":"docs/roadmap/#appium-python-client-plan","text":"This library will be a simple extension of the official Python bindings, through subclassing, to add the new methods. I would like to maintain the same package structure, so that switching to the Appium library would be a matter of changing the import. The official client allows for three ways to interact with the server: with the selenium class, with the webdriver.Remote class, and with specific browser classes, which subclass webdriver.Remote in webdriver.* classes. It seems like we would not need to update the browser classes for our use case, and the first is for RC, which we don't support. Thus we can subclass the official webdriver.Remote classes and add the new methods. Otherwise we would need to use composition, since we have to change the base class and subclasses. Usage will remain as it currently is, using the first two methods from above, other than importing from Appium: from appium import webdriver desired_caps = {} # ... driver = webdriver . Remote ( 'http://localhost:4723/wd/hub' , desired_caps ) print driver . get_window_size () elem = driver . find_element_by_name ( 'Graphics' ) elem . click () driver . quit () As Selenium catches up, the methods can be seemlessly removed from the Appium client. Any methods outside of the spec can remain and be used without issue, should the user choose.","title":"Appium Python Client Plan"},{"location":"reference/appium/","text":"Module appium Appium Python Client View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. \"\"\" Appium Python Client \"\"\" try : from .saucetestcase import SauceTestCase from .saucetestcase import on_platforms except ImportError : # SauceClient not found pass Sub-modules appium.common appium.saucetestcase appium.version appium.webdriver","title":"Index"},{"location":"reference/appium/#module-appium","text":"Appium Python Client View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. \"\"\" Appium Python Client \"\"\" try : from .saucetestcase import SauceTestCase from .saucetestcase import on_platforms except ImportError : # SauceClient not found pass","title":"Module appium"},{"location":"reference/appium/#sub-modules","text":"appium.common appium.saucetestcase appium.version appium.webdriver","title":"Sub-modules"},{"location":"reference/appium/saucetestcase/","text":"Module appium.saucetestcase View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # pylint: disable=import-error,no-member from __future__ import print_function import os import sys import unittest from appium import webdriver from sauceclient import SauceClient SAUCE_USERNAME = os . environ . get ( 'SAUCE_USERNAME' ) SAUCE_ACCESS_KEY = os . environ . get ( 'SAUCE_ACCESS_KEY' ) sauce = SauceClient ( SAUCE_USERNAME , SAUCE_ACCESS_KEY ) def on_platforms ( platforms ): def decorator ( base_class ): module = sys . modules [ base_class . __module__ ] . __dict__ for i , platform in enumerate ( platforms ): name = \" %s _ %s \" % ( base_class . __name__ , i + 1 ) d_caps = { 'desired_capabilities' : platform } module [ name ] = type ( name , ( base_class ,), d_caps ) return decorator class SauceTestCase ( unittest . TestCase ): def setUp ( self ): self . desired_capabilities [ 'name' ] = self . id () sauce_url = \"http:// %s : %s @ondemand.saucelabs.com:80/wd/hub\" self . driver = webdriver . Remote ( desired_capabilities = self . desired_capabilities , command_executor = sauce_url % ( SAUCE_USERNAME , SAUCE_ACCESS_KEY ) ) self . driver . implicitly_wait ( 30 ) def tearDown ( self ): print ( \"Link to your job: https://saucelabs.com/jobs/ %s \" % self . driver . session_id ) try : if sys . exc_info () == ( None , None , None ): sauce . jobs . update_job ( self . driver . session_id , passed = True ) else : sauce . jobs . update_job ( self . driver . session_id , passed = False ) finally : self . driver . quit () Variables SAUCE_ACCESS_KEY SAUCE_USERNAME sauce Functions on_platforms def on_platforms ( platforms ) View Source def on_platforms ( platforms ) : def decorator ( base_class ) : module = sys . modules [ base_class . __module__ ]. __dict__ for i , platform in enumerate ( platforms ) : name = \" %s_%s \" % ( base_class . __name__ , i + 1 ) d_caps = { ' desired_capabilities ' : platform } module [ name ] = type ( name , ( base_class , ) , d_caps ) return decorator Classes SauceTestCase class SauceTestCase ( methodName = 'runTest' ) A class whose instances are single test cases. By default, the test code itself should be placed in a method named 'runTest'. If the fixture may be used for many test cases, create as many test methods as are needed. When instantiating such a TestCase subclass, specify in the constructor arguments the name of the test method that the instance is to execute. Test authors should subclass TestCase for their own tests. Construction and deconstruction of the test's environment ('fixture') can be implemented by overriding the 'setUp' and 'tearDown' methods respectively. If it is necessary to override the init method, the base class init method must always be called. It is important that subclasses should not change the signature of their init method, since instances of the classes are instantiated automatically by parts of the framework in order to be run. When subclassing TestCase, you can set these attributes: * failureException: determines which exception will be raised when the instance's assertion methods fail; test methods raising this exception will be deemed to have 'failed' rather than 'errored'. * longMessage: determines whether long messages (including repr of objects used in assert methods) will be printed on failure in addition to any explicit message passed. * maxDiff: sets the maximum length of a diff in failure messages by assert methods using difflib. It is looked up as an instance attribute so can be configured by individual tests if required. View Source class SauceTestCase ( unittest . TestCase ) : def setUp ( self ) : self . desired_capabilities [ ' name ' ] = self . id () sauce_url = \" http://%s:%s@ondemand.saucelabs.com:80/wd/hub \" self . driver = webdriver . Remote ( desired_capabilities = self . desired_capabilities , command_executor = sauce_url % ( SAUCE_USERNAME , SAUCE_ACCESS_KEY ) ) self . driver . implicitly_wait ( 30 ) def tearDown ( self ) : print ( \" Link to your job: https://saucelabs.com/jobs/%s \" % self . driver . session_id ) try : if sys . exc_info () == ( None , None , None ) : sauce . jobs . update_job ( self . driver . session_id , passed = True ) else : sauce . jobs . update_job ( self . driver . session_id , passed = False ) finally : self . driver . quit () Ancestors (in MRO) unittest.case.TestCase Class variables failureException longMessage maxDiff Static methods setUpClass def setUpClass ( ) Hook method for setting up class fixture before running tests in the class. View Source @ classmethod def setUpClass ( cls ) : \" Hook method for setting up class fixture before running tests in the class. \" tearDownClass def tearDownClass ( ) Hook method for deconstructing the class fixture after running all tests in the class. View Source @ classmethod def tearDownClass ( cls ) : \" Hook method for deconstructing the class fixture after running all tests in the class. \" Methods addCleanup def addCleanup ( self , function , * args , ** kwargs ) Add a function, with arguments, to be called when the test is completed. Functions added are called on a LIFO basis and are called after tearDown on test failure or success. Cleanup items are called even if setUp fails (unlike tearDown). View Source def addCleanup ( self , function , * args , ** kwargs ) : \"\"\" Add a function, with arguments, to be called when the test is completed . Functions added are called on a LIFO basis and are called after tearDown on test failure or success . Cleanup items are called even if setUp fails ( unlike tearDown ) . \"\"\" self . _cleanups . append (( function , args , kwargs )) addTypeEqualityFunc def addTypeEqualityFunc ( self , typeobj , function ) Add a type specific assertEqual style function to compare a type. This method is for use by TestCase subclasses that need to register their own type equality functions to provide nicer error messages. Args: typeobj: The data type to call this function on when both values are of the same type in assertEqual(). function: The callable taking two arguments and an optional msg= argument that raises self.failureException with a useful error message when the two arguments are not equal. View Source def addTypeEqualityFunc ( self , typeobj , function ) : \"\"\" Add a type specific assertEqual style function to compare a type. This method is for use by TestCase subclasses that need to register their own type equality functions to provide nicer error messages . Args : typeobj : The data type to call this function on when both values are of the same type in assertEqual () . function : The callable taking two arguments and an optional msg = argument that raises self . failureException with a useful error message when the two arguments are not equal . \"\"\" self . _type_equality_funcs [ typeobj ] = function assertAlmostEqual def assertAlmostEqual ( self , first , second , places = None , msg = None , delta = None ) Fail if the two objects are unequal as determined by their difference rounded to the given number of decimal places (default 7) and comparing to zero, or by comparing that the difference between the two objects is more than the given delta. Note that decimal places (from zero) are usually not the same as significant digits (measured from the most significant digit). If the two objects compare equal then they will automatically compare almost equal. View Source def assertAlmostEqual ( self , first , second , places = None , msg = None , delta = None ) : \"\"\" Fail if the two objects are unequal as determined by their difference rounded to the given number of decimal places ( default 7 ) and comparing to zero , or by comparing that the difference between the two objects is more than the given delta . Note that decimal places ( from zero ) are usually not the same as significant digits ( measured from the most significant digit ) . If the two objects compare equal then they will automatically compare almost equal . \"\"\" if first == second : # shortcut return if delta is not None and places is not None : raise TypeError ( \" specify delta or places not both \" ) diff = abs ( first - second ) if delta is not None : if diff <= delta : return standardMsg = ' %s != %s within %s delta (%s difference) ' % ( safe_repr ( first ) , safe_repr ( second ) , safe_repr ( delta ) , safe_repr ( diff )) else : if places is None : places = 7 if round ( diff , places ) == 0 : return standardMsg = ' %s != %s within %r places (%s difference) ' % ( safe_repr ( first ) , safe_repr ( second ) , places , safe_repr ( diff )) msg = self . _formatMessage ( msg , standardMsg ) raise self . failureException ( msg ) assertAlmostEquals def assertAlmostEquals ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs ) assertCountEqual def assertCountEqual ( self , first , second , msg = None ) An unordered sequence comparison asserting that the same elements, regardless of order. If the same element occurs more than once, it verifies that the elements occur the same number of times. self . assertEqual ( Counter ( list ( first )), Counter ( list ( second ))) Example: - [0, 1, 1] and [1, 0, 1] compare equal. - [0, 0, 1] and [0, 1] compare unequal. View Source def assertCountEqual ( self , first , second , msg = None ): \"\"\"An unordered sequence comparison asserting that the same elements, regardless of order. If the same element occurs more than once, it verifies that the elements occur the same number of times. self.assertEqual(Counter(list(first)), Counter(list(second))) Example: - [0, 1, 1] and [1, 0, 1] compare equal. - [0, 0, 1] and [0, 1] compare unequal. \"\"\" first_seq , second_seq = list ( first ), list ( second ) try: first = collections . Counter ( first_seq ) second = collections . Counter ( second_seq ) except TypeError: # Handle case with unhashable elements differences = _count_diff_all_purpose ( first_seq , second_seq ) else: if first == second: return differences = _count_diff_hashable ( first_seq , second_seq ) if differences: standardMsg = 'Element counts were not equal:\\n' lines = [ 'First has %d, Second has %d: %r' % diff for diff in differences ] diffMsg = '\\n' . join ( lines ) standardMsg = self . _truncateMessage ( standardMsg , diffMsg ) msg = self . _formatMessage ( msg , standardMsg ) self . fail ( msg ) assertDictContainsSubset def assertDictContainsSubset ( self , subset , dictionary , msg = None ) Checks whether dictionary is a superset of subset. View Source def assertDictContainsSubset ( self , subset , dictionary , msg = None ) : \"\"\" Checks whether dictionary is a superset of subset. \"\"\" warnings . warn ( ' assertDictContainsSubset is deprecated ' , DeprecationWarning ) missing = [] mismatched = [] for key , value in subset . items () : if key not in dictionary : missing . append ( key ) elif value != dictionary [ key ]: mismatched . append ( ' %s, expected: %s, actual: %s ' % ( safe_repr ( key ) , safe_repr ( value ) , safe_repr ( dictionary [ key ] ))) if not ( missing or mismatched ) : return standardMsg = '' if missing : standardMsg = ' Missing: %s ' % ' , ' . join ( safe_repr ( m ) for m in missing ) if mismatched : if standardMsg : standardMsg += ' ; ' standardMsg += ' Mismatched values: %s ' % ' , ' . join ( mismatched ) self . fail ( self . _formatMessage ( msg , standardMsg )) assertDictEqual def assertDictEqual ( self , d1 , d2 , msg = None ) View Source def assertDictEqual ( self , d1 , d2 , msg = None ) : self . assertIsInstance ( d1 , dict , ' First argument is not a dictionary ' ) self . assertIsInstance ( d2 , dict , ' Second argument is not a dictionary ' ) if d1 != d2 : standardMsg = ' %s != %s ' % _common_shorten_repr ( d1 , d2 ) diff = ( ' \\n ' + ' \\n ' . join ( difflib . ndiff ( pprint . pformat ( d1 ) . splitlines () , pprint . pformat ( d2 ) . splitlines ()))) standardMsg = self . _truncateMessage ( standardMsg , diff ) self . fail ( self . _formatMessage ( msg , standardMsg )) assertEqual def assertEqual ( self , first , second , msg = None ) Fail if the two objects are unequal as determined by the '==' operator. View Source def assertEqual ( self , first , second , msg = None ) : \"\"\" Fail if the two objects are unequal as determined by the '==' operator . \"\"\" assertion_func = self . _getAssertEqualityFunc ( first , second ) assertion_func ( first , second , msg = msg ) assertEquals def assertEquals ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs ) assertFalse def assertFalse ( self , expr , msg = None ) Check that the expression is false. View Source def assertFalse ( self , expr , msg = None ) : \"\"\" Check that the expression is false. \"\"\" if expr : msg = self . _formatMessage ( msg , \" %s is not false \" % safe_repr ( expr )) raise self . failureException ( msg ) assertGreater def assertGreater ( self , a , b , msg = None ) Just like self.assertTrue(a > b), but with a nicer default message. View Source def assertGreater ( self , a , b , msg = None ) : \"\"\" Just like self.assertTrue(a > b), but with a nicer default message. \"\"\" if not a > b : standardMsg = ' %s not greater than %s ' % ( safe_repr ( a ) , safe_repr ( b )) self . fail ( self . _formatMessage ( msg , standardMsg )) assertGreaterEqual def assertGreaterEqual ( self , a , b , msg = None ) Just like self.assertTrue(a >= b), but with a nicer default message. View Source def assertGreaterEqual ( self , a , b , msg = None ) : \"\"\" Just like self.assertTrue(a >= b), but with a nicer default message. \"\"\" if not a >= b : standardMsg = ' %s not greater than or equal to %s ' % ( safe_repr ( a ) , safe_repr ( b )) self . fail ( self . _formatMessage ( msg , standardMsg )) assertIn def assertIn ( self , member , container , msg = None ) Just like self.assertTrue(a in b), but with a nicer default message. View Source def assertIn ( self , member , container , msg = None ) : \"\"\" Just like self.assertTrue(a in b), but with a nicer default message. \"\"\" if member not in container : standardMsg = ' %s not found in %s ' % ( safe_repr ( member ) , safe_repr ( container )) self . fail ( self . _formatMessage ( msg , standardMsg )) assertIs def assertIs ( self , expr1 , expr2 , msg = None ) Just like self.assertTrue(a is b), but with a nicer default message. View Source def assertIs ( self , expr1 , expr2 , msg = None ) : \"\"\" Just like self.assertTrue(a is b), but with a nicer default message. \"\"\" if expr1 is not expr2 : standardMsg = ' %s is not %s ' % ( safe_repr ( expr1 ) , safe_repr ( expr2 )) self . fail ( self . _formatMessage ( msg , standardMsg )) assertIsInstance def assertIsInstance ( self , obj , cls , msg = None ) Same as self.assertTrue(isinstance(obj, cls)), with a nicer default message. View Source def assertIsInstance ( self , obj , cls , msg = None ) : \"\"\" Same as self.assertTrue(isinstance(obj, cls)), with a nicer default message . \"\"\" if not isinstance ( obj , cls ) : standardMsg = ' %s is not an instance of %r ' % ( safe_repr ( obj ) , cls ) self . fail ( self . _formatMessage ( msg , standardMsg )) assertIsNone def assertIsNone ( self , obj , msg = None ) Same as self.assertTrue(obj is None), with a nicer default message. View Source def assertIsNone ( self , obj , msg = None ) : \"\"\" Same as self.assertTrue(obj is None), with a nicer default message. \"\"\" if obj is not None : standardMsg = ' %s is not None ' % ( safe_repr ( obj ) , ) self . fail ( self . _formatMessage ( msg , standardMsg )) assertIsNot def assertIsNot ( self , expr1 , expr2 , msg = None ) Just like self.assertTrue(a is not b), but with a nicer default message. View Source def assertIsNot ( self , expr1 , expr2 , msg = None ) : \"\"\" Just like self.assertTrue(a is not b), but with a nicer default message. \"\"\" if expr1 is expr2 : standardMsg = ' unexpectedly identical: %s ' % ( safe_repr ( expr1 ) , ) self . fail ( self . _formatMessage ( msg , standardMsg )) assertIsNotNone def assertIsNotNone ( self , obj , msg = None ) Included for symmetry with assertIsNone. View Source def assertIsNotNone ( self , obj , msg = None ) : \"\"\" Included for symmetry with assertIsNone. \"\"\" if obj is None : standardMsg = ' unexpectedly None ' self . fail ( self . _formatMessage ( msg , standardMsg )) assertLess def assertLess ( self , a , b , msg = None ) Just like self.assertTrue(a < b), but with a nicer default message. View Source def assertLess ( self , a , b , msg = None ) : \"\"\" Just like self.assertTrue(a < b), but with a nicer default message. \"\"\" if not a < b : standardMsg = ' %s not less than %s ' % ( safe_repr ( a ) , safe_repr ( b )) self . fail ( self . _formatMessage ( msg , standardMsg )) assertLessEqual def assertLessEqual ( self , a , b , msg = None ) Just like self.assertTrue(a <= b), but with a nicer default message. View Source def assertLessEqual ( self , a , b , msg = None ) : \"\"\" Just like self.assertTrue(a <= b), but with a nicer default message. \"\"\" if not a <= b : standardMsg = ' %s not less than or equal to %s ' % ( safe_repr ( a ) , safe_repr ( b )) self . fail ( self . _formatMessage ( msg , standardMsg )) assertListEqual def assertListEqual ( self , list1 , list2 , msg = None ) A list-specific equality assertion. Args: list1: The first list to compare. list2: The second list to compare. msg: Optional message to use on failure instead of a list of differences. View Source def assertListEqual ( self , list1 , list2 , msg = None ): \"\"\"A list-specific equality assertion. Args: list1: The first list to compare. list2: The second list to compare. msg: Optional message to use on failure instead of a list of differences. \"\"\" self . assertSequenceEqual ( list1 , list2 , msg , seq_type = list ) assertLogs def assertLogs ( self , logger = None , level = None ) Fail unless a log message of level level or higher is emitted on logger_name or its children. If omitted, level defaults to INFO and logger defaults to the root logger. This method must be used as a context manager, and will yield a recording object with two attributes: output and records . At the end of the context manager, the output attribute will be a list of the matching formatted log messages and the records attribute will be a list of the corresponding LogRecord objects. Example:: with self . assertLogs ( 'foo' , level = 'INFO' ) as cm : logging . getLogger ( 'foo' ). info ( 'first message' ) logging . getLogger ( 'foo.bar' ). error ( 'second message' ) self . assertEqual ( cm . output , [ 'INFO:foo:first message' , 'ERROR:foo.bar:second message' ]) View Source def assertLogs ( self , logger = None , level = None ) : \"\"\" Fail unless a log message of level *level* or higher is emitted on * logger_name * or its children . If omitted , * level * defaults to INFO and * logger * defaults to the root logger . This method must be used as a context manager , and will yield a recording object with two attributes : ` output ` and ` records `. At the end of the context manager , the ` output ` attribute will be a list of the matching formatted log messages and the ` records ` attribute will be a list of the corresponding LogRecord objects . Example :: with self . assertLogs ( ' foo ' , level = ' INFO ' ) as cm : logging . getLogger ( ' foo ' ) . info ( ' first message ' ) logging . getLogger ( ' foo.bar ' ) . error ( ' second message ' ) self . assertEqual ( cm . output , [ ' INFO:foo:first message ' , ' ERROR:foo.bar:second message ' ] ) \"\"\" return _AssertLogsContext ( self , logger , level ) assertMultiLineEqual def assertMultiLineEqual ( self , first , second , msg = None ) Assert that two multi-line strings are equal. View Source def assertMultiLineEqual ( self , first , second , msg = None ) : \"\"\" Assert that two multi-line strings are equal. \"\"\" self . assertIsInstance ( first , str , ' First argument is not a string ' ) self . assertIsInstance ( second , str , ' Second argument is not a string ' ) if first != second : # don ' t use difflib if the strings are too long if ( len ( first ) > self . _diffThreshold or len ( second ) > self . _diffThreshold ) : self . _baseAssertEqual ( first , second , msg ) firstlines = first . splitlines ( keepends = True ) secondlines = second . splitlines ( keepends = True ) if len ( firstlines ) == 1 and first . strip ( ' \\r \\n ' ) == first : firstlines = [ first + ' \\n ' ] secondlines = [ second + ' \\n ' ] standardMsg = ' %s != %s ' % _common_shorten_repr ( first , second ) diff = ' \\n ' + '' . join ( difflib . ndiff ( firstlines , secondlines )) standardMsg = self . _truncateMessage ( standardMsg , diff ) self . fail ( self . _formatMessage ( msg , standardMsg )) assertNotAlmostEqual def assertNotAlmostEqual ( self , first , second , places = None , msg = None , delta = None ) Fail if the two objects are equal as determined by their difference rounded to the given number of decimal places (default 7) and comparing to zero, or by comparing that the difference between the two objects is less than the given delta. Note that decimal places (from zero) are usually not the same as significant digits (measured from the most significant digit). Objects that are equal automatically fail. View Source def assertNotAlmostEqual ( self , first , second , places = None , msg = None , delta = None ) : \"\"\" Fail if the two objects are equal as determined by their difference rounded to the given number of decimal places ( default 7 ) and comparing to zero , or by comparing that the difference between the two objects is less than the given delta . Note that decimal places ( from zero ) are usually not the same as significant digits ( measured from the most significant digit ) . Objects that are equal automatically fail . \"\"\" if delta is not None and places is not None : raise TypeError ( \" specify delta or places not both \" ) diff = abs ( first - second ) if delta is not None : if not ( first == second ) and diff > delta : return standardMsg = ' %s == %s within %s delta (%s difference) ' % ( safe_repr ( first ) , safe_repr ( second ) , safe_repr ( delta ) , safe_repr ( diff )) else : if places is None : places = 7 if not ( first == second ) and round ( diff , places ) != 0 : return standardMsg = ' %s == %s within %r places ' % ( safe_repr ( first ) , safe_repr ( second ) , places ) msg = self . _formatMessage ( msg , standardMsg ) raise self . failureException ( msg ) assertNotAlmostEquals def assertNotAlmostEquals ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs ) assertNotEqual def assertNotEqual ( self , first , second , msg = None ) Fail if the two objects are equal as determined by the '!=' operator. View Source def assertNotEqual ( self , first , second , msg = None ) : \"\"\" Fail if the two objects are equal as determined by the '!=' operator . \"\"\" if not first != second : msg = self . _formatMessage ( msg , ' %s == %s ' % ( safe_repr ( first ) , safe_repr ( second ))) raise self . failureException ( msg ) assertNotEquals def assertNotEquals ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs ) assertNotIn def assertNotIn ( self , member , container , msg = None ) Just like self.assertTrue(a not in b), but with a nicer default message. View Source def assertNotIn ( self , member , container , msg = None ) : \"\"\" Just like self.assertTrue(a not in b), but with a nicer default message. \"\"\" if member in container : standardMsg = ' %s unexpectedly found in %s ' % ( safe_repr ( member ) , safe_repr ( container )) self . fail ( self . _formatMessage ( msg , standardMsg )) assertNotIsInstance def assertNotIsInstance ( self , obj , cls , msg = None ) Included for symmetry with assertIsInstance. View Source def assertNotIsInstance ( self , obj , cls , msg = None ) : \"\"\" Included for symmetry with assertIsInstance. \"\"\" if isinstance ( obj , cls ) : standardMsg = ' %s is an instance of %r ' % ( safe_repr ( obj ) , cls ) self . fail ( self . _formatMessage ( msg , standardMsg )) assertNotRegex def assertNotRegex ( self , text , unexpected_regex , msg = None ) Fail the test if the text matches the regular expression. View Source def assertNotRegex ( self , text , unexpected_regex , msg = None ) : \"\"\" Fail the test if the text matches the regular expression. \"\"\" if isinstance ( unexpected_regex , ( str , bytes )) : unexpected_regex = re . compile ( unexpected_regex ) match = unexpected_regex . search ( text ) if match : standardMsg = ' Regex matched: %r matches %r in %r ' % ( text [ match . start () : match . end () ], unexpected_regex . pattern , text ) # _formatMessage ensures the longMessage option is respected msg = self . _formatMessage ( msg , standardMsg ) raise self . failureException ( msg ) assertNotRegexpMatches def assertNotRegexpMatches ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs ) assertRaises def assertRaises ( self , expected_exception , * args , ** kwargs ) Fail unless an exception of class expected_exception is raised by the callable when invoked with specified positional and keyword arguments. If a different type of exception is raised, it will not be caught, and the test case will be deemed to have suffered an error, exactly as for an unexpected exception. If called with the callable and arguments omitted, will return a context object used like this:: with self . assertRaises ( SomeException ): do_something () An optional keyword argument 'msg' can be provided when assertRaises is used as a context object. The context manager keeps a reference to the exception as the 'exception' attribute. This allows you to inspect the exception after the assertion:: with self . assertRaises ( SomeException ) as cm : do_something () the_exception = cm . exception self . assertEqual ( the_exception . error_code , 3 ) View Source def assertRaises ( self , expected_exception , * args , ** kwargs ) : \"\"\" Fail unless an exception of class expected_exception is raised by the callable when invoked with specified positional and keyword arguments . If a different type of exception is raised , it will not be caught , and the test case will be deemed to have suffered an error , exactly as for an unexpected exception . If called with the callable and arguments omitted , will return a context object used like this :: with self . assertRaises ( SomeException ) : do_something () An optional keyword argument ' msg ' can be provided when assertRaises is used as a context object . The context manager keeps a reference to the exception as the ' exception ' attribute . This allows you to inspect the exception after the assertion :: with self . assertRaises ( SomeException ) as cm : do_something () the_exception = cm . exception self . assertEqual ( the_exception . error_code , 3 ) \"\"\" context = _AssertRaisesContext ( expected_exception , self ) try : return context . handle ( ' assertRaises ' , args , kwargs ) finally : # bpo - 23890 : manually break a reference cycle context = None assertRaisesRegex def assertRaisesRegex ( self , expected_exception , expected_regex , * args , ** kwargs ) Asserts that the message in a raised exception matches a regex. Args: expected_exception: Exception class expected to be raised. expected_regex: Regex (re.Pattern object or string) expected to be found in error message. args: Function to be called and extra positional args. kwargs: Extra kwargs. msg: Optional message used in case of failure. Can only be used when assertRaisesRegex is used as a context manager. View Source def assertRaisesRegex ( self , expected_exception , expected_regex , * args , ** kwargs ) : \"\"\" Asserts that the message in a raised exception matches a regex. Args : expected_exception : Exception class expected to be raised . expected_regex : Regex ( re . Pattern object or string ) expected to be found in error message . args : Function to be called and extra positional args . kwargs : Extra kwargs . msg : Optional message used in case of failure . Can only be used when assertRaisesRegex is used as a context manager . \"\"\" context = _AssertRaisesContext ( expected_exception , self , expected_regex ) return context . handle ( ' assertRaisesRegex ' , args , kwargs ) assertRaisesRegexp def assertRaisesRegexp ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs ) assertRegex def assertRegex ( self , text , expected_regex , msg = None ) Fail the test unless the text matches the regular expression. View Source def assertRegex ( self , text , expected_regex , msg = None ) : \"\"\" Fail the test unless the text matches the regular expression. \"\"\" if isinstance ( expected_regex , ( str , bytes )) : assert expected_regex , \" expected_regex must not be empty. \" expected_regex = re . compile ( expected_regex ) if not expected_regex . search ( text ) : standardMsg = \" Regex didn't match: %r not found in %r \" % ( expected_regex . pattern , text ) # _formatMessage ensures the longMessage option is respected msg = self . _formatMessage ( msg , standardMsg ) raise self . failureException ( msg ) assertRegexpMatches def assertRegexpMatches ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs ) assertSequenceEqual def assertSequenceEqual ( self , seq1 , seq2 , msg = None , seq_type = None ) An equality assertion for ordered sequences (like lists and tuples). For the purposes of this function, a valid ordered sequence type is one which can be indexed, has a length, and has an equality operator. Args: seq1: The first sequence to compare. seq2: The second sequence to compare. seq_type: The expected datatype of the sequences, or None if no datatype should be enforced. msg: Optional message to use on failure instead of a list of differences. View Source def assertSequenceEqual ( self , seq1 , seq2 , msg = None , seq_type = None ) : \"\"\" An equality assertion for ordered sequences (like lists and tuples). For the purposes of this function , a valid ordered sequence type is one which can be indexed , has a length , and has an equality operator . Args : seq1 : The first sequence to compare . seq2 : The second sequence to compare . seq_type : The expected datatype of the sequences , or None if no datatype should be enforced . msg : Optional message to use on failure instead of a list of differences . \"\"\" if seq_type is not None : seq_type_name = seq_type . __name__ if not isinstance ( seq1 , seq_type ) : raise self . failureException ( ' First sequence is not a %s: %s ' % ( seq_type_name , safe_repr ( seq1 ))) if not isinstance ( seq2 , seq_type ) : raise self . failureException ( ' Second sequence is not a %s: %s ' % ( seq_type_name , safe_repr ( seq2 ))) else : seq_type_name = \" sequence \" differing = None try : len1 = len ( seq1 ) except ( TypeError , NotImplementedError ) : differing = ' First %s has no length. Non-sequence? ' % ( seq_type_name ) if differing is None : try : len2 = len ( seq2 ) except ( TypeError , NotImplementedError ) : differing = ' Second %s has no length. Non-sequence? ' % ( seq_type_name ) if differing is None : if seq1 == seq2 : return differing = ' %ss differ: %s != %s \\n ' % ( ( seq_type_name . capitalize () , ) + _common_shorten_repr ( seq1 , seq2 )) for i in range ( min ( len1 , len2 )) : try : item1 = seq1 [ i ] except ( TypeError , IndexError , NotImplementedError ) : differing += ( ' \\n Unable to index element %d of first %s \\n ' % ( i , seq_type_name )) break try : item2 = seq2 [ i ] except ( TypeError , IndexError , NotImplementedError ) : differing += ( ' \\n Unable to index element %d of second %s \\n ' % ( i , seq_type_name )) break if item1 != item2 : differing += ( ' \\n First differing element %d: \\n %s \\n %s \\n ' % (( i , ) + _common_shorten_repr ( item1 , item2 ))) break else : if ( len1 == len2 and seq_type is None and type ( seq1 ) != type ( seq2 )) : # The sequences are the same , but have differing types . return if len1 > len2 : differing += ( ' \\n First %s contains %d additional ' ' elements. \\n ' % ( seq_type_name , len1 - len2 )) try : differing += ( ' First extra element %d: \\n %s \\n ' % ( len2 , safe_repr ( seq1 [ len2 ] ))) except ( TypeError , IndexError , NotImplementedError ) : differing += ( ' Unable to index element %d ' ' of first %s \\n ' % ( len2 , seq_type_name )) elif len1 < len2 : differing += ( ' \\n Second %s contains %d additional ' ' elements. \\n ' % ( seq_type_name , len2 - len1 )) try : differing += ( ' First extra element %d: \\n %s \\n ' % ( len1 , safe_repr ( seq2 [ len1 ] ))) except ( TypeError , IndexError , NotImplementedError ) : differing += ( ' Unable to index element %d ' ' of second %s \\n ' % ( len1 , seq_type_name )) standardMsg = differing diffMsg = ' \\n ' + ' \\n ' . join ( difflib . ndiff ( pprint . pformat ( seq1 ) . splitlines () , pprint . pformat ( seq2 ) . splitlines ())) standardMsg = self . _truncateMessage ( standardMsg , diffMsg ) msg = self . _formatMessage ( msg , standardMsg ) self . fail ( msg ) assertSetEqual def assertSetEqual ( self , set1 , set2 , msg = None ) A set-specific equality assertion. Args: set1: The first set to compare. set2: The second set to compare. msg: Optional message to use on failure instead of a list of differences. assertSetEqual uses ducktyping to support different types of sets, and is optimized for sets specifically (parameters must support a difference method). View Source def assertSetEqual ( self , set1 , set2 , msg = None ) : \"\"\" A set-specific equality assertion. Args : set1 : The first set to compare . set2 : The second set to compare . msg : Optional message to use on failure instead of a list of differences . assertSetEqual uses ducktyping to support different types of sets , and is optimized for sets specifically ( parameters must support a difference method ) . \"\"\" try : difference1 = set1 . difference ( set2 ) except TypeError as e : self . fail ( ' invalid type when attempting set difference: %s ' % e ) except AttributeError as e : self . fail ( ' first argument does not support set difference: %s ' % e ) try : difference2 = set2 . difference ( set1 ) except TypeError as e : self . fail ( ' invalid type when attempting set difference: %s ' % e ) except AttributeError as e : self . fail ( ' second argument does not support set difference: %s ' % e ) if not ( difference1 or difference2 ) : return lines = [] if difference1 : lines . append ( ' Items in the first set but not the second: ' ) for item in difference1 : lines . append ( repr ( item )) if difference2 : lines . append ( ' Items in the second set but not the first: ' ) for item in difference2 : lines . append ( repr ( item )) standardMsg = ' \\n ' . join ( lines ) self . fail ( self . _formatMessage ( msg , standardMsg )) assertTrue def assertTrue ( self , expr , msg = None ) Check that the expression is true. View Source def assertTrue ( self , expr , msg = None ) : \"\"\" Check that the expression is true. \"\"\" if not expr : msg = self . _formatMessage ( msg , \" %s is not true \" % safe_repr ( expr )) raise self . failureException ( msg ) assertTupleEqual def assertTupleEqual ( self , tuple1 , tuple2 , msg = None ) A tuple-specific equality assertion. Args: tuple1: The first tuple to compare. tuple2: The second tuple to compare. msg: Optional message to use on failure instead of a list of differences. View Source def assertTupleEqual ( self , tuple1 , tuple2 , msg = None ): \"\"\"A tuple-specific equality assertion. Args: tuple1: The first tuple to compare. tuple2: The second tuple to compare. msg: Optional message to use on failure instead of a list of differences. \"\"\" self . assertSequenceEqual ( tuple1 , tuple2 , msg , seq_type = tuple ) assertWarns def assertWarns ( self , expected_warning , * args , ** kwargs ) Fail unless a warning of class warnClass is triggered by the callable when invoked with specified positional and keyword arguments. If a different type of warning is triggered, it will not be handled: depending on the other warning filtering rules in effect, it might be silenced, printed out, or raised as an exception. If called with the callable and arguments omitted, will return a context object used like this:: with self . assertWarns ( SomeWarning ): do_something () An optional keyword argument 'msg' can be provided when assertWarns is used as a context object. The context manager keeps a reference to the first matching warning as the 'warning' attribute; similarly, the 'filename' and 'lineno' attributes give you information about the line of Python code from which the warning was triggered. This allows you to inspect the warning after the assertion:: with self . assertWarns ( SomeWarning ) as cm : do_something () the_warning = cm . warning self . assertEqual ( the_warning . some_attribute , 147 ) View Source def assertWarns ( self , expected_warning , * args , ** kwargs ) : \"\"\" Fail unless a warning of class warnClass is triggered by the callable when invoked with specified positional and keyword arguments . If a different type of warning is triggered , it will not be handled : depending on the other warning filtering rules in effect , it might be silenced , printed out , or raised as an exception . If called with the callable and arguments omitted , will return a context object used like this :: with self . assertWarns ( SomeWarning ) : do_something () An optional keyword argument ' msg ' can be provided when assertWarns is used as a context object . The context manager keeps a reference to the first matching warning as the ' warning ' attribute ; similarly, the 'filename' and ' lineno ' attributes give you information about the line of Python code from which the warning was triggered . This allows you to inspect the warning after the assertion :: with self . assertWarns ( SomeWarning ) as cm : do_something () the_warning = cm . warning self . assertEqual ( the_warning . some_attribute , 147 ) \"\"\" context = _AssertWarnsContext ( expected_warning , self ) return context . handle ( ' assertWarns ' , args , kwargs ) assertWarnsRegex def assertWarnsRegex ( self , expected_warning , expected_regex , * args , ** kwargs ) Asserts that the message in a triggered warning matches a regexp. Basic functioning is similar to assertWarns() with the addition that only warnings whose messages also match the regular expression are considered successful matches. Args: expected_warning: Warning class expected to be triggered. expected_regex: Regex (re.Pattern object or string) expected to be found in error message. args: Function to be called and extra positional args. kwargs: Extra kwargs. msg: Optional message used in case of failure. Can only be used when assertWarnsRegex is used as a context manager. View Source def assertWarnsRegex ( self , expected_warning , expected_regex , * args , ** kwargs ) : \"\"\" Asserts that the message in a triggered warning matches a regexp. Basic functioning is similar to assertWarns () with the addition that only warnings whose messages also match the regular expression are considered successful matches . Args : expected_warning : Warning class expected to be triggered . expected_regex : Regex ( re . Pattern object or string ) expected to be found in error message . args : Function to be called and extra positional args . kwargs : Extra kwargs . msg : Optional message used in case of failure . Can only be used when assertWarnsRegex is used as a context manager . \"\"\" context = _AssertWarnsContext ( expected_warning , self , expected_regex ) return context . handle ( ' assertWarnsRegex ' , args , kwargs ) assert_ def assert_ ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs ) countTestCases def countTestCases ( self ) View Source def countTestCases ( self ) : return 1 debug def debug ( self ) Run the test without collecting errors in a TestResult View Source def debug ( self ) : \"\"\" Run the test without collecting errors in a TestResult \"\"\" self . setUp () getattr ( self , self . _testMethodName )() self . tearDown () while self . _cleanups : function , args , kwargs = self . _cleanups . pop ( - 1 ) function ( * args , ** kwargs ) defaultTestResult def defaultTestResult ( self ) View Source def defaultTestResult ( self ) : return result . TestResult () doCleanups def doCleanups ( self ) Execute all cleanup functions. Normally called for you after tearDown. View Source def doCleanups ( self ) : \"\"\" Execute all cleanup functions. Normally called for you after tearDown . \"\"\" outcome = self . _outcome or _Outcome () while self . _cleanups : function , args , kwargs = self . _cleanups . pop () with outcome . testPartExecutor ( self ) : function ( * args , ** kwargs ) # return this for backwards compatibility # even though we no longer us it internally return outcome . success fail def fail ( self , msg = None ) Fail immediately, with the given message. View Source def fail ( self , msg = None ): \"\"\"Fail immediately, with the given message.\"\"\" raise self . failureException ( msg ) failIf def failIf ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs ) failIfAlmostEqual def failIfAlmostEqual ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs ) failIfEqual def failIfEqual ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs ) failUnless def failUnless ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs ) failUnlessAlmostEqual def failUnlessAlmostEqual ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs ) failUnlessEqual def failUnlessEqual ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs ) failUnlessRaises def failUnlessRaises ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs ) id def id ( self ) View Source def id ( self ) : return \" %s.%s \" % ( strclass ( self . __class__ ) , self . _testMethodName ) run def run ( self , result = None ) View Source def run ( self , result = None ) : orig_result = result if result is None : result = self . defaultTestResult () startTestRun = getattr ( result , ' startTestRun ' , None ) if startTestRun is not None : startTestRun () result . startTest ( self ) testMethod = getattr ( self , self . _testMethodName ) if ( getattr ( self . __class__ , \" __unittest_skip__ \" , False ) or getattr ( testMethod , \" __unittest_skip__ \" , False )) : # If the class or method was skipped . try : skip_why = ( getattr ( self . __class__ , ' __unittest_skip_why__ ' , '' ) or getattr ( testMethod , ' __unittest_skip_why__ ' , '' )) self . _addSkip ( result , self , skip_why ) finally : result . stopTest ( self ) return expecting_failure_method = getattr ( testMethod , \" __unittest_expecting_failure__ \" , False ) expecting_failure_class = getattr ( self , \" __unittest_expecting_failure__ \" , False ) expecting_failure = expecting_failure_class or expecting_failure_method outcome = _Outcome ( result ) try : self . _outcome = outcome with outcome . testPartExecutor ( self ) : self . setUp () if outcome . success : outcome . expecting_failure = expecting_failure with outcome . testPartExecutor ( self , isTest = True ) : testMethod () outcome . expecting_failure = False with outcome . testPartExecutor ( self ) : self . tearDown () self . doCleanups () for test , reason in outcome . skipped : self . _addSkip ( result , test , reason ) self . _feedErrorsToResult ( result , outcome . errors ) if outcome . success : if expecting_failure : if outcome . expectedFailure : self . _addExpectedFailure ( result , outcome . expectedFailure ) else : self . _addUnexpectedSuccess ( result ) else : result . addSuccess ( self ) return result finally : result . stopTest ( self ) if orig_result is None : stopTestRun = getattr ( result , ' stopTestRun ' , None ) if stopTestRun is not None : stopTestRun () # explicitly break reference cycles : # outcome . errors -> frame -> outcome -> outcome . errors # outcome . expectedFailure -> frame -> outcome -> outcome . expectedFailure outcome . errors . clear () outcome . expectedFailure = None # clear the outcome , no more needed self . _outcome = None setUp def setUp ( self ) Hook method for setting up the test fixture before exercising it. View Source def setUp ( self ) : self . desired_capabilities [ 'name' ] = self . id () sauce_url = \"http://%s:%s@ondemand.saucelabs.com:80/wd/hub\" self . driver = webdriver . Remote ( desired_capabilities = self . desired_capabilities , command_executor = sauce_url % ( SAUCE_USERNAME , SAUCE_ACCESS_KEY ) ) self . driver . implicitly_wait ( 30 ) shortDescription def shortDescription ( self ) Returns a one-line description of the test, or None if no description has been provided. The default implementation of this method returns the first line of the specified test method's docstring. View Source def shortDescription ( self ) : \"\"\" Returns a one-line description of the test, or None if no description has been provided . The default implementation of this method returns the first line of the specified test method ' s docstring. \"\"\" doc = self . _testMethodDoc return doc and doc . split ( \" \\n \" ) [ 0 ]. strip () or None skipTest def skipTest ( self , reason ) Skip this test. View Source def skipTest ( self , reason ): \"\"\"Skip this test.\"\"\" raise SkipTest ( reason ) subTest def subTest ( self , msg =< object object at 0x10a68b4d0 > , ** params ) Return a context manager that will return the enclosed block of code in a subtest identified by the optional message and keyword parameters. A failure in the subtest marks the test case as failed but resumes execution at the end of the enclosed block, allowing further test code to be executed. View Source @ contextlib . contextmanager def subTest ( self , msg = _subtest_msg_sentinel , ** params ) : \"\"\" Return a context manager that will return the enclosed block of code in a subtest identified by the optional message and keyword parameters . A failure in the subtest marks the test case as failed but resumes execution at the end of the enclosed block , allowing further test code to be executed . \"\"\" if self . _outcome is None or not self . _outcome . result_supports_subtests : yield return parent = self . _subtest if parent is None : params_map = _OrderedChainMap ( params ) else : params_map = parent . params . new_child ( params ) self . _subtest = _SubTest ( self , msg , params_map ) try : with self . _outcome . testPartExecutor ( self . _subtest , isTest = True ) : yield if not self . _outcome . success : result = self . _outcome . result if result is not None and result . failfast : raise _ShouldStop elif self . _outcome . expectedFailure : # If the test is expecting a failure , we really want to # stop now and register the expected failure . raise _ShouldStop finally : self . _subtest = parent tearDown def tearDown ( self ) Hook method for deconstructing the test fixture after testing it. View Source def tearDown ( self ) : print ( \" Link to your job: https://saucelabs.com/jobs/%s \" % self . driver . session_id ) try : if sys . exc_info () == ( None , None , None ) : sauce . jobs . update_job ( self . driver . session_id , passed = True ) else : sauce . jobs . update_job ( self . driver . session_id , passed = False ) finally : self . driver . quit ()","title":"Saucetestcase"},{"location":"reference/appium/saucetestcase/#module-appiumsaucetestcase","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # pylint: disable=import-error,no-member from __future__ import print_function import os import sys import unittest from appium import webdriver from sauceclient import SauceClient SAUCE_USERNAME = os . environ . get ( 'SAUCE_USERNAME' ) SAUCE_ACCESS_KEY = os . environ . get ( 'SAUCE_ACCESS_KEY' ) sauce = SauceClient ( SAUCE_USERNAME , SAUCE_ACCESS_KEY ) def on_platforms ( platforms ): def decorator ( base_class ): module = sys . modules [ base_class . __module__ ] . __dict__ for i , platform in enumerate ( platforms ): name = \" %s _ %s \" % ( base_class . __name__ , i + 1 ) d_caps = { 'desired_capabilities' : platform } module [ name ] = type ( name , ( base_class ,), d_caps ) return decorator class SauceTestCase ( unittest . TestCase ): def setUp ( self ): self . desired_capabilities [ 'name' ] = self . id () sauce_url = \"http:// %s : %s @ondemand.saucelabs.com:80/wd/hub\" self . driver = webdriver . Remote ( desired_capabilities = self . desired_capabilities , command_executor = sauce_url % ( SAUCE_USERNAME , SAUCE_ACCESS_KEY ) ) self . driver . implicitly_wait ( 30 ) def tearDown ( self ): print ( \"Link to your job: https://saucelabs.com/jobs/ %s \" % self . driver . session_id ) try : if sys . exc_info () == ( None , None , None ): sauce . jobs . update_job ( self . driver . session_id , passed = True ) else : sauce . jobs . update_job ( self . driver . session_id , passed = False ) finally : self . driver . quit ()","title":"Module appium.saucetestcase"},{"location":"reference/appium/saucetestcase/#variables","text":"SAUCE_ACCESS_KEY SAUCE_USERNAME sauce","title":"Variables"},{"location":"reference/appium/saucetestcase/#functions","text":"","title":"Functions"},{"location":"reference/appium/saucetestcase/#on_platforms","text":"def on_platforms ( platforms ) View Source def on_platforms ( platforms ) : def decorator ( base_class ) : module = sys . modules [ base_class . __module__ ]. __dict__ for i , platform in enumerate ( platforms ) : name = \" %s_%s \" % ( base_class . __name__ , i + 1 ) d_caps = { ' desired_capabilities ' : platform } module [ name ] = type ( name , ( base_class , ) , d_caps ) return decorator","title":"on_platforms"},{"location":"reference/appium/saucetestcase/#classes","text":"","title":"Classes"},{"location":"reference/appium/saucetestcase/#saucetestcase","text":"class SauceTestCase ( methodName = 'runTest' ) A class whose instances are single test cases. By default, the test code itself should be placed in a method named 'runTest'. If the fixture may be used for many test cases, create as many test methods as are needed. When instantiating such a TestCase subclass, specify in the constructor arguments the name of the test method that the instance is to execute. Test authors should subclass TestCase for their own tests. Construction and deconstruction of the test's environment ('fixture') can be implemented by overriding the 'setUp' and 'tearDown' methods respectively. If it is necessary to override the init method, the base class init method must always be called. It is important that subclasses should not change the signature of their init method, since instances of the classes are instantiated automatically by parts of the framework in order to be run. When subclassing TestCase, you can set these attributes: * failureException: determines which exception will be raised when the instance's assertion methods fail; test methods raising this exception will be deemed to have 'failed' rather than 'errored'. * longMessage: determines whether long messages (including repr of objects used in assert methods) will be printed on failure in addition to any explicit message passed. * maxDiff: sets the maximum length of a diff in failure messages by assert methods using difflib. It is looked up as an instance attribute so can be configured by individual tests if required. View Source class SauceTestCase ( unittest . TestCase ) : def setUp ( self ) : self . desired_capabilities [ ' name ' ] = self . id () sauce_url = \" http://%s:%s@ondemand.saucelabs.com:80/wd/hub \" self . driver = webdriver . Remote ( desired_capabilities = self . desired_capabilities , command_executor = sauce_url % ( SAUCE_USERNAME , SAUCE_ACCESS_KEY ) ) self . driver . implicitly_wait ( 30 ) def tearDown ( self ) : print ( \" Link to your job: https://saucelabs.com/jobs/%s \" % self . driver . session_id ) try : if sys . exc_info () == ( None , None , None ) : sauce . jobs . update_job ( self . driver . session_id , passed = True ) else : sauce . jobs . update_job ( self . driver . session_id , passed = False ) finally : self . driver . quit ()","title":"SauceTestCase"},{"location":"reference/appium/saucetestcase/#ancestors-in-mro","text":"unittest.case.TestCase","title":"Ancestors (in MRO)"},{"location":"reference/appium/saucetestcase/#class-variables","text":"failureException longMessage maxDiff","title":"Class variables"},{"location":"reference/appium/saucetestcase/#static-methods","text":"","title":"Static methods"},{"location":"reference/appium/saucetestcase/#setupclass","text":"def setUpClass ( ) Hook method for setting up class fixture before running tests in the class. View Source @ classmethod def setUpClass ( cls ) : \" Hook method for setting up class fixture before running tests in the class. \"","title":"setUpClass"},{"location":"reference/appium/saucetestcase/#teardownclass","text":"def tearDownClass ( ) Hook method for deconstructing the class fixture after running all tests in the class. View Source @ classmethod def tearDownClass ( cls ) : \" Hook method for deconstructing the class fixture after running all tests in the class. \"","title":"tearDownClass"},{"location":"reference/appium/saucetestcase/#methods","text":"","title":"Methods"},{"location":"reference/appium/saucetestcase/#addcleanup","text":"def addCleanup ( self , function , * args , ** kwargs ) Add a function, with arguments, to be called when the test is completed. Functions added are called on a LIFO basis and are called after tearDown on test failure or success. Cleanup items are called even if setUp fails (unlike tearDown). View Source def addCleanup ( self , function , * args , ** kwargs ) : \"\"\" Add a function, with arguments, to be called when the test is completed . Functions added are called on a LIFO basis and are called after tearDown on test failure or success . Cleanup items are called even if setUp fails ( unlike tearDown ) . \"\"\" self . _cleanups . append (( function , args , kwargs ))","title":"addCleanup"},{"location":"reference/appium/saucetestcase/#addtypeequalityfunc","text":"def addTypeEqualityFunc ( self , typeobj , function ) Add a type specific assertEqual style function to compare a type. This method is for use by TestCase subclasses that need to register their own type equality functions to provide nicer error messages. Args: typeobj: The data type to call this function on when both values are of the same type in assertEqual(). function: The callable taking two arguments and an optional msg= argument that raises self.failureException with a useful error message when the two arguments are not equal. View Source def addTypeEqualityFunc ( self , typeobj , function ) : \"\"\" Add a type specific assertEqual style function to compare a type. This method is for use by TestCase subclasses that need to register their own type equality functions to provide nicer error messages . Args : typeobj : The data type to call this function on when both values are of the same type in assertEqual () . function : The callable taking two arguments and an optional msg = argument that raises self . failureException with a useful error message when the two arguments are not equal . \"\"\" self . _type_equality_funcs [ typeobj ] = function","title":"addTypeEqualityFunc"},{"location":"reference/appium/saucetestcase/#assertalmostequal","text":"def assertAlmostEqual ( self , first , second , places = None , msg = None , delta = None ) Fail if the two objects are unequal as determined by their difference rounded to the given number of decimal places (default 7) and comparing to zero, or by comparing that the difference between the two objects is more than the given delta. Note that decimal places (from zero) are usually not the same as significant digits (measured from the most significant digit). If the two objects compare equal then they will automatically compare almost equal. View Source def assertAlmostEqual ( self , first , second , places = None , msg = None , delta = None ) : \"\"\" Fail if the two objects are unequal as determined by their difference rounded to the given number of decimal places ( default 7 ) and comparing to zero , or by comparing that the difference between the two objects is more than the given delta . Note that decimal places ( from zero ) are usually not the same as significant digits ( measured from the most significant digit ) . If the two objects compare equal then they will automatically compare almost equal . \"\"\" if first == second : # shortcut return if delta is not None and places is not None : raise TypeError ( \" specify delta or places not both \" ) diff = abs ( first - second ) if delta is not None : if diff <= delta : return standardMsg = ' %s != %s within %s delta (%s difference) ' % ( safe_repr ( first ) , safe_repr ( second ) , safe_repr ( delta ) , safe_repr ( diff )) else : if places is None : places = 7 if round ( diff , places ) == 0 : return standardMsg = ' %s != %s within %r places (%s difference) ' % ( safe_repr ( first ) , safe_repr ( second ) , places , safe_repr ( diff )) msg = self . _formatMessage ( msg , standardMsg ) raise self . failureException ( msg )","title":"assertAlmostEqual"},{"location":"reference/appium/saucetestcase/#assertalmostequals","text":"def assertAlmostEquals ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs )","title":"assertAlmostEquals"},{"location":"reference/appium/saucetestcase/#assertcountequal","text":"def assertCountEqual ( self , first , second , msg = None ) An unordered sequence comparison asserting that the same elements, regardless of order. If the same element occurs more than once, it verifies that the elements occur the same number of times. self . assertEqual ( Counter ( list ( first )), Counter ( list ( second ))) Example: - [0, 1, 1] and [1, 0, 1] compare equal. - [0, 0, 1] and [0, 1] compare unequal. View Source def assertCountEqual ( self , first , second , msg = None ): \"\"\"An unordered sequence comparison asserting that the same elements, regardless of order. If the same element occurs more than once, it verifies that the elements occur the same number of times. self.assertEqual(Counter(list(first)), Counter(list(second))) Example: - [0, 1, 1] and [1, 0, 1] compare equal. - [0, 0, 1] and [0, 1] compare unequal. \"\"\" first_seq , second_seq = list ( first ), list ( second ) try: first = collections . Counter ( first_seq ) second = collections . Counter ( second_seq ) except TypeError: # Handle case with unhashable elements differences = _count_diff_all_purpose ( first_seq , second_seq ) else: if first == second: return differences = _count_diff_hashable ( first_seq , second_seq ) if differences: standardMsg = 'Element counts were not equal:\\n' lines = [ 'First has %d, Second has %d: %r' % diff for diff in differences ] diffMsg = '\\n' . join ( lines ) standardMsg = self . _truncateMessage ( standardMsg , diffMsg ) msg = self . _formatMessage ( msg , standardMsg ) self . fail ( msg )","title":"assertCountEqual"},{"location":"reference/appium/saucetestcase/#assertdictcontainssubset","text":"def assertDictContainsSubset ( self , subset , dictionary , msg = None ) Checks whether dictionary is a superset of subset. View Source def assertDictContainsSubset ( self , subset , dictionary , msg = None ) : \"\"\" Checks whether dictionary is a superset of subset. \"\"\" warnings . warn ( ' assertDictContainsSubset is deprecated ' , DeprecationWarning ) missing = [] mismatched = [] for key , value in subset . items () : if key not in dictionary : missing . append ( key ) elif value != dictionary [ key ]: mismatched . append ( ' %s, expected: %s, actual: %s ' % ( safe_repr ( key ) , safe_repr ( value ) , safe_repr ( dictionary [ key ] ))) if not ( missing or mismatched ) : return standardMsg = '' if missing : standardMsg = ' Missing: %s ' % ' , ' . join ( safe_repr ( m ) for m in missing ) if mismatched : if standardMsg : standardMsg += ' ; ' standardMsg += ' Mismatched values: %s ' % ' , ' . join ( mismatched ) self . fail ( self . _formatMessage ( msg , standardMsg ))","title":"assertDictContainsSubset"},{"location":"reference/appium/saucetestcase/#assertdictequal","text":"def assertDictEqual ( self , d1 , d2 , msg = None ) View Source def assertDictEqual ( self , d1 , d2 , msg = None ) : self . assertIsInstance ( d1 , dict , ' First argument is not a dictionary ' ) self . assertIsInstance ( d2 , dict , ' Second argument is not a dictionary ' ) if d1 != d2 : standardMsg = ' %s != %s ' % _common_shorten_repr ( d1 , d2 ) diff = ( ' \\n ' + ' \\n ' . join ( difflib . ndiff ( pprint . pformat ( d1 ) . splitlines () , pprint . pformat ( d2 ) . splitlines ()))) standardMsg = self . _truncateMessage ( standardMsg , diff ) self . fail ( self . _formatMessage ( msg , standardMsg ))","title":"assertDictEqual"},{"location":"reference/appium/saucetestcase/#assertequal","text":"def assertEqual ( self , first , second , msg = None ) Fail if the two objects are unequal as determined by the '==' operator. View Source def assertEqual ( self , first , second , msg = None ) : \"\"\" Fail if the two objects are unequal as determined by the '==' operator . \"\"\" assertion_func = self . _getAssertEqualityFunc ( first , second ) assertion_func ( first , second , msg = msg )","title":"assertEqual"},{"location":"reference/appium/saucetestcase/#assertequals","text":"def assertEquals ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs )","title":"assertEquals"},{"location":"reference/appium/saucetestcase/#assertfalse","text":"def assertFalse ( self , expr , msg = None ) Check that the expression is false. View Source def assertFalse ( self , expr , msg = None ) : \"\"\" Check that the expression is false. \"\"\" if expr : msg = self . _formatMessage ( msg , \" %s is not false \" % safe_repr ( expr )) raise self . failureException ( msg )","title":"assertFalse"},{"location":"reference/appium/saucetestcase/#assertgreater","text":"def assertGreater ( self , a , b , msg = None ) Just like self.assertTrue(a > b), but with a nicer default message. View Source def assertGreater ( self , a , b , msg = None ) : \"\"\" Just like self.assertTrue(a > b), but with a nicer default message. \"\"\" if not a > b : standardMsg = ' %s not greater than %s ' % ( safe_repr ( a ) , safe_repr ( b )) self . fail ( self . _formatMessage ( msg , standardMsg ))","title":"assertGreater"},{"location":"reference/appium/saucetestcase/#assertgreaterequal","text":"def assertGreaterEqual ( self , a , b , msg = None ) Just like self.assertTrue(a >= b), but with a nicer default message. View Source def assertGreaterEqual ( self , a , b , msg = None ) : \"\"\" Just like self.assertTrue(a >= b), but with a nicer default message. \"\"\" if not a >= b : standardMsg = ' %s not greater than or equal to %s ' % ( safe_repr ( a ) , safe_repr ( b )) self . fail ( self . _formatMessage ( msg , standardMsg ))","title":"assertGreaterEqual"},{"location":"reference/appium/saucetestcase/#assertin","text":"def assertIn ( self , member , container , msg = None ) Just like self.assertTrue(a in b), but with a nicer default message. View Source def assertIn ( self , member , container , msg = None ) : \"\"\" Just like self.assertTrue(a in b), but with a nicer default message. \"\"\" if member not in container : standardMsg = ' %s not found in %s ' % ( safe_repr ( member ) , safe_repr ( container )) self . fail ( self . _formatMessage ( msg , standardMsg ))","title":"assertIn"},{"location":"reference/appium/saucetestcase/#assertis","text":"def assertIs ( self , expr1 , expr2 , msg = None ) Just like self.assertTrue(a is b), but with a nicer default message. View Source def assertIs ( self , expr1 , expr2 , msg = None ) : \"\"\" Just like self.assertTrue(a is b), but with a nicer default message. \"\"\" if expr1 is not expr2 : standardMsg = ' %s is not %s ' % ( safe_repr ( expr1 ) , safe_repr ( expr2 )) self . fail ( self . _formatMessage ( msg , standardMsg ))","title":"assertIs"},{"location":"reference/appium/saucetestcase/#assertisinstance","text":"def assertIsInstance ( self , obj , cls , msg = None ) Same as self.assertTrue(isinstance(obj, cls)), with a nicer default message. View Source def assertIsInstance ( self , obj , cls , msg = None ) : \"\"\" Same as self.assertTrue(isinstance(obj, cls)), with a nicer default message . \"\"\" if not isinstance ( obj , cls ) : standardMsg = ' %s is not an instance of %r ' % ( safe_repr ( obj ) , cls ) self . fail ( self . _formatMessage ( msg , standardMsg ))","title":"assertIsInstance"},{"location":"reference/appium/saucetestcase/#assertisnone","text":"def assertIsNone ( self , obj , msg = None ) Same as self.assertTrue(obj is None), with a nicer default message. View Source def assertIsNone ( self , obj , msg = None ) : \"\"\" Same as self.assertTrue(obj is None), with a nicer default message. \"\"\" if obj is not None : standardMsg = ' %s is not None ' % ( safe_repr ( obj ) , ) self . fail ( self . _formatMessage ( msg , standardMsg ))","title":"assertIsNone"},{"location":"reference/appium/saucetestcase/#assertisnot","text":"def assertIsNot ( self , expr1 , expr2 , msg = None ) Just like self.assertTrue(a is not b), but with a nicer default message. View Source def assertIsNot ( self , expr1 , expr2 , msg = None ) : \"\"\" Just like self.assertTrue(a is not b), but with a nicer default message. \"\"\" if expr1 is expr2 : standardMsg = ' unexpectedly identical: %s ' % ( safe_repr ( expr1 ) , ) self . fail ( self . _formatMessage ( msg , standardMsg ))","title":"assertIsNot"},{"location":"reference/appium/saucetestcase/#assertisnotnone","text":"def assertIsNotNone ( self , obj , msg = None ) Included for symmetry with assertIsNone. View Source def assertIsNotNone ( self , obj , msg = None ) : \"\"\" Included for symmetry with assertIsNone. \"\"\" if obj is None : standardMsg = ' unexpectedly None ' self . fail ( self . _formatMessage ( msg , standardMsg ))","title":"assertIsNotNone"},{"location":"reference/appium/saucetestcase/#assertless","text":"def assertLess ( self , a , b , msg = None ) Just like self.assertTrue(a < b), but with a nicer default message. View Source def assertLess ( self , a , b , msg = None ) : \"\"\" Just like self.assertTrue(a < b), but with a nicer default message. \"\"\" if not a < b : standardMsg = ' %s not less than %s ' % ( safe_repr ( a ) , safe_repr ( b )) self . fail ( self . _formatMessage ( msg , standardMsg ))","title":"assertLess"},{"location":"reference/appium/saucetestcase/#assertlessequal","text":"def assertLessEqual ( self , a , b , msg = None ) Just like self.assertTrue(a <= b), but with a nicer default message. View Source def assertLessEqual ( self , a , b , msg = None ) : \"\"\" Just like self.assertTrue(a <= b), but with a nicer default message. \"\"\" if not a <= b : standardMsg = ' %s not less than or equal to %s ' % ( safe_repr ( a ) , safe_repr ( b )) self . fail ( self . _formatMessage ( msg , standardMsg ))","title":"assertLessEqual"},{"location":"reference/appium/saucetestcase/#assertlistequal","text":"def assertListEqual ( self , list1 , list2 , msg = None ) A list-specific equality assertion. Args: list1: The first list to compare. list2: The second list to compare. msg: Optional message to use on failure instead of a list of differences. View Source def assertListEqual ( self , list1 , list2 , msg = None ): \"\"\"A list-specific equality assertion. Args: list1: The first list to compare. list2: The second list to compare. msg: Optional message to use on failure instead of a list of differences. \"\"\" self . assertSequenceEqual ( list1 , list2 , msg , seq_type = list )","title":"assertListEqual"},{"location":"reference/appium/saucetestcase/#assertlogs","text":"def assertLogs ( self , logger = None , level = None ) Fail unless a log message of level level or higher is emitted on logger_name or its children. If omitted, level defaults to INFO and logger defaults to the root logger. This method must be used as a context manager, and will yield a recording object with two attributes: output and records . At the end of the context manager, the output attribute will be a list of the matching formatted log messages and the records attribute will be a list of the corresponding LogRecord objects. Example:: with self . assertLogs ( 'foo' , level = 'INFO' ) as cm : logging . getLogger ( 'foo' ). info ( 'first message' ) logging . getLogger ( 'foo.bar' ). error ( 'second message' ) self . assertEqual ( cm . output , [ 'INFO:foo:first message' , 'ERROR:foo.bar:second message' ]) View Source def assertLogs ( self , logger = None , level = None ) : \"\"\" Fail unless a log message of level *level* or higher is emitted on * logger_name * or its children . If omitted , * level * defaults to INFO and * logger * defaults to the root logger . This method must be used as a context manager , and will yield a recording object with two attributes : ` output ` and ` records `. At the end of the context manager , the ` output ` attribute will be a list of the matching formatted log messages and the ` records ` attribute will be a list of the corresponding LogRecord objects . Example :: with self . assertLogs ( ' foo ' , level = ' INFO ' ) as cm : logging . getLogger ( ' foo ' ) . info ( ' first message ' ) logging . getLogger ( ' foo.bar ' ) . error ( ' second message ' ) self . assertEqual ( cm . output , [ ' INFO:foo:first message ' , ' ERROR:foo.bar:second message ' ] ) \"\"\" return _AssertLogsContext ( self , logger , level )","title":"assertLogs"},{"location":"reference/appium/saucetestcase/#assertmultilineequal","text":"def assertMultiLineEqual ( self , first , second , msg = None ) Assert that two multi-line strings are equal. View Source def assertMultiLineEqual ( self , first , second , msg = None ) : \"\"\" Assert that two multi-line strings are equal. \"\"\" self . assertIsInstance ( first , str , ' First argument is not a string ' ) self . assertIsInstance ( second , str , ' Second argument is not a string ' ) if first != second : # don ' t use difflib if the strings are too long if ( len ( first ) > self . _diffThreshold or len ( second ) > self . _diffThreshold ) : self . _baseAssertEqual ( first , second , msg ) firstlines = first . splitlines ( keepends = True ) secondlines = second . splitlines ( keepends = True ) if len ( firstlines ) == 1 and first . strip ( ' \\r \\n ' ) == first : firstlines = [ first + ' \\n ' ] secondlines = [ second + ' \\n ' ] standardMsg = ' %s != %s ' % _common_shorten_repr ( first , second ) diff = ' \\n ' + '' . join ( difflib . ndiff ( firstlines , secondlines )) standardMsg = self . _truncateMessage ( standardMsg , diff ) self . fail ( self . _formatMessage ( msg , standardMsg ))","title":"assertMultiLineEqual"},{"location":"reference/appium/saucetestcase/#assertnotalmostequal","text":"def assertNotAlmostEqual ( self , first , second , places = None , msg = None , delta = None ) Fail if the two objects are equal as determined by their difference rounded to the given number of decimal places (default 7) and comparing to zero, or by comparing that the difference between the two objects is less than the given delta. Note that decimal places (from zero) are usually not the same as significant digits (measured from the most significant digit). Objects that are equal automatically fail. View Source def assertNotAlmostEqual ( self , first , second , places = None , msg = None , delta = None ) : \"\"\" Fail if the two objects are equal as determined by their difference rounded to the given number of decimal places ( default 7 ) and comparing to zero , or by comparing that the difference between the two objects is less than the given delta . Note that decimal places ( from zero ) are usually not the same as significant digits ( measured from the most significant digit ) . Objects that are equal automatically fail . \"\"\" if delta is not None and places is not None : raise TypeError ( \" specify delta or places not both \" ) diff = abs ( first - second ) if delta is not None : if not ( first == second ) and diff > delta : return standardMsg = ' %s == %s within %s delta (%s difference) ' % ( safe_repr ( first ) , safe_repr ( second ) , safe_repr ( delta ) , safe_repr ( diff )) else : if places is None : places = 7 if not ( first == second ) and round ( diff , places ) != 0 : return standardMsg = ' %s == %s within %r places ' % ( safe_repr ( first ) , safe_repr ( second ) , places ) msg = self . _formatMessage ( msg , standardMsg ) raise self . failureException ( msg )","title":"assertNotAlmostEqual"},{"location":"reference/appium/saucetestcase/#assertnotalmostequals","text":"def assertNotAlmostEquals ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs )","title":"assertNotAlmostEquals"},{"location":"reference/appium/saucetestcase/#assertnotequal","text":"def assertNotEqual ( self , first , second , msg = None ) Fail if the two objects are equal as determined by the '!=' operator. View Source def assertNotEqual ( self , first , second , msg = None ) : \"\"\" Fail if the two objects are equal as determined by the '!=' operator . \"\"\" if not first != second : msg = self . _formatMessage ( msg , ' %s == %s ' % ( safe_repr ( first ) , safe_repr ( second ))) raise self . failureException ( msg )","title":"assertNotEqual"},{"location":"reference/appium/saucetestcase/#assertnotequals","text":"def assertNotEquals ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs )","title":"assertNotEquals"},{"location":"reference/appium/saucetestcase/#assertnotin","text":"def assertNotIn ( self , member , container , msg = None ) Just like self.assertTrue(a not in b), but with a nicer default message. View Source def assertNotIn ( self , member , container , msg = None ) : \"\"\" Just like self.assertTrue(a not in b), but with a nicer default message. \"\"\" if member in container : standardMsg = ' %s unexpectedly found in %s ' % ( safe_repr ( member ) , safe_repr ( container )) self . fail ( self . _formatMessage ( msg , standardMsg ))","title":"assertNotIn"},{"location":"reference/appium/saucetestcase/#assertnotisinstance","text":"def assertNotIsInstance ( self , obj , cls , msg = None ) Included for symmetry with assertIsInstance. View Source def assertNotIsInstance ( self , obj , cls , msg = None ) : \"\"\" Included for symmetry with assertIsInstance. \"\"\" if isinstance ( obj , cls ) : standardMsg = ' %s is an instance of %r ' % ( safe_repr ( obj ) , cls ) self . fail ( self . _formatMessage ( msg , standardMsg ))","title":"assertNotIsInstance"},{"location":"reference/appium/saucetestcase/#assertnotregex","text":"def assertNotRegex ( self , text , unexpected_regex , msg = None ) Fail the test if the text matches the regular expression. View Source def assertNotRegex ( self , text , unexpected_regex , msg = None ) : \"\"\" Fail the test if the text matches the regular expression. \"\"\" if isinstance ( unexpected_regex , ( str , bytes )) : unexpected_regex = re . compile ( unexpected_regex ) match = unexpected_regex . search ( text ) if match : standardMsg = ' Regex matched: %r matches %r in %r ' % ( text [ match . start () : match . end () ], unexpected_regex . pattern , text ) # _formatMessage ensures the longMessage option is respected msg = self . _formatMessage ( msg , standardMsg ) raise self . failureException ( msg )","title":"assertNotRegex"},{"location":"reference/appium/saucetestcase/#assertnotregexpmatches","text":"def assertNotRegexpMatches ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs )","title":"assertNotRegexpMatches"},{"location":"reference/appium/saucetestcase/#assertraises","text":"def assertRaises ( self , expected_exception , * args , ** kwargs ) Fail unless an exception of class expected_exception is raised by the callable when invoked with specified positional and keyword arguments. If a different type of exception is raised, it will not be caught, and the test case will be deemed to have suffered an error, exactly as for an unexpected exception. If called with the callable and arguments omitted, will return a context object used like this:: with self . assertRaises ( SomeException ): do_something () An optional keyword argument 'msg' can be provided when assertRaises is used as a context object. The context manager keeps a reference to the exception as the 'exception' attribute. This allows you to inspect the exception after the assertion:: with self . assertRaises ( SomeException ) as cm : do_something () the_exception = cm . exception self . assertEqual ( the_exception . error_code , 3 ) View Source def assertRaises ( self , expected_exception , * args , ** kwargs ) : \"\"\" Fail unless an exception of class expected_exception is raised by the callable when invoked with specified positional and keyword arguments . If a different type of exception is raised , it will not be caught , and the test case will be deemed to have suffered an error , exactly as for an unexpected exception . If called with the callable and arguments omitted , will return a context object used like this :: with self . assertRaises ( SomeException ) : do_something () An optional keyword argument ' msg ' can be provided when assertRaises is used as a context object . The context manager keeps a reference to the exception as the ' exception ' attribute . This allows you to inspect the exception after the assertion :: with self . assertRaises ( SomeException ) as cm : do_something () the_exception = cm . exception self . assertEqual ( the_exception . error_code , 3 ) \"\"\" context = _AssertRaisesContext ( expected_exception , self ) try : return context . handle ( ' assertRaises ' , args , kwargs ) finally : # bpo - 23890 : manually break a reference cycle context = None","title":"assertRaises"},{"location":"reference/appium/saucetestcase/#assertraisesregex","text":"def assertRaisesRegex ( self , expected_exception , expected_regex , * args , ** kwargs ) Asserts that the message in a raised exception matches a regex. Args: expected_exception: Exception class expected to be raised. expected_regex: Regex (re.Pattern object or string) expected to be found in error message. args: Function to be called and extra positional args. kwargs: Extra kwargs. msg: Optional message used in case of failure. Can only be used when assertRaisesRegex is used as a context manager. View Source def assertRaisesRegex ( self , expected_exception , expected_regex , * args , ** kwargs ) : \"\"\" Asserts that the message in a raised exception matches a regex. Args : expected_exception : Exception class expected to be raised . expected_regex : Regex ( re . Pattern object or string ) expected to be found in error message . args : Function to be called and extra positional args . kwargs : Extra kwargs . msg : Optional message used in case of failure . Can only be used when assertRaisesRegex is used as a context manager . \"\"\" context = _AssertRaisesContext ( expected_exception , self , expected_regex ) return context . handle ( ' assertRaisesRegex ' , args , kwargs )","title":"assertRaisesRegex"},{"location":"reference/appium/saucetestcase/#assertraisesregexp","text":"def assertRaisesRegexp ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs )","title":"assertRaisesRegexp"},{"location":"reference/appium/saucetestcase/#assertregex","text":"def assertRegex ( self , text , expected_regex , msg = None ) Fail the test unless the text matches the regular expression. View Source def assertRegex ( self , text , expected_regex , msg = None ) : \"\"\" Fail the test unless the text matches the regular expression. \"\"\" if isinstance ( expected_regex , ( str , bytes )) : assert expected_regex , \" expected_regex must not be empty. \" expected_regex = re . compile ( expected_regex ) if not expected_regex . search ( text ) : standardMsg = \" Regex didn't match: %r not found in %r \" % ( expected_regex . pattern , text ) # _formatMessage ensures the longMessage option is respected msg = self . _formatMessage ( msg , standardMsg ) raise self . failureException ( msg )","title":"assertRegex"},{"location":"reference/appium/saucetestcase/#assertregexpmatches","text":"def assertRegexpMatches ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs )","title":"assertRegexpMatches"},{"location":"reference/appium/saucetestcase/#assertsequenceequal","text":"def assertSequenceEqual ( self , seq1 , seq2 , msg = None , seq_type = None ) An equality assertion for ordered sequences (like lists and tuples). For the purposes of this function, a valid ordered sequence type is one which can be indexed, has a length, and has an equality operator. Args: seq1: The first sequence to compare. seq2: The second sequence to compare. seq_type: The expected datatype of the sequences, or None if no datatype should be enforced. msg: Optional message to use on failure instead of a list of differences. View Source def assertSequenceEqual ( self , seq1 , seq2 , msg = None , seq_type = None ) : \"\"\" An equality assertion for ordered sequences (like lists and tuples). For the purposes of this function , a valid ordered sequence type is one which can be indexed , has a length , and has an equality operator . Args : seq1 : The first sequence to compare . seq2 : The second sequence to compare . seq_type : The expected datatype of the sequences , or None if no datatype should be enforced . msg : Optional message to use on failure instead of a list of differences . \"\"\" if seq_type is not None : seq_type_name = seq_type . __name__ if not isinstance ( seq1 , seq_type ) : raise self . failureException ( ' First sequence is not a %s: %s ' % ( seq_type_name , safe_repr ( seq1 ))) if not isinstance ( seq2 , seq_type ) : raise self . failureException ( ' Second sequence is not a %s: %s ' % ( seq_type_name , safe_repr ( seq2 ))) else : seq_type_name = \" sequence \" differing = None try : len1 = len ( seq1 ) except ( TypeError , NotImplementedError ) : differing = ' First %s has no length. Non-sequence? ' % ( seq_type_name ) if differing is None : try : len2 = len ( seq2 ) except ( TypeError , NotImplementedError ) : differing = ' Second %s has no length. Non-sequence? ' % ( seq_type_name ) if differing is None : if seq1 == seq2 : return differing = ' %ss differ: %s != %s \\n ' % ( ( seq_type_name . capitalize () , ) + _common_shorten_repr ( seq1 , seq2 )) for i in range ( min ( len1 , len2 )) : try : item1 = seq1 [ i ] except ( TypeError , IndexError , NotImplementedError ) : differing += ( ' \\n Unable to index element %d of first %s \\n ' % ( i , seq_type_name )) break try : item2 = seq2 [ i ] except ( TypeError , IndexError , NotImplementedError ) : differing += ( ' \\n Unable to index element %d of second %s \\n ' % ( i , seq_type_name )) break if item1 != item2 : differing += ( ' \\n First differing element %d: \\n %s \\n %s \\n ' % (( i , ) + _common_shorten_repr ( item1 , item2 ))) break else : if ( len1 == len2 and seq_type is None and type ( seq1 ) != type ( seq2 )) : # The sequences are the same , but have differing types . return if len1 > len2 : differing += ( ' \\n First %s contains %d additional ' ' elements. \\n ' % ( seq_type_name , len1 - len2 )) try : differing += ( ' First extra element %d: \\n %s \\n ' % ( len2 , safe_repr ( seq1 [ len2 ] ))) except ( TypeError , IndexError , NotImplementedError ) : differing += ( ' Unable to index element %d ' ' of first %s \\n ' % ( len2 , seq_type_name )) elif len1 < len2 : differing += ( ' \\n Second %s contains %d additional ' ' elements. \\n ' % ( seq_type_name , len2 - len1 )) try : differing += ( ' First extra element %d: \\n %s \\n ' % ( len1 , safe_repr ( seq2 [ len1 ] ))) except ( TypeError , IndexError , NotImplementedError ) : differing += ( ' Unable to index element %d ' ' of second %s \\n ' % ( len1 , seq_type_name )) standardMsg = differing diffMsg = ' \\n ' + ' \\n ' . join ( difflib . ndiff ( pprint . pformat ( seq1 ) . splitlines () , pprint . pformat ( seq2 ) . splitlines ())) standardMsg = self . _truncateMessage ( standardMsg , diffMsg ) msg = self . _formatMessage ( msg , standardMsg ) self . fail ( msg )","title":"assertSequenceEqual"},{"location":"reference/appium/saucetestcase/#assertsetequal","text":"def assertSetEqual ( self , set1 , set2 , msg = None ) A set-specific equality assertion. Args: set1: The first set to compare. set2: The second set to compare. msg: Optional message to use on failure instead of a list of differences. assertSetEqual uses ducktyping to support different types of sets, and is optimized for sets specifically (parameters must support a difference method). View Source def assertSetEqual ( self , set1 , set2 , msg = None ) : \"\"\" A set-specific equality assertion. Args : set1 : The first set to compare . set2 : The second set to compare . msg : Optional message to use on failure instead of a list of differences . assertSetEqual uses ducktyping to support different types of sets , and is optimized for sets specifically ( parameters must support a difference method ) . \"\"\" try : difference1 = set1 . difference ( set2 ) except TypeError as e : self . fail ( ' invalid type when attempting set difference: %s ' % e ) except AttributeError as e : self . fail ( ' first argument does not support set difference: %s ' % e ) try : difference2 = set2 . difference ( set1 ) except TypeError as e : self . fail ( ' invalid type when attempting set difference: %s ' % e ) except AttributeError as e : self . fail ( ' second argument does not support set difference: %s ' % e ) if not ( difference1 or difference2 ) : return lines = [] if difference1 : lines . append ( ' Items in the first set but not the second: ' ) for item in difference1 : lines . append ( repr ( item )) if difference2 : lines . append ( ' Items in the second set but not the first: ' ) for item in difference2 : lines . append ( repr ( item )) standardMsg = ' \\n ' . join ( lines ) self . fail ( self . _formatMessage ( msg , standardMsg ))","title":"assertSetEqual"},{"location":"reference/appium/saucetestcase/#asserttrue","text":"def assertTrue ( self , expr , msg = None ) Check that the expression is true. View Source def assertTrue ( self , expr , msg = None ) : \"\"\" Check that the expression is true. \"\"\" if not expr : msg = self . _formatMessage ( msg , \" %s is not true \" % safe_repr ( expr )) raise self . failureException ( msg )","title":"assertTrue"},{"location":"reference/appium/saucetestcase/#asserttupleequal","text":"def assertTupleEqual ( self , tuple1 , tuple2 , msg = None ) A tuple-specific equality assertion. Args: tuple1: The first tuple to compare. tuple2: The second tuple to compare. msg: Optional message to use on failure instead of a list of differences. View Source def assertTupleEqual ( self , tuple1 , tuple2 , msg = None ): \"\"\"A tuple-specific equality assertion. Args: tuple1: The first tuple to compare. tuple2: The second tuple to compare. msg: Optional message to use on failure instead of a list of differences. \"\"\" self . assertSequenceEqual ( tuple1 , tuple2 , msg , seq_type = tuple )","title":"assertTupleEqual"},{"location":"reference/appium/saucetestcase/#assertwarns","text":"def assertWarns ( self , expected_warning , * args , ** kwargs ) Fail unless a warning of class warnClass is triggered by the callable when invoked with specified positional and keyword arguments. If a different type of warning is triggered, it will not be handled: depending on the other warning filtering rules in effect, it might be silenced, printed out, or raised as an exception. If called with the callable and arguments omitted, will return a context object used like this:: with self . assertWarns ( SomeWarning ): do_something () An optional keyword argument 'msg' can be provided when assertWarns is used as a context object. The context manager keeps a reference to the first matching warning as the 'warning' attribute; similarly, the 'filename' and 'lineno' attributes give you information about the line of Python code from which the warning was triggered. This allows you to inspect the warning after the assertion:: with self . assertWarns ( SomeWarning ) as cm : do_something () the_warning = cm . warning self . assertEqual ( the_warning . some_attribute , 147 ) View Source def assertWarns ( self , expected_warning , * args , ** kwargs ) : \"\"\" Fail unless a warning of class warnClass is triggered by the callable when invoked with specified positional and keyword arguments . If a different type of warning is triggered , it will not be handled : depending on the other warning filtering rules in effect , it might be silenced , printed out , or raised as an exception . If called with the callable and arguments omitted , will return a context object used like this :: with self . assertWarns ( SomeWarning ) : do_something () An optional keyword argument ' msg ' can be provided when assertWarns is used as a context object . The context manager keeps a reference to the first matching warning as the ' warning ' attribute ; similarly, the 'filename' and ' lineno ' attributes give you information about the line of Python code from which the warning was triggered . This allows you to inspect the warning after the assertion :: with self . assertWarns ( SomeWarning ) as cm : do_something () the_warning = cm . warning self . assertEqual ( the_warning . some_attribute , 147 ) \"\"\" context = _AssertWarnsContext ( expected_warning , self ) return context . handle ( ' assertWarns ' , args , kwargs )","title":"assertWarns"},{"location":"reference/appium/saucetestcase/#assertwarnsregex","text":"def assertWarnsRegex ( self , expected_warning , expected_regex , * args , ** kwargs ) Asserts that the message in a triggered warning matches a regexp. Basic functioning is similar to assertWarns() with the addition that only warnings whose messages also match the regular expression are considered successful matches. Args: expected_warning: Warning class expected to be triggered. expected_regex: Regex (re.Pattern object or string) expected to be found in error message. args: Function to be called and extra positional args. kwargs: Extra kwargs. msg: Optional message used in case of failure. Can only be used when assertWarnsRegex is used as a context manager. View Source def assertWarnsRegex ( self , expected_warning , expected_regex , * args , ** kwargs ) : \"\"\" Asserts that the message in a triggered warning matches a regexp. Basic functioning is similar to assertWarns () with the addition that only warnings whose messages also match the regular expression are considered successful matches . Args : expected_warning : Warning class expected to be triggered . expected_regex : Regex ( re . Pattern object or string ) expected to be found in error message . args : Function to be called and extra positional args . kwargs : Extra kwargs . msg : Optional message used in case of failure . Can only be used when assertWarnsRegex is used as a context manager . \"\"\" context = _AssertWarnsContext ( expected_warning , self , expected_regex ) return context . handle ( ' assertWarnsRegex ' , args , kwargs )","title":"assertWarnsRegex"},{"location":"reference/appium/saucetestcase/#assert_","text":"def assert_ ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs )","title":"assert_"},{"location":"reference/appium/saucetestcase/#counttestcases","text":"def countTestCases ( self ) View Source def countTestCases ( self ) : return 1","title":"countTestCases"},{"location":"reference/appium/saucetestcase/#debug","text":"def debug ( self ) Run the test without collecting errors in a TestResult View Source def debug ( self ) : \"\"\" Run the test without collecting errors in a TestResult \"\"\" self . setUp () getattr ( self , self . _testMethodName )() self . tearDown () while self . _cleanups : function , args , kwargs = self . _cleanups . pop ( - 1 ) function ( * args , ** kwargs )","title":"debug"},{"location":"reference/appium/saucetestcase/#defaulttestresult","text":"def defaultTestResult ( self ) View Source def defaultTestResult ( self ) : return result . TestResult ()","title":"defaultTestResult"},{"location":"reference/appium/saucetestcase/#docleanups","text":"def doCleanups ( self ) Execute all cleanup functions. Normally called for you after tearDown. View Source def doCleanups ( self ) : \"\"\" Execute all cleanup functions. Normally called for you after tearDown . \"\"\" outcome = self . _outcome or _Outcome () while self . _cleanups : function , args , kwargs = self . _cleanups . pop () with outcome . testPartExecutor ( self ) : function ( * args , ** kwargs ) # return this for backwards compatibility # even though we no longer us it internally return outcome . success","title":"doCleanups"},{"location":"reference/appium/saucetestcase/#fail","text":"def fail ( self , msg = None ) Fail immediately, with the given message. View Source def fail ( self , msg = None ): \"\"\"Fail immediately, with the given message.\"\"\" raise self . failureException ( msg )","title":"fail"},{"location":"reference/appium/saucetestcase/#failif","text":"def failIf ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs )","title":"failIf"},{"location":"reference/appium/saucetestcase/#failifalmostequal","text":"def failIfAlmostEqual ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs )","title":"failIfAlmostEqual"},{"location":"reference/appium/saucetestcase/#failifequal","text":"def failIfEqual ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs )","title":"failIfEqual"},{"location":"reference/appium/saucetestcase/#failunless","text":"def failUnless ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs )","title":"failUnless"},{"location":"reference/appium/saucetestcase/#failunlessalmostequal","text":"def failUnlessAlmostEqual ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs )","title":"failUnlessAlmostEqual"},{"location":"reference/appium/saucetestcase/#failunlessequal","text":"def failUnlessEqual ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs )","title":"failUnlessEqual"},{"location":"reference/appium/saucetestcase/#failunlessraises","text":"def failUnlessRaises ( * args , ** kwargs ) View Source def deprecated_func ( * args , ** kwargs ) : warnings . warn ( ' Please use {0} instead. ' . format ( original_func . __name__ ) , DeprecationWarning , 2 ) return original_func ( * args , ** kwargs )","title":"failUnlessRaises"},{"location":"reference/appium/saucetestcase/#id","text":"def id ( self ) View Source def id ( self ) : return \" %s.%s \" % ( strclass ( self . __class__ ) , self . _testMethodName )","title":"id"},{"location":"reference/appium/saucetestcase/#run","text":"def run ( self , result = None ) View Source def run ( self , result = None ) : orig_result = result if result is None : result = self . defaultTestResult () startTestRun = getattr ( result , ' startTestRun ' , None ) if startTestRun is not None : startTestRun () result . startTest ( self ) testMethod = getattr ( self , self . _testMethodName ) if ( getattr ( self . __class__ , \" __unittest_skip__ \" , False ) or getattr ( testMethod , \" __unittest_skip__ \" , False )) : # If the class or method was skipped . try : skip_why = ( getattr ( self . __class__ , ' __unittest_skip_why__ ' , '' ) or getattr ( testMethod , ' __unittest_skip_why__ ' , '' )) self . _addSkip ( result , self , skip_why ) finally : result . stopTest ( self ) return expecting_failure_method = getattr ( testMethod , \" __unittest_expecting_failure__ \" , False ) expecting_failure_class = getattr ( self , \" __unittest_expecting_failure__ \" , False ) expecting_failure = expecting_failure_class or expecting_failure_method outcome = _Outcome ( result ) try : self . _outcome = outcome with outcome . testPartExecutor ( self ) : self . setUp () if outcome . success : outcome . expecting_failure = expecting_failure with outcome . testPartExecutor ( self , isTest = True ) : testMethod () outcome . expecting_failure = False with outcome . testPartExecutor ( self ) : self . tearDown () self . doCleanups () for test , reason in outcome . skipped : self . _addSkip ( result , test , reason ) self . _feedErrorsToResult ( result , outcome . errors ) if outcome . success : if expecting_failure : if outcome . expectedFailure : self . _addExpectedFailure ( result , outcome . expectedFailure ) else : self . _addUnexpectedSuccess ( result ) else : result . addSuccess ( self ) return result finally : result . stopTest ( self ) if orig_result is None : stopTestRun = getattr ( result , ' stopTestRun ' , None ) if stopTestRun is not None : stopTestRun () # explicitly break reference cycles : # outcome . errors -> frame -> outcome -> outcome . errors # outcome . expectedFailure -> frame -> outcome -> outcome . expectedFailure outcome . errors . clear () outcome . expectedFailure = None # clear the outcome , no more needed self . _outcome = None","title":"run"},{"location":"reference/appium/saucetestcase/#setup","text":"def setUp ( self ) Hook method for setting up the test fixture before exercising it. View Source def setUp ( self ) : self . desired_capabilities [ 'name' ] = self . id () sauce_url = \"http://%s:%s@ondemand.saucelabs.com:80/wd/hub\" self . driver = webdriver . Remote ( desired_capabilities = self . desired_capabilities , command_executor = sauce_url % ( SAUCE_USERNAME , SAUCE_ACCESS_KEY ) ) self . driver . implicitly_wait ( 30 )","title":"setUp"},{"location":"reference/appium/saucetestcase/#shortdescription","text":"def shortDescription ( self ) Returns a one-line description of the test, or None if no description has been provided. The default implementation of this method returns the first line of the specified test method's docstring. View Source def shortDescription ( self ) : \"\"\" Returns a one-line description of the test, or None if no description has been provided . The default implementation of this method returns the first line of the specified test method ' s docstring. \"\"\" doc = self . _testMethodDoc return doc and doc . split ( \" \\n \" ) [ 0 ]. strip () or None","title":"shortDescription"},{"location":"reference/appium/saucetestcase/#skiptest","text":"def skipTest ( self , reason ) Skip this test. View Source def skipTest ( self , reason ): \"\"\"Skip this test.\"\"\" raise SkipTest ( reason )","title":"skipTest"},{"location":"reference/appium/saucetestcase/#subtest","text":"def subTest ( self , msg =< object object at 0x10a68b4d0 > , ** params ) Return a context manager that will return the enclosed block of code in a subtest identified by the optional message and keyword parameters. A failure in the subtest marks the test case as failed but resumes execution at the end of the enclosed block, allowing further test code to be executed. View Source @ contextlib . contextmanager def subTest ( self , msg = _subtest_msg_sentinel , ** params ) : \"\"\" Return a context manager that will return the enclosed block of code in a subtest identified by the optional message and keyword parameters . A failure in the subtest marks the test case as failed but resumes execution at the end of the enclosed block , allowing further test code to be executed . \"\"\" if self . _outcome is None or not self . _outcome . result_supports_subtests : yield return parent = self . _subtest if parent is None : params_map = _OrderedChainMap ( params ) else : params_map = parent . params . new_child ( params ) self . _subtest = _SubTest ( self , msg , params_map ) try : with self . _outcome . testPartExecutor ( self . _subtest , isTest = True ) : yield if not self . _outcome . success : result = self . _outcome . result if result is not None and result . failfast : raise _ShouldStop elif self . _outcome . expectedFailure : # If the test is expecting a failure , we really want to # stop now and register the expected failure . raise _ShouldStop finally : self . _subtest = parent","title":"subTest"},{"location":"reference/appium/saucetestcase/#teardown","text":"def tearDown ( self ) Hook method for deconstructing the test fixture after testing it. View Source def tearDown ( self ) : print ( \" Link to your job: https://saucelabs.com/jobs/%s \" % self . driver . session_id ) try : if sys . exc_info () == ( None , None , None ) : sauce . jobs . update_job ( self . driver . session_id , passed = True ) else : sauce . jobs . update_job ( self . driver . session_id , passed = False ) finally : self . driver . quit ()","title":"tearDown"},{"location":"reference/appium/version/","text":"Module appium.version View Source version = '0.47' Variables version","title":"Version"},{"location":"reference/appium/version/#module-appiumversion","text":"View Source version = '0.47'","title":"Module appium.version"},{"location":"reference/appium/version/#variables","text":"version","title":"Variables"},{"location":"reference/appium/common/","text":"Module appium.common Appium Python Client: Common classes View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. \"\"\" Appium Python Client: Common classes \"\"\" Sub-modules appium.common.exceptions appium.common.helper appium.common.logger","title":"Index"},{"location":"reference/appium/common/#module-appiumcommon","text":"Appium Python Client: Common classes View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. \"\"\" Appium Python Client: Common classes \"\"\"","title":"Module appium.common"},{"location":"reference/appium/common/#sub-modules","text":"appium.common.exceptions appium.common.helper appium.common.logger","title":"Sub-modules"},{"location":"reference/appium/common/exceptions/","text":"Module appium.common.exceptions View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium.common.exceptions import InvalidSwitchToTargetException class NoSuchContextException ( InvalidSwitchToTargetException ): \"\"\"Thrown when context target to be switched doesn't exist. To find the current set of active contexts, you can get a list of the active contexts in the following way: print driver.contexts \"\"\" pass Classes NoSuchContextException class NoSuchContextException ( msg = None , screen = None , stacktrace = None ) Thrown when context target to be switched doesn't exist. To find the current set of active contexts, you can get a list of the active contexts in the following way: print driver . contexts View Source class NoSuchContextException ( InvalidSwitchToTargetException ): \"\"\"Thrown when context target to be switched doesn't exist. To find the current set of active contexts, you can get a list of the active contexts in the following way: print driver.contexts \"\"\" pass Ancestors (in MRO) selenium.common.exceptions.InvalidSwitchToTargetException selenium.common.exceptions.WebDriverException builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Exceptions"},{"location":"reference/appium/common/exceptions/#module-appiumcommonexceptions","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium.common.exceptions import InvalidSwitchToTargetException class NoSuchContextException ( InvalidSwitchToTargetException ): \"\"\"Thrown when context target to be switched doesn't exist. To find the current set of active contexts, you can get a list of the active contexts in the following way: print driver.contexts \"\"\" pass","title":"Module appium.common.exceptions"},{"location":"reference/appium/common/exceptions/#classes","text":"","title":"Classes"},{"location":"reference/appium/common/exceptions/#nosuchcontextexception","text":"class NoSuchContextException ( msg = None , screen = None , stacktrace = None ) Thrown when context target to be switched doesn't exist. To find the current set of active contexts, you can get a list of the active contexts in the following way: print driver . contexts View Source class NoSuchContextException ( InvalidSwitchToTargetException ): \"\"\"Thrown when context target to be switched doesn't exist. To find the current set of active contexts, you can get a list of the active contexts in the following way: print driver.contexts \"\"\" pass","title":"NoSuchContextException"},{"location":"reference/appium/common/exceptions/#ancestors-in-mro","text":"selenium.common.exceptions.InvalidSwitchToTargetException selenium.common.exceptions.WebDriverException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/appium/common/exceptions/#class-variables","text":"args","title":"Class variables"},{"location":"reference/appium/common/exceptions/#methods","text":"","title":"Methods"},{"location":"reference/appium/common/exceptions/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/appium/common/helper/","text":"Module appium.common.helper View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from collections import OrderedDict from appium import version as appium_version def appium_bytes ( value , encoding ): \"\"\"Return a bytes-like object Has _appium_ prefix to avoid overriding built-in bytes. Args: value (str): A value to convert encoding (str): A encoding which will convert to Returns: str: A bytes-like object \"\"\" try : return bytes ( value , encoding ) # Python 3 except TypeError : return value # Python 2 def extract_const_attributes ( cls ): \"\"\"Return dict with constants attributes and values in the class(e.g. {'VAL1': 1, 'VAL2': 2}) Args: cls (type): Class to be extracted constants Returns: OrderedDict: dict with constants attributes and values in the class \"\"\" return OrderedDict ( [( attr , value ) for attr , value in vars ( cls ) . items () if not callable ( getattr ( cls , attr )) and attr . isupper ()]) def library_version (): \"\"\"Return a version of this python library \"\"\" return appium_version . version Functions appium_bytes def appium_bytes ( value , encoding ) Return a bytes-like object Has appium prefix to avoid overriding built-in bytes. Args: value (str): A value to convert encoding (str): A encoding which will convert to Returns: str: A bytes-like object View Source def appium_bytes ( value , encoding ) : \"\"\" Return a bytes-like object Has _appium_ prefix to avoid overriding built - in bytes . Args : value ( str ) : A value to convert encoding ( str ) : A encoding which will convert to Returns : str : A bytes - like object \"\"\" try : return bytes ( value , encoding ) # Python 3 except TypeError : return value # Python 2 extract_const_attributes def extract_const_attributes ( cls ) Return dict with constants attributes and values in the class(e.g. {'VAL1': 1, 'VAL2': 2}) Args: cls (type): Class to be extracted constants Returns: OrderedDict: dict with constants attributes and values in the class View Source def extract_const_attributes ( cls ) : \"\"\" Return dict with constants attributes and values in the class(e.g. {'VAL1': 1, 'VAL2': 2}) Args : cls ( type ) : Class to be extracted constants Returns : OrderedDict : dict with constants attributes and values in the class \"\"\" return OrderedDict ( [ ( attr , value ) for attr , value in vars ( cls ) . items () if not callable ( getattr ( cls , attr )) and attr . isupper () ] ) library_version def library_version ( ) Return a version of this python library View Source def library_version () : \"\"\" Return a version of this python library \"\"\" return appium_version . version","title":"Helper"},{"location":"reference/appium/common/helper/#module-appiumcommonhelper","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from collections import OrderedDict from appium import version as appium_version def appium_bytes ( value , encoding ): \"\"\"Return a bytes-like object Has _appium_ prefix to avoid overriding built-in bytes. Args: value (str): A value to convert encoding (str): A encoding which will convert to Returns: str: A bytes-like object \"\"\" try : return bytes ( value , encoding ) # Python 3 except TypeError : return value # Python 2 def extract_const_attributes ( cls ): \"\"\"Return dict with constants attributes and values in the class(e.g. {'VAL1': 1, 'VAL2': 2}) Args: cls (type): Class to be extracted constants Returns: OrderedDict: dict with constants attributes and values in the class \"\"\" return OrderedDict ( [( attr , value ) for attr , value in vars ( cls ) . items () if not callable ( getattr ( cls , attr )) and attr . isupper ()]) def library_version (): \"\"\"Return a version of this python library \"\"\" return appium_version . version","title":"Module appium.common.helper"},{"location":"reference/appium/common/helper/#functions","text":"","title":"Functions"},{"location":"reference/appium/common/helper/#appium_bytes","text":"def appium_bytes ( value , encoding ) Return a bytes-like object Has appium prefix to avoid overriding built-in bytes. Args: value (str): A value to convert encoding (str): A encoding which will convert to Returns: str: A bytes-like object View Source def appium_bytes ( value , encoding ) : \"\"\" Return a bytes-like object Has _appium_ prefix to avoid overriding built - in bytes . Args : value ( str ) : A value to convert encoding ( str ) : A encoding which will convert to Returns : str : A bytes - like object \"\"\" try : return bytes ( value , encoding ) # Python 3 except TypeError : return value # Python 2","title":"appium_bytes"},{"location":"reference/appium/common/helper/#extract_const_attributes","text":"def extract_const_attributes ( cls ) Return dict with constants attributes and values in the class(e.g. {'VAL1': 1, 'VAL2': 2}) Args: cls (type): Class to be extracted constants Returns: OrderedDict: dict with constants attributes and values in the class View Source def extract_const_attributes ( cls ) : \"\"\" Return dict with constants attributes and values in the class(e.g. {'VAL1': 1, 'VAL2': 2}) Args : cls ( type ) : Class to be extracted constants Returns : OrderedDict : dict with constants attributes and values in the class \"\"\" return OrderedDict ( [ ( attr , value ) for attr , value in vars ( cls ) . items () if not callable ( getattr ( cls , attr )) and attr . isupper () ] )","title":"extract_const_attributes"},{"location":"reference/appium/common/helper/#library_version","text":"def library_version ( ) Return a version of this python library View Source def library_version () : \"\"\" Return a version of this python library \"\"\" return appium_version . version","title":"library_version"},{"location":"reference/appium/common/logger/","text":"Module appium.common.logger View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import logging import sys def setup_logger ( level = logging . NOTSET ): logger . propagate = False logger . setLevel ( level ) handler = logging . StreamHandler ( stream = sys . stderr ) logger . addHandler ( handler ) # global logger logger = logging . getLogger ( __name__ ) setup_logger () Variables logger Functions setup_logger def setup_logger ( level = 0 ) View Source def setup_logger ( level = logging . NOTSET ): logger . propagate = False logger . setLevel ( level ) handler = logging . StreamHandler ( stream = sys . stderr ) logger . addHandler ( handler )","title":"Logger"},{"location":"reference/appium/common/logger/#module-appiumcommonlogger","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import logging import sys def setup_logger ( level = logging . NOTSET ): logger . propagate = False logger . setLevel ( level ) handler = logging . StreamHandler ( stream = sys . stderr ) logger . addHandler ( handler ) # global logger logger = logging . getLogger ( __name__ ) setup_logger ()","title":"Module appium.common.logger"},{"location":"reference/appium/common/logger/#variables","text":"logger","title":"Variables"},{"location":"reference/appium/common/logger/#functions","text":"","title":"Functions"},{"location":"reference/appium/common/logger/#setup_logger","text":"def setup_logger ( level = 0 ) View Source def setup_logger ( level = logging . NOTSET ): logger . propagate = False logger . setLevel ( level ) handler = logging . StreamHandler ( stream = sys . stderr ) logger . addHandler ( handler )","title":"setup_logger"},{"location":"reference/appium/webdriver/","text":"Module appium.webdriver Appium Python Client: WebDriver module View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. \"\"\" Appium Python Client: WebDriver module \"\"\" from .webdriver import WebDriver as Remote from .webelement import WebElement Sub-modules appium.webdriver.appium_connection appium.webdriver.appium_service appium.webdriver.applicationstate appium.webdriver.clipboard_content_type appium.webdriver.common appium.webdriver.connectiontype appium.webdriver.errorhandler appium.webdriver.extensions appium.webdriver.mobilecommand appium.webdriver.switch_to appium.webdriver.webdriver appium.webdriver.webelement","title":"Index"},{"location":"reference/appium/webdriver/#module-appiumwebdriver","text":"Appium Python Client: WebDriver module View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. \"\"\" Appium Python Client: WebDriver module \"\"\" from .webdriver import WebDriver as Remote from .webelement import WebElement","title":"Module appium.webdriver"},{"location":"reference/appium/webdriver/#sub-modules","text":"appium.webdriver.appium_connection appium.webdriver.appium_service appium.webdriver.applicationstate appium.webdriver.clipboard_content_type appium.webdriver.common appium.webdriver.connectiontype appium.webdriver.errorhandler appium.webdriver.extensions appium.webdriver.mobilecommand appium.webdriver.switch_to appium.webdriver.webdriver appium.webdriver.webelement","title":"Sub-modules"},{"location":"reference/appium/webdriver/appium_connection/","text":"Module appium.webdriver.appium_connection View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium.webdriver.remote.remote_connection import RemoteConnection from appium.common.helper import library_version class AppiumConnection ( RemoteConnection ): @classmethod def get_remote_connection_headers ( cls , parsed_url , keep_alive = True ): \"\"\"Override get_remote_connection_headers in RemoteConnection\"\"\" headers = RemoteConnection . get_remote_connection_headers ( parsed_url , keep_alive = keep_alive ) headers [ 'User-Agent' ] = 'appium/python {} ({})' . format ( library_version (), headers [ 'User-Agent' ]) return headers Classes AppiumConnection class AppiumConnection ( remote_server_addr , keep_alive = False , resolve_ip = True ) A connection with the Remote WebDriver server. Communicates with the server using the WebDriver wire protocol: https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol View Source class AppiumConnection ( RemoteConnection ) : @ classmethod def get_remote_connection_headers ( cls , parsed_url , keep_alive = True ) : \"\"\" Override get_remote_connection_headers in RemoteConnection \"\"\" headers = RemoteConnection . get_remote_connection_headers ( parsed_url , keep_alive = keep_alive ) headers [ ' User-Agent ' ] = ' appium/python {} ({}) ' . format ( library_version () , headers [ ' User-Agent ' ] ) return headers Ancestors (in MRO) selenium.webdriver.remote.remote_connection.RemoteConnection Static methods get_remote_connection_headers def get_remote_connection_headers ( parsed_url , keep_alive = True ) Override get_remote_connection_headers in RemoteConnection View Source @ classmethod def get_remote_connection_headers ( cls , parsed_url , keep_alive = True ) : \"\"\" Override get_remote_connection_headers in RemoteConnection \"\"\" headers = RemoteConnection . get_remote_connection_headers ( parsed_url , keep_alive = keep_alive ) headers [ ' User-Agent ' ] = ' appium/python {} ({}) ' . format ( library_version () , headers [ ' User-Agent ' ] ) return headers get_timeout def get_timeout ( ) :Returns: Timeout value in seconds for all http requests made to the Remote Connection View Source @ classmethod def get_timeout ( cls ) : \"\"\" :Returns : Timeout value in seconds for all http requests made to the Remote Connection \"\"\" return None if cls . _timeout == socket . _GLOBAL_DEFAULT_TIMEOUT else cls . _timeout reset_timeout def reset_timeout ( ) Reset the http request timeout to socket._GLOBAL_DEFAULT_TIMEOUT View Source @classmethod def reset_timeout ( cls ) : \"\"\" Reset the http request timeout to socket._GLOBAL_DEFAULT_TIMEOUT \"\"\" cls . _timeout = socket . _GLOBAL_DEFAULT_TIMEOUT set_timeout def set_timeout ( timeout ) Override the default timeout :Args: - timeout - timeout value for http requests in seconds View Source @ classmethod def set_timeout ( cls , timeout ) : \"\"\" Override the default timeout : Args : - timeout - timeout value for http requests in seconds \"\"\" cls . _timeout = timeout Methods execute def execute ( self , command , params ) Send a command to the remote server. Any path subtitutions required for the URL mapped to the command should be included in the command parameters. :Args: - command - A string specifying the command to execute. - params - A dictionary of named parameters to send with the command as its JSON payload. View Source def execute ( self , command , params ) : \"\"\" Send a command to the remote server . Any path subtitutions required for the URL mapped to the command should be included in the command parameters . : Args : - command - A string specifying the command to execute . - params - A dictionary of named parameters to send with the command as its JSON payload . \"\"\" command_info = self . _commands [ command ] assert command_info is not None , ' Unrecognised command %s ' % command path = string . Template ( command_info [ 1 ] ) . substitute ( params ) if hasattr ( self , ' w3c ' ) and self . w3c and isinstance ( params , dict ) and ' sessionId ' in params : del params [ ' sessionId ' ] data = utils . dump_json ( params ) url = ' %s%s ' % ( self . _url , path ) return self . _request ( command_info [ 0 ], url , body = data )","title":"Appium Connection"},{"location":"reference/appium/webdriver/appium_connection/#module-appiumwebdriverappium_connection","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium.webdriver.remote.remote_connection import RemoteConnection from appium.common.helper import library_version class AppiumConnection ( RemoteConnection ): @classmethod def get_remote_connection_headers ( cls , parsed_url , keep_alive = True ): \"\"\"Override get_remote_connection_headers in RemoteConnection\"\"\" headers = RemoteConnection . get_remote_connection_headers ( parsed_url , keep_alive = keep_alive ) headers [ 'User-Agent' ] = 'appium/python {} ({})' . format ( library_version (), headers [ 'User-Agent' ]) return headers","title":"Module appium.webdriver.appium_connection"},{"location":"reference/appium/webdriver/appium_connection/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/appium_connection/#appiumconnection","text":"class AppiumConnection ( remote_server_addr , keep_alive = False , resolve_ip = True ) A connection with the Remote WebDriver server. Communicates with the server using the WebDriver wire protocol: https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol View Source class AppiumConnection ( RemoteConnection ) : @ classmethod def get_remote_connection_headers ( cls , parsed_url , keep_alive = True ) : \"\"\" Override get_remote_connection_headers in RemoteConnection \"\"\" headers = RemoteConnection . get_remote_connection_headers ( parsed_url , keep_alive = keep_alive ) headers [ ' User-Agent ' ] = ' appium/python {} ({}) ' . format ( library_version () , headers [ ' User-Agent ' ] ) return headers","title":"AppiumConnection"},{"location":"reference/appium/webdriver/appium_connection/#ancestors-in-mro","text":"selenium.webdriver.remote.remote_connection.RemoteConnection","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/appium_connection/#static-methods","text":"","title":"Static methods"},{"location":"reference/appium/webdriver/appium_connection/#get_remote_connection_headers","text":"def get_remote_connection_headers ( parsed_url , keep_alive = True ) Override get_remote_connection_headers in RemoteConnection View Source @ classmethod def get_remote_connection_headers ( cls , parsed_url , keep_alive = True ) : \"\"\" Override get_remote_connection_headers in RemoteConnection \"\"\" headers = RemoteConnection . get_remote_connection_headers ( parsed_url , keep_alive = keep_alive ) headers [ ' User-Agent ' ] = ' appium/python {} ({}) ' . format ( library_version () , headers [ ' User-Agent ' ] ) return headers","title":"get_remote_connection_headers"},{"location":"reference/appium/webdriver/appium_connection/#get_timeout","text":"def get_timeout ( ) :Returns: Timeout value in seconds for all http requests made to the Remote Connection View Source @ classmethod def get_timeout ( cls ) : \"\"\" :Returns : Timeout value in seconds for all http requests made to the Remote Connection \"\"\" return None if cls . _timeout == socket . _GLOBAL_DEFAULT_TIMEOUT else cls . _timeout","title":"get_timeout"},{"location":"reference/appium/webdriver/appium_connection/#reset_timeout","text":"def reset_timeout ( ) Reset the http request timeout to socket._GLOBAL_DEFAULT_TIMEOUT View Source @classmethod def reset_timeout ( cls ) : \"\"\" Reset the http request timeout to socket._GLOBAL_DEFAULT_TIMEOUT \"\"\" cls . _timeout = socket . _GLOBAL_DEFAULT_TIMEOUT","title":"reset_timeout"},{"location":"reference/appium/webdriver/appium_connection/#set_timeout","text":"def set_timeout ( timeout ) Override the default timeout :Args: - timeout - timeout value for http requests in seconds View Source @ classmethod def set_timeout ( cls , timeout ) : \"\"\" Override the default timeout : Args : - timeout - timeout value for http requests in seconds \"\"\" cls . _timeout = timeout","title":"set_timeout"},{"location":"reference/appium/webdriver/appium_connection/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/appium_connection/#execute","text":"def execute ( self , command , params ) Send a command to the remote server. Any path subtitutions required for the URL mapped to the command should be included in the command parameters. :Args: - command - A string specifying the command to execute. - params - A dictionary of named parameters to send with the command as its JSON payload. View Source def execute ( self , command , params ) : \"\"\" Send a command to the remote server . Any path subtitutions required for the URL mapped to the command should be included in the command parameters . : Args : - command - A string specifying the command to execute . - params - A dictionary of named parameters to send with the command as its JSON payload . \"\"\" command_info = self . _commands [ command ] assert command_info is not None , ' Unrecognised command %s ' % command path = string . Template ( command_info [ 1 ] ) . substitute ( params ) if hasattr ( self , ' w3c ' ) and self . w3c and isinstance ( params , dict ) and ' sessionId ' in params : del params [ ' sessionId ' ] data = utils . dump_json ( params ) url = ' %s%s ' % ( self . _url , path ) return self . _request ( command_info [ 0 ], url , body = data )","title":"execute"},{"location":"reference/appium/webdriver/appium_service/","text":"Module appium.webdriver.appium_service View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import os import subprocess import sys import time import urllib3 DEFAULT_HOST = '127.0.0.1' DEFAULT_PORT = 4723 STARTUP_TIMEOUT_MS = 60000 MAIN_SCRIPT_PATH = 'appium/build/lib/main.js' STATUS_URL = '/wd/hub/status' def find_executable ( executable ): path = os . environ [ 'PATH' ] paths = path . split ( os . pathsep ) base , ext = os . path . splitext ( executable ) if sys . platform == 'win32' and not ext : executable = executable + '.exe' if os . path . isfile ( executable ): return executable for p in paths : full_path = os . path . join ( p , executable ) if os . path . isfile ( full_path ): return full_path return None def poll_url ( host , port , path , timeout_ms ): time_started_sec = time . time () while time . time () < time_started_sec + timeout_ms / 1000.0 : try : conn = urllib3 . PoolManager ( timeout = 1.0 ) resp = conn . request ( 'HEAD' , 'http://{host}:{port}{path}' . format ( host = host , port = port , path = path )) if resp . status < 400 : return True except Exception : pass time . sleep ( 1.0 ) return False class AppiumServiceError ( RuntimeError ): pass class AppiumService ( object ): def __init__ ( self ): self . _process = None self . _cmd = None def _get_node ( self ): if not hasattr ( self , '_node_executable' ): self . _node_executable = find_executable ( 'node' ) if self . _node_executable is None : raise AppiumServiceError ( 'NodeJS main executable cannot be found. ' + 'Make sure it is installed and present in PATH' ) return self . _node_executable def _get_npm ( self ): if not hasattr ( self , '_npm_executable' ): self . _npm_executable = find_executable ( 'npm.cmd' if sys . platform == 'win32' else 'npm' ) if self . _npm_executable is None : raise AppiumServiceError ( 'Node Package Manager executable cannot be found. ' + 'Make sure it is installed and present in PATH' ) return self . _npm_executable def _get_main_script ( self ): if not hasattr ( self , '_main_script' ): for args in [[ 'root' , '-g' ], [ 'root' ]]: try : modules_root = subprocess . check_output ([ self . _get_npm ()] + args ) . strip () . decode ( 'utf-8' ) if os . path . exists ( os . path . join ( modules_root , MAIN_SCRIPT_PATH )): self . _main_script = os . path . join ( modules_root , MAIN_SCRIPT_PATH ) break except subprocess . CalledProcessError : continue if not hasattr ( self , '_main_script' ): try : self . _main_script = subprocess . check_output ( [ self . _get_node (), '-e' , 'console.log(require.resolve(\"{}\"))' . format ( MAIN_SCRIPT_PATH )]) . strip () except subprocess . CalledProcessError as e : raise AppiumServiceError ( e . output ) return self . _main_script @staticmethod def _parse_port ( args ): for idx , arg in enumerate ( args or []): if arg in ( '--port' , '-p' ) and idx < len ( args ) - 1 : return int ( args [ idx + 1 ]) return DEFAULT_PORT @staticmethod def _parse_host ( args ): for idx , arg in enumerate ( args or []): if arg in ( '--address' , '-a' ) and idx < len ( args ) - 1 : return args [ idx + 1 ] return DEFAULT_HOST def start ( self , ** kwargs ): \"\"\"Starts Appium service with given arguments. The service will be forcefully restarted if it is already running. Keyword Args: env (dict): Environment variables mapping. The default system environment, which is inherited from the parent process is assigned by default. node (str): The full path to the main NodeJS executable. The service will try to retrieve it automatically by default. stdout: Check on the documentation for subprocess.Popen for more details. The default value is subprocess.PIPE. stderr: Check on the documentation for subprocess.Popen for more details. The default value is subprocess.PIPE. timeout_ms (int): The maximum time to wait until Appium process starts listening for HTTP connections. If set to zero or a negative number then no wait will be applied. 60000 ms by default main_script (str): The full path to the main Appium executable (usually located this is build/lib/main.js). If this is not set then the service tries to detect the path automatically. args (str): List of Appium arguments (all must be strings). Check on https://appium.io/docs/en/writing-running-appium/server-args/ for more details about possible arguments and their values. Returns: subprocess.Popen instance: You can use Popen.communicate interface or stderr/stdout properties of the instance (stdout/stderr must not be set to None in such case) in order to retrieve the actual process output. \"\"\" self . stop () env = kwargs [ 'env' ] if 'env' in kwargs else None node = kwargs [ 'node' ] if 'node' in kwargs else self . _get_node () stdout = kwargs [ 'stdout' ] if 'stdout' in kwargs else subprocess . PIPE stderr = kwargs [ 'stderr' ] if 'stderr' in kwargs else subprocess . PIPE timeout_ms = int ( kwargs [ 'timeout_ms' ]) if 'timeout_ms' in kwargs else STARTUP_TIMEOUT_MS main_script = kwargs [ 'main_script' ] if 'main_script' in kwargs else self . _get_main_script () args = [ node , main_script ] if 'args' in kwargs : args . extend ( kwargs [ 'args' ]) self . _cmd = args self . _process = subprocess . Popen ( args = args , stdout = stdout , stderr = stderr , env = env ) host = self . _parse_host ( args ) port = self . _parse_port ( args ) error_msg = None if not self . is_running or ( timeout_ms > 0 and not poll_url ( host , port , STATUS_URL , timeout_ms )): error_msg = 'Appium has failed to start on {}:{} within {}ms timeout' \\ . format ( host , port , timeout_ms ) if error_msg is not None : if stderr == subprocess . PIPE : err_output = self . _process . stderr . read () if err_output : error_msg += ' \\n Original error: {}' . format ( err_output ) self . stop () raise AppiumServiceError ( error_msg ) return self . _process def stop ( self ): \"\"\"Stops Appium service if it is running. The call will be ignored if the service is not running or has been already stopped. Returns: bool: `True` if the service was running before being stopped \"\"\" is_terminated = False if self . is_running : self . _process . terminate () is_terminated = True self . _process = None self . _cmd = None return is_terminated @property def is_running ( self ): \"\"\"Check if the service is running. Returns: bool: `True` or `False` \"\"\" return self . _process is not None and self . _process . poll () is None @property def is_listening ( self ): \"\"\"Check if the service is listening on the given/default host/port. The fact, that the service is running, does not always mean it is listening. the default host/port values can be customized by providing --address/--port command line arguments while starting the service. Returns: bool: `True` if the service is running and listening on the given/default host/port \"\"\" if not self . is_running or self . _cmd is None : return False host = self . _parse_host ( self . _cmd ) port = self . _parse_port ( self . _cmd ) return self . is_running and poll_url ( host , port , STATUS_URL , 1000 ) if __name__ == '__main__' : assert ( find_executable ( 'node' ) is not None ) assert ( find_executable ( 'npm' ) is not None ) service = AppiumService () service . start ( args = [ '--address' , '127.0.0.1' , '-p' , str ( DEFAULT_PORT )]) # service.start(args=['--address', '127.0.0.1', '-p', '80'], timeout_ms=2000) assert ( service . is_running ) assert ( service . is_listening ) service . stop () assert ( not service . is_running ) assert ( not service . is_listening ) Variables DEFAULT_HOST DEFAULT_PORT MAIN_SCRIPT_PATH STARTUP_TIMEOUT_MS STATUS_URL Functions find_executable def find_executable ( executable ) View Source def find_executable ( executable ) : path = os . environ [ ' PATH ' ] paths = path . split ( os . pathsep ) base , ext = os . path . splitext ( executable ) if sys . platform == ' win32 ' and not ext : executable = executable + ' .exe ' if os . path . isfile ( executable ) : return executable for p in paths : full_path = os . path . join ( p , executable ) if os . path . isfile ( full_path ) : return full_path return None poll_url def poll_url ( host , port , path , timeout_ms ) View Source def poll_url ( host , port , path , timeout_ms ) : time_started_sec = time . time () while time . time () < time_started_sec + timeout_ms / 1000 . 0 : try : conn = urllib3 . PoolManager ( timeout = 1 . 0 ) resp = conn . request ( ' HEAD ' , ' http://{host}:{port}{path} ' . format ( host = host , port = port , path = path )) if resp . status < 400 : return True except Exception : pass time . sleep ( 1 . 0 ) return False Classes AppiumService class AppiumService ( ) View Source class AppiumService ( object ) : def __init__ ( self ) : self . _process = None self . _cmd = None def _get_node ( self ) : if not hasattr ( self , ' _node_executable ' ) : self . _node_executable = find_executable ( ' node ' ) if self . _node_executable is None : raise AppiumServiceError ( ' NodeJS main executable cannot be found. ' + ' Make sure it is installed and present in PATH ' ) return self . _node_executable def _get_npm ( self ) : if not hasattr ( self , ' _npm_executable ' ) : self . _npm_executable = find_executable ( ' npm.cmd ' if sys . platform == ' win32 ' else ' npm ' ) if self . _npm_executable is None : raise AppiumServiceError ( ' Node Package Manager executable cannot be found. ' + ' Make sure it is installed and present in PATH ' ) return self . _npm_executable def _get_main_script ( self ) : if not hasattr ( self , ' _main_script ' ) : for args in [[ ' root ' , ' -g ' ], [ ' root ' ]]: try : modules_root = subprocess . check_output ( [ self . _get_npm () ] + args ) . strip () . decode ( ' utf-8 ' ) if os . path . exists ( os . path . join ( modules_root , MAIN_SCRIPT_PATH )) : self . _main_script = os . path . join ( modules_root , MAIN_SCRIPT_PATH ) break except subprocess . CalledProcessError : continue if not hasattr ( self , ' _main_script ' ) : try : self . _main_script = subprocess . check_output ( [ self . _get_node () , ' -e ' , ' console.log(require.resolve(\"{}\")) ' . format ( MAIN_SCRIPT_PATH ) ] ) . strip () except subprocess . CalledProcessError as e : raise AppiumServiceError ( e . output ) return self . _main_script @ staticmethod def _parse_port ( args ) : for idx , arg in enumerate ( args or [] ) : if arg in ( ' --port ' , ' -p ' ) and idx < len ( args ) - 1 : return int ( args [ idx + 1 ] ) return DEFAULT_PORT @ staticmethod def _parse_host ( args ) : for idx , arg in enumerate ( args or [] ) : if arg in ( ' --address ' , ' -a ' ) and idx < len ( args ) - 1 : return args [ idx + 1 ] return DEFAULT_HOST def start ( self , ** kwargs ) : \"\"\" Starts Appium service with given arguments. The service will be forcefully restarted if it is already running . Keyword Args : env ( dict ) : Environment variables mapping . The default system environment , which is inherited from the parent process is assigned by default . node ( str ) : The full path to the main NodeJS executable . The service will try to retrieve it automatically by default . stdout : Check on the documentation for subprocess . Popen for more details . The default value is subprocess . PIPE . stderr : Check on the documentation for subprocess . Popen for more details . The default value is subprocess . PIPE . timeout_ms ( int ) : The maximum time to wait until Appium process starts listening for HTTP connections . If set to zero or a negative number then no wait will be applied . 60000 ms by default main_script ( str ) : The full path to the main Appium executable ( usually located this is build / lib / main . js ) . If this is not set then the service tries to detect the path automatically . args ( str ) : List of Appium arguments ( all must be strings ) . Check on https : // appium . io / docs / en / writing - running - appium / server - args / for more details about possible arguments and their values . Returns : subprocess . Popen instance : You can use Popen . communicate interface or stderr / stdout properties of the instance ( stdout / stderr must not be set to None in such case ) in order to retrieve the actual process output . \"\"\" self . stop () env = kwargs [ ' env ' ] if ' env ' in kwargs else None node = kwargs [ ' node ' ] if ' node ' in kwargs else self . _get_node () stdout = kwargs [ ' stdout ' ] if ' stdout ' in kwargs else subprocess . PIPE stderr = kwargs [ ' stderr ' ] if ' stderr ' in kwargs else subprocess . PIPE timeout_ms = int ( kwargs [ ' timeout_ms ' ] ) if ' timeout_ms ' in kwargs else STARTUP_TIMEOUT_MS main_script = kwargs [ ' main_script ' ] if ' main_script ' in kwargs else self . _get_main_script () args = [ node , main_script ] if ' args ' in kwargs : args . extend ( kwargs [ ' args ' ] ) self . _cmd = args self . _process = subprocess . Popen ( args = args , stdout = stdout , stderr = stderr , env = env ) host = self . _parse_host ( args ) port = self . _parse_port ( args ) error_msg = None if not self . is_running or ( timeout_ms > 0 and not poll_url ( host , port , STATUS_URL , timeout_ms )) : error_msg = ' Appium has failed to start on {}:{} within {}ms timeout ' \\ . format ( host , port , timeout_ms ) if error_msg is not None : if stderr == subprocess . PIPE : err_output = self . _process . stderr . read () if err_output : error_msg += ' \\n Original error: {} ' . format ( err_output ) self . stop () raise AppiumServiceError ( error_msg ) return self . _process def stop ( self ) : \"\"\" Stops Appium service if it is running. The call will be ignored if the service is not running or has been already stopped . Returns : bool : ` True ` if the service was running before being stopped \"\"\" is_terminated = False if self . is_running : self . _process . terminate () is_terminated = True self . _process = None self . _cmd = None return is_terminated @ property def is_running ( self ) : \"\"\" Check if the service is running. Returns : bool : ` True ` or ` False ` \"\"\" return self . _process is not None and self . _process . poll () is None @ property def is_listening ( self ) : \"\"\" Check if the service is listening on the given/default host/port. The fact , that the service is running , does not always mean it is listening . the default host / port values can be customized by providing -- address /-- port command line arguments while starting the service . Returns : bool : ` True ` if the service is running and listening on the given / default host / port \"\"\" if not self . is_running or self . _cmd is None : return False host = self . _parse_host ( self . _cmd ) port = self . _parse_port ( self . _cmd ) return self . is_running and poll_url ( host , port , STATUS_URL , 1000 ) Instance variables is_listening Check if the service is listening on the given/default host/port. The fact, that the service is running, does not always mean it is listening. the default host/port values can be customized by providing --address/--port command line arguments while starting the service. Returns: bool: True if the service is running and listening on the given/default host/port is_running Check if the service is running. Returns: bool: True or False Methods start def start ( self , ** kwargs ) Starts Appium service with given arguments. The service will be forcefully restarted if it is already running. Keyword Args: env (dict): Environment variables mapping. The default system environment, which is inherited from the parent process is assigned by default. node (str): The full path to the main NodeJS executable. The service will try to retrieve it automatically by default. stdout: Check on the documentation for subprocess.Popen for more details. The default value is subprocess.PIPE. stderr: Check on the documentation for subprocess.Popen for more details. The default value is subprocess.PIPE. timeout_ms (int): The maximum time to wait until Appium process starts listening for HTTP connections. If set to zero or a negative number then no wait will be applied. 60000 ms by default main_script (str): The full path to the main Appium executable (usually located this is build/lib/main.js). If this is not set then the service tries to detect the path automatically. args (str): List of Appium arguments (all must be strings). Check on https://appium.io/docs/en/writing-running-appium/server-args/ for more details about possible arguments and their values. Returns: subprocess.Popen instance: You can use Popen.communicate interface or stderr/stdout properties of the instance (stdout/stderr must not be set to None in such case) in order to retrieve the actual process output. View Source def start ( self , ** kwargs ) : \"\"\" Starts Appium service with given arguments. The service will be forcefully restarted if it is already running . Keyword Args : env ( dict ) : Environment variables mapping . The default system environment , which is inherited from the parent process is assigned by default . node ( str ) : The full path to the main NodeJS executable . The service will try to retrieve it automatically by default . stdout : Check on the documentation for subprocess . Popen for more details . The default value is subprocess . PIPE . stderr : Check on the documentation for subprocess . Popen for more details . The default value is subprocess . PIPE . timeout_ms ( int ) : The maximum time to wait until Appium process starts listening for HTTP connections . If set to zero or a negative number then no wait will be applied . 60000 ms by default main_script ( str ) : The full path to the main Appium executable ( usually located this is build / lib / main . js ) . If this is not set then the service tries to detect the path automatically . args ( str ) : List of Appium arguments ( all must be strings ) . Check on https : // appium . io / docs / en / writing - running - appium / server - args / for more details about possible arguments and their values . Returns : subprocess . Popen instance : You can use Popen . communicate interface or stderr / stdout properties of the instance ( stdout / stderr must not be set to None in such case ) in order to retrieve the actual process output . \"\"\" self . stop () env = kwargs [ ' env ' ] if ' env ' in kwargs else None node = kwargs [ ' node ' ] if ' node ' in kwargs else self . _get_node () stdout = kwargs [ ' stdout ' ] if ' stdout ' in kwargs else subprocess . PIPE stderr = kwargs [ ' stderr ' ] if ' stderr ' in kwargs else subprocess . PIPE timeout_ms = int ( kwargs [ ' timeout_ms ' ] ) if ' timeout_ms ' in kwargs else STARTUP_TIMEOUT_MS main_script = kwargs [ ' main_script ' ] if ' main_script ' in kwargs else self . _get_main_script () args = [ node , main_script ] if ' args ' in kwargs : args . extend ( kwargs [ ' args ' ] ) self . _cmd = args self . _process = subprocess . Popen ( args = args , stdout = stdout , stderr = stderr , env = env ) host = self . _parse_host ( args ) port = self . _parse_port ( args ) error_msg = None if not self . is_running or ( timeout_ms > 0 and not poll_url ( host , port , STATUS_URL , timeout_ms )) : error_msg = ' Appium has failed to start on {}:{} within {}ms timeout ' \\ . format ( host , port , timeout_ms ) if error_msg is not None : if stderr == subprocess . PIPE : err_output = self . _process . stderr . read () if err_output : error_msg += ' \\n Original error: {} ' . format ( err_output ) self . stop () raise AppiumServiceError ( error_msg ) return self . _process stop def stop ( self ) Stops Appium service if it is running. The call will be ignored if the service is not running or has been already stopped. Returns: bool: True if the service was running before being stopped View Source def stop ( self ) : \"\"\" Stops Appium service if it is running. The call will be ignored if the service is not running or has been already stopped . Returns : bool : ` True ` if the service was running before being stopped \"\"\" is_terminated = False if self . is_running : self . _process . terminate () is_terminated = True self . _process = None self . _cmd = None return is_terminated AppiumServiceError class AppiumServiceError ( / , * args , ** kwargs ) Unspecified run-time error. View Source class AppiumServiceError ( RuntimeError ): pass Ancestors (in MRO) builtins.RuntimeError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Appium Service"},{"location":"reference/appium/webdriver/appium_service/#module-appiumwebdriverappium_service","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import os import subprocess import sys import time import urllib3 DEFAULT_HOST = '127.0.0.1' DEFAULT_PORT = 4723 STARTUP_TIMEOUT_MS = 60000 MAIN_SCRIPT_PATH = 'appium/build/lib/main.js' STATUS_URL = '/wd/hub/status' def find_executable ( executable ): path = os . environ [ 'PATH' ] paths = path . split ( os . pathsep ) base , ext = os . path . splitext ( executable ) if sys . platform == 'win32' and not ext : executable = executable + '.exe' if os . path . isfile ( executable ): return executable for p in paths : full_path = os . path . join ( p , executable ) if os . path . isfile ( full_path ): return full_path return None def poll_url ( host , port , path , timeout_ms ): time_started_sec = time . time () while time . time () < time_started_sec + timeout_ms / 1000.0 : try : conn = urllib3 . PoolManager ( timeout = 1.0 ) resp = conn . request ( 'HEAD' , 'http://{host}:{port}{path}' . format ( host = host , port = port , path = path )) if resp . status < 400 : return True except Exception : pass time . sleep ( 1.0 ) return False class AppiumServiceError ( RuntimeError ): pass class AppiumService ( object ): def __init__ ( self ): self . _process = None self . _cmd = None def _get_node ( self ): if not hasattr ( self , '_node_executable' ): self . _node_executable = find_executable ( 'node' ) if self . _node_executable is None : raise AppiumServiceError ( 'NodeJS main executable cannot be found. ' + 'Make sure it is installed and present in PATH' ) return self . _node_executable def _get_npm ( self ): if not hasattr ( self , '_npm_executable' ): self . _npm_executable = find_executable ( 'npm.cmd' if sys . platform == 'win32' else 'npm' ) if self . _npm_executable is None : raise AppiumServiceError ( 'Node Package Manager executable cannot be found. ' + 'Make sure it is installed and present in PATH' ) return self . _npm_executable def _get_main_script ( self ): if not hasattr ( self , '_main_script' ): for args in [[ 'root' , '-g' ], [ 'root' ]]: try : modules_root = subprocess . check_output ([ self . _get_npm ()] + args ) . strip () . decode ( 'utf-8' ) if os . path . exists ( os . path . join ( modules_root , MAIN_SCRIPT_PATH )): self . _main_script = os . path . join ( modules_root , MAIN_SCRIPT_PATH ) break except subprocess . CalledProcessError : continue if not hasattr ( self , '_main_script' ): try : self . _main_script = subprocess . check_output ( [ self . _get_node (), '-e' , 'console.log(require.resolve(\"{}\"))' . format ( MAIN_SCRIPT_PATH )]) . strip () except subprocess . CalledProcessError as e : raise AppiumServiceError ( e . output ) return self . _main_script @staticmethod def _parse_port ( args ): for idx , arg in enumerate ( args or []): if arg in ( '--port' , '-p' ) and idx < len ( args ) - 1 : return int ( args [ idx + 1 ]) return DEFAULT_PORT @staticmethod def _parse_host ( args ): for idx , arg in enumerate ( args or []): if arg in ( '--address' , '-a' ) and idx < len ( args ) - 1 : return args [ idx + 1 ] return DEFAULT_HOST def start ( self , ** kwargs ): \"\"\"Starts Appium service with given arguments. The service will be forcefully restarted if it is already running. Keyword Args: env (dict): Environment variables mapping. The default system environment, which is inherited from the parent process is assigned by default. node (str): The full path to the main NodeJS executable. The service will try to retrieve it automatically by default. stdout: Check on the documentation for subprocess.Popen for more details. The default value is subprocess.PIPE. stderr: Check on the documentation for subprocess.Popen for more details. The default value is subprocess.PIPE. timeout_ms (int): The maximum time to wait until Appium process starts listening for HTTP connections. If set to zero or a negative number then no wait will be applied. 60000 ms by default main_script (str): The full path to the main Appium executable (usually located this is build/lib/main.js). If this is not set then the service tries to detect the path automatically. args (str): List of Appium arguments (all must be strings). Check on https://appium.io/docs/en/writing-running-appium/server-args/ for more details about possible arguments and their values. Returns: subprocess.Popen instance: You can use Popen.communicate interface or stderr/stdout properties of the instance (stdout/stderr must not be set to None in such case) in order to retrieve the actual process output. \"\"\" self . stop () env = kwargs [ 'env' ] if 'env' in kwargs else None node = kwargs [ 'node' ] if 'node' in kwargs else self . _get_node () stdout = kwargs [ 'stdout' ] if 'stdout' in kwargs else subprocess . PIPE stderr = kwargs [ 'stderr' ] if 'stderr' in kwargs else subprocess . PIPE timeout_ms = int ( kwargs [ 'timeout_ms' ]) if 'timeout_ms' in kwargs else STARTUP_TIMEOUT_MS main_script = kwargs [ 'main_script' ] if 'main_script' in kwargs else self . _get_main_script () args = [ node , main_script ] if 'args' in kwargs : args . extend ( kwargs [ 'args' ]) self . _cmd = args self . _process = subprocess . Popen ( args = args , stdout = stdout , stderr = stderr , env = env ) host = self . _parse_host ( args ) port = self . _parse_port ( args ) error_msg = None if not self . is_running or ( timeout_ms > 0 and not poll_url ( host , port , STATUS_URL , timeout_ms )): error_msg = 'Appium has failed to start on {}:{} within {}ms timeout' \\ . format ( host , port , timeout_ms ) if error_msg is not None : if stderr == subprocess . PIPE : err_output = self . _process . stderr . read () if err_output : error_msg += ' \\n Original error: {}' . format ( err_output ) self . stop () raise AppiumServiceError ( error_msg ) return self . _process def stop ( self ): \"\"\"Stops Appium service if it is running. The call will be ignored if the service is not running or has been already stopped. Returns: bool: `True` if the service was running before being stopped \"\"\" is_terminated = False if self . is_running : self . _process . terminate () is_terminated = True self . _process = None self . _cmd = None return is_terminated @property def is_running ( self ): \"\"\"Check if the service is running. Returns: bool: `True` or `False` \"\"\" return self . _process is not None and self . _process . poll () is None @property def is_listening ( self ): \"\"\"Check if the service is listening on the given/default host/port. The fact, that the service is running, does not always mean it is listening. the default host/port values can be customized by providing --address/--port command line arguments while starting the service. Returns: bool: `True` if the service is running and listening on the given/default host/port \"\"\" if not self . is_running or self . _cmd is None : return False host = self . _parse_host ( self . _cmd ) port = self . _parse_port ( self . _cmd ) return self . is_running and poll_url ( host , port , STATUS_URL , 1000 ) if __name__ == '__main__' : assert ( find_executable ( 'node' ) is not None ) assert ( find_executable ( 'npm' ) is not None ) service = AppiumService () service . start ( args = [ '--address' , '127.0.0.1' , '-p' , str ( DEFAULT_PORT )]) # service.start(args=['--address', '127.0.0.1', '-p', '80'], timeout_ms=2000) assert ( service . is_running ) assert ( service . is_listening ) service . stop () assert ( not service . is_running ) assert ( not service . is_listening )","title":"Module appium.webdriver.appium_service"},{"location":"reference/appium/webdriver/appium_service/#variables","text":"DEFAULT_HOST DEFAULT_PORT MAIN_SCRIPT_PATH STARTUP_TIMEOUT_MS STATUS_URL","title":"Variables"},{"location":"reference/appium/webdriver/appium_service/#functions","text":"","title":"Functions"},{"location":"reference/appium/webdriver/appium_service/#find_executable","text":"def find_executable ( executable ) View Source def find_executable ( executable ) : path = os . environ [ ' PATH ' ] paths = path . split ( os . pathsep ) base , ext = os . path . splitext ( executable ) if sys . platform == ' win32 ' and not ext : executable = executable + ' .exe ' if os . path . isfile ( executable ) : return executable for p in paths : full_path = os . path . join ( p , executable ) if os . path . isfile ( full_path ) : return full_path return None","title":"find_executable"},{"location":"reference/appium/webdriver/appium_service/#poll_url","text":"def poll_url ( host , port , path , timeout_ms ) View Source def poll_url ( host , port , path , timeout_ms ) : time_started_sec = time . time () while time . time () < time_started_sec + timeout_ms / 1000 . 0 : try : conn = urllib3 . PoolManager ( timeout = 1 . 0 ) resp = conn . request ( ' HEAD ' , ' http://{host}:{port}{path} ' . format ( host = host , port = port , path = path )) if resp . status < 400 : return True except Exception : pass time . sleep ( 1 . 0 ) return False","title":"poll_url"},{"location":"reference/appium/webdriver/appium_service/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/appium_service/#appiumservice","text":"class AppiumService ( ) View Source class AppiumService ( object ) : def __init__ ( self ) : self . _process = None self . _cmd = None def _get_node ( self ) : if not hasattr ( self , ' _node_executable ' ) : self . _node_executable = find_executable ( ' node ' ) if self . _node_executable is None : raise AppiumServiceError ( ' NodeJS main executable cannot be found. ' + ' Make sure it is installed and present in PATH ' ) return self . _node_executable def _get_npm ( self ) : if not hasattr ( self , ' _npm_executable ' ) : self . _npm_executable = find_executable ( ' npm.cmd ' if sys . platform == ' win32 ' else ' npm ' ) if self . _npm_executable is None : raise AppiumServiceError ( ' Node Package Manager executable cannot be found. ' + ' Make sure it is installed and present in PATH ' ) return self . _npm_executable def _get_main_script ( self ) : if not hasattr ( self , ' _main_script ' ) : for args in [[ ' root ' , ' -g ' ], [ ' root ' ]]: try : modules_root = subprocess . check_output ( [ self . _get_npm () ] + args ) . strip () . decode ( ' utf-8 ' ) if os . path . exists ( os . path . join ( modules_root , MAIN_SCRIPT_PATH )) : self . _main_script = os . path . join ( modules_root , MAIN_SCRIPT_PATH ) break except subprocess . CalledProcessError : continue if not hasattr ( self , ' _main_script ' ) : try : self . _main_script = subprocess . check_output ( [ self . _get_node () , ' -e ' , ' console.log(require.resolve(\"{}\")) ' . format ( MAIN_SCRIPT_PATH ) ] ) . strip () except subprocess . CalledProcessError as e : raise AppiumServiceError ( e . output ) return self . _main_script @ staticmethod def _parse_port ( args ) : for idx , arg in enumerate ( args or [] ) : if arg in ( ' --port ' , ' -p ' ) and idx < len ( args ) - 1 : return int ( args [ idx + 1 ] ) return DEFAULT_PORT @ staticmethod def _parse_host ( args ) : for idx , arg in enumerate ( args or [] ) : if arg in ( ' --address ' , ' -a ' ) and idx < len ( args ) - 1 : return args [ idx + 1 ] return DEFAULT_HOST def start ( self , ** kwargs ) : \"\"\" Starts Appium service with given arguments. The service will be forcefully restarted if it is already running . Keyword Args : env ( dict ) : Environment variables mapping . The default system environment , which is inherited from the parent process is assigned by default . node ( str ) : The full path to the main NodeJS executable . The service will try to retrieve it automatically by default . stdout : Check on the documentation for subprocess . Popen for more details . The default value is subprocess . PIPE . stderr : Check on the documentation for subprocess . Popen for more details . The default value is subprocess . PIPE . timeout_ms ( int ) : The maximum time to wait until Appium process starts listening for HTTP connections . If set to zero or a negative number then no wait will be applied . 60000 ms by default main_script ( str ) : The full path to the main Appium executable ( usually located this is build / lib / main . js ) . If this is not set then the service tries to detect the path automatically . args ( str ) : List of Appium arguments ( all must be strings ) . Check on https : // appium . io / docs / en / writing - running - appium / server - args / for more details about possible arguments and their values . Returns : subprocess . Popen instance : You can use Popen . communicate interface or stderr / stdout properties of the instance ( stdout / stderr must not be set to None in such case ) in order to retrieve the actual process output . \"\"\" self . stop () env = kwargs [ ' env ' ] if ' env ' in kwargs else None node = kwargs [ ' node ' ] if ' node ' in kwargs else self . _get_node () stdout = kwargs [ ' stdout ' ] if ' stdout ' in kwargs else subprocess . PIPE stderr = kwargs [ ' stderr ' ] if ' stderr ' in kwargs else subprocess . PIPE timeout_ms = int ( kwargs [ ' timeout_ms ' ] ) if ' timeout_ms ' in kwargs else STARTUP_TIMEOUT_MS main_script = kwargs [ ' main_script ' ] if ' main_script ' in kwargs else self . _get_main_script () args = [ node , main_script ] if ' args ' in kwargs : args . extend ( kwargs [ ' args ' ] ) self . _cmd = args self . _process = subprocess . Popen ( args = args , stdout = stdout , stderr = stderr , env = env ) host = self . _parse_host ( args ) port = self . _parse_port ( args ) error_msg = None if not self . is_running or ( timeout_ms > 0 and not poll_url ( host , port , STATUS_URL , timeout_ms )) : error_msg = ' Appium has failed to start on {}:{} within {}ms timeout ' \\ . format ( host , port , timeout_ms ) if error_msg is not None : if stderr == subprocess . PIPE : err_output = self . _process . stderr . read () if err_output : error_msg += ' \\n Original error: {} ' . format ( err_output ) self . stop () raise AppiumServiceError ( error_msg ) return self . _process def stop ( self ) : \"\"\" Stops Appium service if it is running. The call will be ignored if the service is not running or has been already stopped . Returns : bool : ` True ` if the service was running before being stopped \"\"\" is_terminated = False if self . is_running : self . _process . terminate () is_terminated = True self . _process = None self . _cmd = None return is_terminated @ property def is_running ( self ) : \"\"\" Check if the service is running. Returns : bool : ` True ` or ` False ` \"\"\" return self . _process is not None and self . _process . poll () is None @ property def is_listening ( self ) : \"\"\" Check if the service is listening on the given/default host/port. The fact , that the service is running , does not always mean it is listening . the default host / port values can be customized by providing -- address /-- port command line arguments while starting the service . Returns : bool : ` True ` if the service is running and listening on the given / default host / port \"\"\" if not self . is_running or self . _cmd is None : return False host = self . _parse_host ( self . _cmd ) port = self . _parse_port ( self . _cmd ) return self . is_running and poll_url ( host , port , STATUS_URL , 1000 )","title":"AppiumService"},{"location":"reference/appium/webdriver/appium_service/#instance-variables","text":"is_listening Check if the service is listening on the given/default host/port. The fact, that the service is running, does not always mean it is listening. the default host/port values can be customized by providing --address/--port command line arguments while starting the service. Returns: bool: True if the service is running and listening on the given/default host/port is_running Check if the service is running. Returns: bool: True or False","title":"Instance variables"},{"location":"reference/appium/webdriver/appium_service/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/appium_service/#start","text":"def start ( self , ** kwargs ) Starts Appium service with given arguments. The service will be forcefully restarted if it is already running. Keyword Args: env (dict): Environment variables mapping. The default system environment, which is inherited from the parent process is assigned by default. node (str): The full path to the main NodeJS executable. The service will try to retrieve it automatically by default. stdout: Check on the documentation for subprocess.Popen for more details. The default value is subprocess.PIPE. stderr: Check on the documentation for subprocess.Popen for more details. The default value is subprocess.PIPE. timeout_ms (int): The maximum time to wait until Appium process starts listening for HTTP connections. If set to zero or a negative number then no wait will be applied. 60000 ms by default main_script (str): The full path to the main Appium executable (usually located this is build/lib/main.js). If this is not set then the service tries to detect the path automatically. args (str): List of Appium arguments (all must be strings). Check on https://appium.io/docs/en/writing-running-appium/server-args/ for more details about possible arguments and their values. Returns: subprocess.Popen instance: You can use Popen.communicate interface or stderr/stdout properties of the instance (stdout/stderr must not be set to None in such case) in order to retrieve the actual process output. View Source def start ( self , ** kwargs ) : \"\"\" Starts Appium service with given arguments. The service will be forcefully restarted if it is already running . Keyword Args : env ( dict ) : Environment variables mapping . The default system environment , which is inherited from the parent process is assigned by default . node ( str ) : The full path to the main NodeJS executable . The service will try to retrieve it automatically by default . stdout : Check on the documentation for subprocess . Popen for more details . The default value is subprocess . PIPE . stderr : Check on the documentation for subprocess . Popen for more details . The default value is subprocess . PIPE . timeout_ms ( int ) : The maximum time to wait until Appium process starts listening for HTTP connections . If set to zero or a negative number then no wait will be applied . 60000 ms by default main_script ( str ) : The full path to the main Appium executable ( usually located this is build / lib / main . js ) . If this is not set then the service tries to detect the path automatically . args ( str ) : List of Appium arguments ( all must be strings ) . Check on https : // appium . io / docs / en / writing - running - appium / server - args / for more details about possible arguments and their values . Returns : subprocess . Popen instance : You can use Popen . communicate interface or stderr / stdout properties of the instance ( stdout / stderr must not be set to None in such case ) in order to retrieve the actual process output . \"\"\" self . stop () env = kwargs [ ' env ' ] if ' env ' in kwargs else None node = kwargs [ ' node ' ] if ' node ' in kwargs else self . _get_node () stdout = kwargs [ ' stdout ' ] if ' stdout ' in kwargs else subprocess . PIPE stderr = kwargs [ ' stderr ' ] if ' stderr ' in kwargs else subprocess . PIPE timeout_ms = int ( kwargs [ ' timeout_ms ' ] ) if ' timeout_ms ' in kwargs else STARTUP_TIMEOUT_MS main_script = kwargs [ ' main_script ' ] if ' main_script ' in kwargs else self . _get_main_script () args = [ node , main_script ] if ' args ' in kwargs : args . extend ( kwargs [ ' args ' ] ) self . _cmd = args self . _process = subprocess . Popen ( args = args , stdout = stdout , stderr = stderr , env = env ) host = self . _parse_host ( args ) port = self . _parse_port ( args ) error_msg = None if not self . is_running or ( timeout_ms > 0 and not poll_url ( host , port , STATUS_URL , timeout_ms )) : error_msg = ' Appium has failed to start on {}:{} within {}ms timeout ' \\ . format ( host , port , timeout_ms ) if error_msg is not None : if stderr == subprocess . PIPE : err_output = self . _process . stderr . read () if err_output : error_msg += ' \\n Original error: {} ' . format ( err_output ) self . stop () raise AppiumServiceError ( error_msg ) return self . _process","title":"start"},{"location":"reference/appium/webdriver/appium_service/#stop","text":"def stop ( self ) Stops Appium service if it is running. The call will be ignored if the service is not running or has been already stopped. Returns: bool: True if the service was running before being stopped View Source def stop ( self ) : \"\"\" Stops Appium service if it is running. The call will be ignored if the service is not running or has been already stopped . Returns : bool : ` True ` if the service was running before being stopped \"\"\" is_terminated = False if self . is_running : self . _process . terminate () is_terminated = True self . _process = None self . _cmd = None return is_terminated","title":"stop"},{"location":"reference/appium/webdriver/appium_service/#appiumserviceerror","text":"class AppiumServiceError ( / , * args , ** kwargs ) Unspecified run-time error. View Source class AppiumServiceError ( RuntimeError ): pass","title":"AppiumServiceError"},{"location":"reference/appium/webdriver/appium_service/#ancestors-in-mro","text":"builtins.RuntimeError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/appium_service/#class-variables","text":"args","title":"Class variables"},{"location":"reference/appium/webdriver/appium_service/#methods_1","text":"","title":"Methods"},{"location":"reference/appium/webdriver/appium_service/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/appium/webdriver/applicationstate/","text":"Module appium.webdriver.applicationstate View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. class ApplicationState ( object ): NOT_INSTALLED = 0 NOT_RUNNING = 1 RUNNING_IN_BACKGROUND_SUSPENDED = 2 RUNNING_IN_BACKGROUND = 3 RUNNING_IN_FOREGROUND = 4 Classes ApplicationState class ApplicationState ( / , * args , ** kwargs ) View Source class ApplicationState ( object ): NOT_INSTALLED = 0 NOT_RUNNING = 1 RUNNING_IN_BACKGROUND_SUSPENDED = 2 RUNNING_IN_BACKGROUND = 3 RUNNING_IN_FOREGROUND = 4 Class variables NOT_INSTALLED NOT_RUNNING RUNNING_IN_BACKGROUND RUNNING_IN_BACKGROUND_SUSPENDED RUNNING_IN_FOREGROUND","title":"Applicationstate"},{"location":"reference/appium/webdriver/applicationstate/#module-appiumwebdriverapplicationstate","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. class ApplicationState ( object ): NOT_INSTALLED = 0 NOT_RUNNING = 1 RUNNING_IN_BACKGROUND_SUSPENDED = 2 RUNNING_IN_BACKGROUND = 3 RUNNING_IN_FOREGROUND = 4","title":"Module appium.webdriver.applicationstate"},{"location":"reference/appium/webdriver/applicationstate/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/applicationstate/#applicationstate","text":"class ApplicationState ( / , * args , ** kwargs ) View Source class ApplicationState ( object ): NOT_INSTALLED = 0 NOT_RUNNING = 1 RUNNING_IN_BACKGROUND_SUSPENDED = 2 RUNNING_IN_BACKGROUND = 3 RUNNING_IN_FOREGROUND = 4","title":"ApplicationState"},{"location":"reference/appium/webdriver/applicationstate/#class-variables","text":"NOT_INSTALLED NOT_RUNNING RUNNING_IN_BACKGROUND RUNNING_IN_BACKGROUND_SUSPENDED RUNNING_IN_FOREGROUND","title":"Class variables"},{"location":"reference/appium/webdriver/clipboard_content_type/","text":"Module appium.webdriver.clipboard_content_type View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. class ClipboardContentType ( object ): PLAINTEXT = 'plaintext' IMAGE = 'image' URL = 'url' Classes ClipboardContentType class ClipboardContentType ( / , * args , ** kwargs ) View Source class ClipboardContentType ( object ): PLAINTEXT = 'plaintext' IMAGE = 'image' URL = 'url' Class variables IMAGE PLAINTEXT URL","title":"Clipboard Content Type"},{"location":"reference/appium/webdriver/clipboard_content_type/#module-appiumwebdriverclipboard_content_type","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. class ClipboardContentType ( object ): PLAINTEXT = 'plaintext' IMAGE = 'image' URL = 'url'","title":"Module appium.webdriver.clipboard_content_type"},{"location":"reference/appium/webdriver/clipboard_content_type/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/clipboard_content_type/#clipboardcontenttype","text":"class ClipboardContentType ( / , * args , ** kwargs ) View Source class ClipboardContentType ( object ): PLAINTEXT = 'plaintext' IMAGE = 'image' URL = 'url'","title":"ClipboardContentType"},{"location":"reference/appium/webdriver/clipboard_content_type/#class-variables","text":"IMAGE PLAINTEXT URL","title":"Class variables"},{"location":"reference/appium/webdriver/connectiontype/","text":"Module appium.webdriver.connectiontype Connection types are specified here: https://code.google.com/p/selenium/source/browse/spec-draft.md?repo=mobile#120 Value (Alias) | Data | Wifi | Airplane Mode 0 (None) | 0 | 0 | 0 1 (Airplane Mode) | 0 | 0 | 1 2 (Wifi only) | 0 | 1 | 0 4 (Data only) | 1 | 0 | 0 6 (All network on) | 1 | 1 | 0 View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. \"\"\" Connection types are specified here: https://code.google.com/p/selenium/source/browse/spec-draft.md?repo=mobile#120 Value (Alias) | Data | Wifi | Airplane Mode ------------------------------------------------- 0 (None) | 0 | 0 | 0 1 (Airplane Mode) | 0 | 0 | 1 2 (Wifi only) | 0 | 1 | 0 4 (Data only) | 1 | 0 | 0 6 (All network on) | 1 | 1 | 0 \"\"\" class ConnectionType ( object ): NO_CONNECTION = 0 AIRPLANE_MODE = 1 WIFI_ONLY = 2 DATA_ONLY = 4 ALL_NETWORK_ON = 6 Classes ConnectionType class ConnectionType ( / , * args , ** kwargs ) View Source class ConnectionType ( object ): NO_CONNECTION = 0 AIRPLANE_MODE = 1 WIFI_ONLY = 2 DATA_ONLY = 4 ALL_NETWORK_ON = 6 Class variables AIRPLANE_MODE ALL_NETWORK_ON DATA_ONLY NO_CONNECTION WIFI_ONLY","title":"Connectiontype"},{"location":"reference/appium/webdriver/connectiontype/#module-appiumwebdriverconnectiontype","text":"Connection types are specified here: https://code.google.com/p/selenium/source/browse/spec-draft.md?repo=mobile#120 Value (Alias) | Data | Wifi | Airplane Mode 0 (None) | 0 | 0 | 0 1 (Airplane Mode) | 0 | 0 | 1 2 (Wifi only) | 0 | 1 | 0 4 (Data only) | 1 | 0 | 0 6 (All network on) | 1 | 1 | 0 View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. \"\"\" Connection types are specified here: https://code.google.com/p/selenium/source/browse/spec-draft.md?repo=mobile#120 Value (Alias) | Data | Wifi | Airplane Mode ------------------------------------------------- 0 (None) | 0 | 0 | 0 1 (Airplane Mode) | 0 | 0 | 1 2 (Wifi only) | 0 | 1 | 0 4 (Data only) | 1 | 0 | 0 6 (All network on) | 1 | 1 | 0 \"\"\" class ConnectionType ( object ): NO_CONNECTION = 0 AIRPLANE_MODE = 1 WIFI_ONLY = 2 DATA_ONLY = 4 ALL_NETWORK_ON = 6","title":"Module appium.webdriver.connectiontype"},{"location":"reference/appium/webdriver/connectiontype/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/connectiontype/#connectiontype","text":"class ConnectionType ( / , * args , ** kwargs ) View Source class ConnectionType ( object ): NO_CONNECTION = 0 AIRPLANE_MODE = 1 WIFI_ONLY = 2 DATA_ONLY = 4 ALL_NETWORK_ON = 6","title":"ConnectionType"},{"location":"reference/appium/webdriver/connectiontype/#class-variables","text":"AIRPLANE_MODE ALL_NETWORK_ON DATA_ONLY NO_CONNECTION WIFI_ONLY","title":"Class variables"},{"location":"reference/appium/webdriver/errorhandler/","text":"Module appium.webdriver.errorhandler View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium.common.exceptions import WebDriverException from selenium.webdriver.remote import errorhandler from appium.common.exceptions import NoSuchContextException class MobileErrorHandler ( errorhandler . ErrorHandler ): def check_response ( self , response ): try : super ( MobileErrorHandler , self ) . check_response ( response ) except WebDriverException as wde : if wde . msg == 'No such context found.' : raise NoSuchContextException ( wde . msg , wde . screen , wde . stacktrace ) else : raise wde Classes MobileErrorHandler class MobileErrorHandler ( / , * args , ** kwargs ) Handles errors returned by the WebDriver server. View Source class MobileErrorHandler ( errorhandler . ErrorHandler ) : def check_response ( self , response ) : try : super ( MobileErrorHandler , self ) . check_response ( response ) except WebDriverException as wde : if wde . msg == ' No such context found. ' : raise NoSuchContextException ( wde . msg , wde . screen , wde . stacktrace ) else : raise wde Ancestors (in MRO) selenium.webdriver.remote.errorhandler.ErrorHandler Methods check_response def check_response ( self , response ) Checks that a JSON response from the WebDriver does not have an error. :Args: - response - The JSON response from the WebDriver server as a dictionary object. :Raises: If the response contains an error message. View Source def check_response ( self , response ) : try : super ( MobileErrorHandler , self ) . check_response ( response ) except WebDriverException as wde : if wde . msg == ' No such context found. ' : raise NoSuchContextException ( wde . msg , wde . screen , wde . stacktrace ) else : raise wde","title":"Errorhandler"},{"location":"reference/appium/webdriver/errorhandler/#module-appiumwebdrivererrorhandler","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium.common.exceptions import WebDriverException from selenium.webdriver.remote import errorhandler from appium.common.exceptions import NoSuchContextException class MobileErrorHandler ( errorhandler . ErrorHandler ): def check_response ( self , response ): try : super ( MobileErrorHandler , self ) . check_response ( response ) except WebDriverException as wde : if wde . msg == 'No such context found.' : raise NoSuchContextException ( wde . msg , wde . screen , wde . stacktrace ) else : raise wde","title":"Module appium.webdriver.errorhandler"},{"location":"reference/appium/webdriver/errorhandler/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/errorhandler/#mobileerrorhandler","text":"class MobileErrorHandler ( / , * args , ** kwargs ) Handles errors returned by the WebDriver server. View Source class MobileErrorHandler ( errorhandler . ErrorHandler ) : def check_response ( self , response ) : try : super ( MobileErrorHandler , self ) . check_response ( response ) except WebDriverException as wde : if wde . msg == ' No such context found. ' : raise NoSuchContextException ( wde . msg , wde . screen , wde . stacktrace ) else : raise wde","title":"MobileErrorHandler"},{"location":"reference/appium/webdriver/errorhandler/#ancestors-in-mro","text":"selenium.webdriver.remote.errorhandler.ErrorHandler","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/errorhandler/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/errorhandler/#check_response","text":"def check_response ( self , response ) Checks that a JSON response from the WebDriver does not have an error. :Args: - response - The JSON response from the WebDriver server as a dictionary object. :Raises: If the response contains an error message. View Source def check_response ( self , response ) : try : super ( MobileErrorHandler , self ) . check_response ( response ) except WebDriverException as wde : if wde . msg == ' No such context found. ' : raise NoSuchContextException ( wde . msg , wde . screen , wde . stacktrace ) else : raise wde","title":"check_response"},{"location":"reference/appium/webdriver/mobilecommand/","text":"Module appium.webdriver.mobilecommand View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. class MobileCommand ( object ): # Common GET_SESSION = 'getSession' GET_LOCATION = 'getLocation' SET_LOCATION = 'setLocation' GET_AVAILABLE_IME_ENGINES = 'getAvailableIMEEngines' IS_IME_ACTIVE = 'isIMEActive' ACTIVATE_IME_ENGINE = 'activateIMEEngine' DEACTIVATE_IME_ENGINE = 'deactivateIMEEngine' GET_ACTIVE_IME_ENGINE = 'getActiveEngine' CLEAR = 'clear' LOCATION_IN_VIEW = 'locationInView' CONTEXTS = 'getContexts' GET_CURRENT_CONTEXT = 'getCurrentContext' SWITCH_TO_CONTEXT = 'switchToContext' TOUCH_ACTION = 'touchAction' MULTI_ACTION = 'multiAction' SET_IMMEDIATE_VALUE = 'setImmediateValue' REPLACE_KEYS = 'replaceKeys' LAUNCH_APP = 'launchApp' CLOSE_APP = 'closeApp' RESET = 'reset' BACKGROUND = 'background' GET_APP_STRINGS = 'getAppStrings' IS_LOCKED = 'isLocked' LOCK = 'lock' UNLOCK = 'unlock' GET_DEVICE_TIME_GET = 'getDeviceTimeGet' GET_DEVICE_TIME_POST = 'getDeviceTimePost' INSTALL_APP = 'installApp' REMOVE_APP = 'removeApp' IS_APP_INSTALLED = 'isAppInstalled' TERMINATE_APP = 'terminateApp' ACTIVATE_APP = 'activateApp' QUERY_APP_STATE = 'queryAppState' SHAKE = 'shake' HIDE_KEYBOARD = 'hideKeyboard' PRESS_KEYCODE = 'pressKeyCode' LONG_PRESS_KEYCODE = 'longPressKeyCode' KEY_EVENT = 'keyEvent' # Needed for Selendroid PUSH_FILE = 'pushFile' PULL_FILE = 'pullFile' PULL_FOLDER = 'pullFolder' GET_CLIPBOARD = 'getClipboard' SET_CLIPBOARD = 'setClipboard' FINGER_PRINT = 'fingerPrint' GET_SETTINGS = 'getSettings' UPDATE_SETTINGS = 'updateSettings' START_RECORDING_SCREEN = 'startRecordingScreen' STOP_RECORDING_SCREEN = 'stopRecordingScreen' COMPARE_IMAGES = 'compareImages' IS_KEYBOARD_SHOWN = 'isKeyboardShown' EXECUTE_DRIVER = 'executeDriver' # Android OPEN_NOTIFICATIONS = 'openNotifications' START_ACTIVITY = 'startActivity' GET_CURRENT_ACTIVITY = 'getCurrentActivity' GET_CURRENT_PACKAGE = 'getCurrentPackage' GET_SYSTEM_BARS = 'getSystemBars' GET_DISPLAY_DENSITY = 'getDisplayDensity' TOGGLE_WIFI = 'toggleWiFi' TOGGLE_LOCATION_SERVICES = 'toggleLocationServices' END_TEST_COVERAGE = 'endTestCoverage' GET_PERFORMANCE_DATA_TYPES = 'getPerformanceDataTypes' GET_PERFORMANCE_DATA = 'getPerformanceData' GET_NETWORK_CONNECTION = 'getNetworkConnection' SET_NETWORK_CONNECTION = 'setNetworkConnection' # Android Emulator SEND_SMS = 'sendSms' MAKE_GSM_CALL = 'makeGsmCall' SET_GSM_SIGNAL = 'setGsmSignal' SET_GSM_VOICE = 'setGsmVoice' SET_NETWORK_SPEED = 'setNetworkSpeed' SET_POWER_CAPACITY = 'setPowerCapacity' SET_POWER_AC = 'setPowerAc' # iOS TOUCH_ID = 'touchId' TOGGLE_TOUCH_ID_ENROLLMENT = 'toggleTouchIdEnrollment' Classes MobileCommand class MobileCommand ( / , * args , ** kwargs ) View Source class MobileCommand ( object ) : # Common GET_SESSION = ' getSession ' GET_LOCATION = ' getLocation ' SET_LOCATION = ' setLocation ' GET_AVAILABLE_IME_ENGINES = ' getAvailableIMEEngines ' IS_IME_ACTIVE = ' isIMEActive ' ACTIVATE_IME_ENGINE = ' activateIMEEngine ' DEACTIVATE_IME_ENGINE = ' deactivateIMEEngine ' GET_ACTIVE_IME_ENGINE = ' getActiveEngine ' CLEAR = ' clear ' LOCATION_IN_VIEW = ' locationInView ' CONTEXTS = ' getContexts ' GET_CURRENT_CONTEXT = ' getCurrentContext ' SWITCH_TO_CONTEXT = ' switchToContext ' TOUCH_ACTION = ' touchAction ' MULTI_ACTION = ' multiAction ' SET_IMMEDIATE_VALUE = ' setImmediateValue ' REPLACE_KEYS = ' replaceKeys ' LAUNCH_APP = ' launchApp ' CLOSE_APP = ' closeApp ' RESET = ' reset ' BACKGROUND = ' background ' GET_APP_STRINGS = ' getAppStrings ' IS_LOCKED = ' isLocked ' LOCK = ' lock ' UNLOCK = ' unlock ' GET_DEVICE_TIME_GET = ' getDeviceTimeGet ' GET_DEVICE_TIME_POST = ' getDeviceTimePost ' INSTALL_APP = ' installApp ' REMOVE_APP = ' removeApp ' IS_APP_INSTALLED = ' isAppInstalled ' TERMINATE_APP = ' terminateApp ' ACTIVATE_APP = ' activateApp ' QUERY_APP_STATE = ' queryAppState ' SHAKE = ' shake ' HIDE_KEYBOARD = ' hideKeyboard ' PRESS_KEYCODE = ' pressKeyCode ' LONG_PRESS_KEYCODE = ' longPressKeyCode ' KEY_EVENT = ' keyEvent ' # Needed for Selendroid PUSH_FILE = ' pushFile ' PULL_FILE = ' pullFile ' PULL_FOLDER = ' pullFolder ' GET_CLIPBOARD = ' getClipboard ' SET_CLIPBOARD = ' setClipboard ' FINGER_PRINT = ' fingerPrint ' GET_SETTINGS = ' getSettings ' UPDATE_SETTINGS = ' updateSettings ' START_RECORDING_SCREEN = ' startRecordingScreen ' STOP_RECORDING_SCREEN = ' stopRecordingScreen ' COMPARE_IMAGES = ' compareImages ' IS_KEYBOARD_SHOWN = ' isKeyboardShown ' EXECUTE_DRIVER = ' executeDriver ' # Android OPEN_NOTIFICATIONS = ' openNotifications ' START_ACTIVITY = ' startActivity ' GET_CURRENT_ACTIVITY = ' getCurrentActivity ' GET_CURRENT_PACKAGE = ' getCurrentPackage ' GET_SYSTEM_BARS = ' getSystemBars ' GET_DISPLAY_DENSITY = ' getDisplayDensity ' TOGGLE_WIFI = ' toggleWiFi ' TOGGLE_LOCATION_SERVICES = ' toggleLocationServices ' END_TEST_COVERAGE = ' endTestCoverage ' GET_PERFORMANCE_DATA_TYPES = ' getPerformanceDataTypes ' GET_PERFORMANCE_DATA = ' getPerformanceData ' GET_NETWORK_CONNECTION = ' getNetworkConnection ' SET_NETWORK_CONNECTION = ' setNetworkConnection ' # Android Emulator SEND_SMS = ' sendSms ' MAKE_GSM_CALL = ' makeGsmCall ' SET_GSM_SIGNAL = ' setGsmSignal ' SET_GSM_VOICE = ' setGsmVoice ' SET_NETWORK_SPEED = ' setNetworkSpeed ' SET_POWER_CAPACITY = ' setPowerCapacity ' SET_POWER_AC = ' setPowerAc ' # iOS TOUCH_ID = ' touchId ' TOGGLE_TOUCH_ID_ENROLLMENT = ' toggleTouchIdEnrollment ' Class variables ACTIVATE_APP ACTIVATE_IME_ENGINE BACKGROUND CLEAR CLOSE_APP COMPARE_IMAGES CONTEXTS DEACTIVATE_IME_ENGINE END_TEST_COVERAGE EXECUTE_DRIVER FINGER_PRINT GET_ACTIVE_IME_ENGINE GET_APP_STRINGS GET_AVAILABLE_IME_ENGINES GET_CLIPBOARD GET_CURRENT_ACTIVITY GET_CURRENT_CONTEXT GET_CURRENT_PACKAGE GET_DEVICE_TIME_GET GET_DEVICE_TIME_POST GET_DISPLAY_DENSITY GET_LOCATION GET_NETWORK_CONNECTION GET_PERFORMANCE_DATA GET_PERFORMANCE_DATA_TYPES GET_SESSION GET_SETTINGS GET_SYSTEM_BARS HIDE_KEYBOARD INSTALL_APP IS_APP_INSTALLED IS_IME_ACTIVE IS_KEYBOARD_SHOWN IS_LOCKED KEY_EVENT LAUNCH_APP LOCATION_IN_VIEW LOCK LONG_PRESS_KEYCODE MAKE_GSM_CALL MULTI_ACTION OPEN_NOTIFICATIONS PRESS_KEYCODE PULL_FILE PULL_FOLDER PUSH_FILE QUERY_APP_STATE REMOVE_APP REPLACE_KEYS RESET SEND_SMS SET_CLIPBOARD SET_GSM_SIGNAL SET_GSM_VOICE SET_IMMEDIATE_VALUE SET_LOCATION SET_NETWORK_CONNECTION SET_NETWORK_SPEED SET_POWER_AC SET_POWER_CAPACITY SHAKE START_ACTIVITY START_RECORDING_SCREEN STOP_RECORDING_SCREEN SWITCH_TO_CONTEXT TERMINATE_APP TOGGLE_LOCATION_SERVICES TOGGLE_TOUCH_ID_ENROLLMENT TOGGLE_WIFI TOUCH_ACTION TOUCH_ID UNLOCK UPDATE_SETTINGS","title":"Mobilecommand"},{"location":"reference/appium/webdriver/mobilecommand/#module-appiumwebdrivermobilecommand","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. class MobileCommand ( object ): # Common GET_SESSION = 'getSession' GET_LOCATION = 'getLocation' SET_LOCATION = 'setLocation' GET_AVAILABLE_IME_ENGINES = 'getAvailableIMEEngines' IS_IME_ACTIVE = 'isIMEActive' ACTIVATE_IME_ENGINE = 'activateIMEEngine' DEACTIVATE_IME_ENGINE = 'deactivateIMEEngine' GET_ACTIVE_IME_ENGINE = 'getActiveEngine' CLEAR = 'clear' LOCATION_IN_VIEW = 'locationInView' CONTEXTS = 'getContexts' GET_CURRENT_CONTEXT = 'getCurrentContext' SWITCH_TO_CONTEXT = 'switchToContext' TOUCH_ACTION = 'touchAction' MULTI_ACTION = 'multiAction' SET_IMMEDIATE_VALUE = 'setImmediateValue' REPLACE_KEYS = 'replaceKeys' LAUNCH_APP = 'launchApp' CLOSE_APP = 'closeApp' RESET = 'reset' BACKGROUND = 'background' GET_APP_STRINGS = 'getAppStrings' IS_LOCKED = 'isLocked' LOCK = 'lock' UNLOCK = 'unlock' GET_DEVICE_TIME_GET = 'getDeviceTimeGet' GET_DEVICE_TIME_POST = 'getDeviceTimePost' INSTALL_APP = 'installApp' REMOVE_APP = 'removeApp' IS_APP_INSTALLED = 'isAppInstalled' TERMINATE_APP = 'terminateApp' ACTIVATE_APP = 'activateApp' QUERY_APP_STATE = 'queryAppState' SHAKE = 'shake' HIDE_KEYBOARD = 'hideKeyboard' PRESS_KEYCODE = 'pressKeyCode' LONG_PRESS_KEYCODE = 'longPressKeyCode' KEY_EVENT = 'keyEvent' # Needed for Selendroid PUSH_FILE = 'pushFile' PULL_FILE = 'pullFile' PULL_FOLDER = 'pullFolder' GET_CLIPBOARD = 'getClipboard' SET_CLIPBOARD = 'setClipboard' FINGER_PRINT = 'fingerPrint' GET_SETTINGS = 'getSettings' UPDATE_SETTINGS = 'updateSettings' START_RECORDING_SCREEN = 'startRecordingScreen' STOP_RECORDING_SCREEN = 'stopRecordingScreen' COMPARE_IMAGES = 'compareImages' IS_KEYBOARD_SHOWN = 'isKeyboardShown' EXECUTE_DRIVER = 'executeDriver' # Android OPEN_NOTIFICATIONS = 'openNotifications' START_ACTIVITY = 'startActivity' GET_CURRENT_ACTIVITY = 'getCurrentActivity' GET_CURRENT_PACKAGE = 'getCurrentPackage' GET_SYSTEM_BARS = 'getSystemBars' GET_DISPLAY_DENSITY = 'getDisplayDensity' TOGGLE_WIFI = 'toggleWiFi' TOGGLE_LOCATION_SERVICES = 'toggleLocationServices' END_TEST_COVERAGE = 'endTestCoverage' GET_PERFORMANCE_DATA_TYPES = 'getPerformanceDataTypes' GET_PERFORMANCE_DATA = 'getPerformanceData' GET_NETWORK_CONNECTION = 'getNetworkConnection' SET_NETWORK_CONNECTION = 'setNetworkConnection' # Android Emulator SEND_SMS = 'sendSms' MAKE_GSM_CALL = 'makeGsmCall' SET_GSM_SIGNAL = 'setGsmSignal' SET_GSM_VOICE = 'setGsmVoice' SET_NETWORK_SPEED = 'setNetworkSpeed' SET_POWER_CAPACITY = 'setPowerCapacity' SET_POWER_AC = 'setPowerAc' # iOS TOUCH_ID = 'touchId' TOGGLE_TOUCH_ID_ENROLLMENT = 'toggleTouchIdEnrollment'","title":"Module appium.webdriver.mobilecommand"},{"location":"reference/appium/webdriver/mobilecommand/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/mobilecommand/#mobilecommand","text":"class MobileCommand ( / , * args , ** kwargs ) View Source class MobileCommand ( object ) : # Common GET_SESSION = ' getSession ' GET_LOCATION = ' getLocation ' SET_LOCATION = ' setLocation ' GET_AVAILABLE_IME_ENGINES = ' getAvailableIMEEngines ' IS_IME_ACTIVE = ' isIMEActive ' ACTIVATE_IME_ENGINE = ' activateIMEEngine ' DEACTIVATE_IME_ENGINE = ' deactivateIMEEngine ' GET_ACTIVE_IME_ENGINE = ' getActiveEngine ' CLEAR = ' clear ' LOCATION_IN_VIEW = ' locationInView ' CONTEXTS = ' getContexts ' GET_CURRENT_CONTEXT = ' getCurrentContext ' SWITCH_TO_CONTEXT = ' switchToContext ' TOUCH_ACTION = ' touchAction ' MULTI_ACTION = ' multiAction ' SET_IMMEDIATE_VALUE = ' setImmediateValue ' REPLACE_KEYS = ' replaceKeys ' LAUNCH_APP = ' launchApp ' CLOSE_APP = ' closeApp ' RESET = ' reset ' BACKGROUND = ' background ' GET_APP_STRINGS = ' getAppStrings ' IS_LOCKED = ' isLocked ' LOCK = ' lock ' UNLOCK = ' unlock ' GET_DEVICE_TIME_GET = ' getDeviceTimeGet ' GET_DEVICE_TIME_POST = ' getDeviceTimePost ' INSTALL_APP = ' installApp ' REMOVE_APP = ' removeApp ' IS_APP_INSTALLED = ' isAppInstalled ' TERMINATE_APP = ' terminateApp ' ACTIVATE_APP = ' activateApp ' QUERY_APP_STATE = ' queryAppState ' SHAKE = ' shake ' HIDE_KEYBOARD = ' hideKeyboard ' PRESS_KEYCODE = ' pressKeyCode ' LONG_PRESS_KEYCODE = ' longPressKeyCode ' KEY_EVENT = ' keyEvent ' # Needed for Selendroid PUSH_FILE = ' pushFile ' PULL_FILE = ' pullFile ' PULL_FOLDER = ' pullFolder ' GET_CLIPBOARD = ' getClipboard ' SET_CLIPBOARD = ' setClipboard ' FINGER_PRINT = ' fingerPrint ' GET_SETTINGS = ' getSettings ' UPDATE_SETTINGS = ' updateSettings ' START_RECORDING_SCREEN = ' startRecordingScreen ' STOP_RECORDING_SCREEN = ' stopRecordingScreen ' COMPARE_IMAGES = ' compareImages ' IS_KEYBOARD_SHOWN = ' isKeyboardShown ' EXECUTE_DRIVER = ' executeDriver ' # Android OPEN_NOTIFICATIONS = ' openNotifications ' START_ACTIVITY = ' startActivity ' GET_CURRENT_ACTIVITY = ' getCurrentActivity ' GET_CURRENT_PACKAGE = ' getCurrentPackage ' GET_SYSTEM_BARS = ' getSystemBars ' GET_DISPLAY_DENSITY = ' getDisplayDensity ' TOGGLE_WIFI = ' toggleWiFi ' TOGGLE_LOCATION_SERVICES = ' toggleLocationServices ' END_TEST_COVERAGE = ' endTestCoverage ' GET_PERFORMANCE_DATA_TYPES = ' getPerformanceDataTypes ' GET_PERFORMANCE_DATA = ' getPerformanceData ' GET_NETWORK_CONNECTION = ' getNetworkConnection ' SET_NETWORK_CONNECTION = ' setNetworkConnection ' # Android Emulator SEND_SMS = ' sendSms ' MAKE_GSM_CALL = ' makeGsmCall ' SET_GSM_SIGNAL = ' setGsmSignal ' SET_GSM_VOICE = ' setGsmVoice ' SET_NETWORK_SPEED = ' setNetworkSpeed ' SET_POWER_CAPACITY = ' setPowerCapacity ' SET_POWER_AC = ' setPowerAc ' # iOS TOUCH_ID = ' touchId ' TOGGLE_TOUCH_ID_ENROLLMENT = ' toggleTouchIdEnrollment '","title":"MobileCommand"},{"location":"reference/appium/webdriver/mobilecommand/#class-variables","text":"ACTIVATE_APP ACTIVATE_IME_ENGINE BACKGROUND CLEAR CLOSE_APP COMPARE_IMAGES CONTEXTS DEACTIVATE_IME_ENGINE END_TEST_COVERAGE EXECUTE_DRIVER FINGER_PRINT GET_ACTIVE_IME_ENGINE GET_APP_STRINGS GET_AVAILABLE_IME_ENGINES GET_CLIPBOARD GET_CURRENT_ACTIVITY GET_CURRENT_CONTEXT GET_CURRENT_PACKAGE GET_DEVICE_TIME_GET GET_DEVICE_TIME_POST GET_DISPLAY_DENSITY GET_LOCATION GET_NETWORK_CONNECTION GET_PERFORMANCE_DATA GET_PERFORMANCE_DATA_TYPES GET_SESSION GET_SETTINGS GET_SYSTEM_BARS HIDE_KEYBOARD INSTALL_APP IS_APP_INSTALLED IS_IME_ACTIVE IS_KEYBOARD_SHOWN IS_LOCKED KEY_EVENT LAUNCH_APP LOCATION_IN_VIEW LOCK LONG_PRESS_KEYCODE MAKE_GSM_CALL MULTI_ACTION OPEN_NOTIFICATIONS PRESS_KEYCODE PULL_FILE PULL_FOLDER PUSH_FILE QUERY_APP_STATE REMOVE_APP REPLACE_KEYS RESET SEND_SMS SET_CLIPBOARD SET_GSM_SIGNAL SET_GSM_VOICE SET_IMMEDIATE_VALUE SET_LOCATION SET_NETWORK_CONNECTION SET_NETWORK_SPEED SET_POWER_AC SET_POWER_CAPACITY SHAKE START_ACTIVITY START_RECORDING_SCREEN STOP_RECORDING_SCREEN SWITCH_TO_CONTEXT TERMINATE_APP TOGGLE_LOCATION_SERVICES TOGGLE_TOUCH_ID_ENROLLMENT TOGGLE_WIFI TOUCH_ACTION TOUCH_ID UNLOCK UPDATE_SETTINGS","title":"Class variables"},{"location":"reference/appium/webdriver/switch_to/","text":"Module appium.webdriver.switch_to View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium.webdriver.remote.switch_to import SwitchTo from .mobilecommand import MobileCommand class MobileSwitchTo ( SwitchTo ): def context ( self , context_name ): \"\"\"Sets the context for the current session. Args: context_name (str): The name of the context to switch to. Usage: driver.switch_to.context('WEBVIEW_1') \"\"\" self . _driver . execute ( MobileCommand . SWITCH_TO_CONTEXT , { 'name' : context_name }) Classes MobileSwitchTo class MobileSwitchTo ( driver ) View Source class MobileSwitchTo ( SwitchTo ) : def context ( self , context_name ) : \"\"\" Sets the context for the current session. Args : context_name ( str ) : The name of the context to switch to . Usage : driver . switch_to . context ( ' WEBVIEW_1 ' ) \"\"\" self . _driver . execute ( MobileCommand . SWITCH_TO_CONTEXT , { ' name ' : context_name } ) Ancestors (in MRO) selenium.webdriver.remote.switch_to.SwitchTo Instance variables active_element Returns the element with focus, or BODY if nothing has focus. :Usage: element = driver.switch_to.active_element alert Switches focus to an alert on the page. :Usage: alert = driver.switch_to.alert Methods context def context ( self , context_name ) Sets the context for the current session. Args: context_name (str): The name of the context to switch to. Usage: driver.switch_to.context('WEBVIEW_1') View Source def context ( self , context_name ) : \"\"\" Sets the context for the current session. Args : context_name ( str ) : The name of the context to switch to . Usage : driver . switch_to . context ( ' WEBVIEW_1 ' ) \"\"\" self . _driver . execute ( MobileCommand . SWITCH_TO_CONTEXT , { ' name ' : context_name } ) default_content def default_content ( self ) Switch focus to the default frame. :Usage: driver.switch_to.default_content() View Source def default_content ( self ): \"\"\" Switch focus to the default frame. :Usage: driver.switch_to.default_content() \"\"\" self . _driver . execute ( Command . SWITCH_TO_FRAME , { 'id' : None } ) frame def frame ( self , frame_reference ) Switches focus to the specified frame, by index, name, or webelement. :Args: - frame_reference: The name of the window to switch to, an integer representing the index, or a webelement that is an (i)frame to switch to. :Usage: driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) View Source def frame ( self , frame_reference ) : \"\"\" Switches focus to the specified frame , by index , name , or webelement . : Args : - frame_reference : The name of the window to switch to , an integer representing the index , or a webelement that is an ( i ) frame to switch to . : Usage : driver . switch_to . frame ( ' frame_name ' ) driver . switch_to . frame ( 1 ) driver . switch_to . frame ( driver . find_elements_by_tag_name ( \" iframe \" ) [ 0 ] ) \"\"\" if isinstance ( frame_reference , basestring ) and self . _driver . w3c : try : frame_reference = self . _driver . find_element ( By . ID , frame_reference ) except NoSuchElementException : try : frame_reference = self . _driver . find_element ( By . NAME , frame_reference ) except NoSuchElementException : raise NoSuchFrameException ( frame_reference ) self . _driver . execute ( Command . SWITCH_TO_FRAME , { ' id ' : frame_reference } ) parent_frame def parent_frame ( self ) Switches focus to the parent context. If the current context is the top level browsing context, the context remains unchanged. :Usage: driver.switch_to.parent_frame() View Source def parent_frame ( self ) : \"\"\" Switches focus to the parent context . If the current context is the top level browsing context , the context remains unchanged . : Usage : driver . switch_to . parent_frame () \"\"\" self . _driver . execute ( Command . SWITCH_TO_PARENT_FRAME ) window def window ( self , window_name ) Switches focus to the specified window. :Args: - window_name: The name or window handle of the window to switch to. :Usage: driver.switch_to.window('main') View Source def window ( self , window_name ) : \"\"\" Switches focus to the specified window . : Args : - window_name : The name or window handle of the window to switch to . : Usage : driver . switch_to . window ( ' main ' ) \"\"\" if self . _driver . w3c : self . _w3c_window ( window_name ) return data = { ' name ' : window_name } self . _driver . execute ( Command . SWITCH_TO_WINDOW , data )","title":"Switch To"},{"location":"reference/appium/webdriver/switch_to/#module-appiumwebdriverswitch_to","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium.webdriver.remote.switch_to import SwitchTo from .mobilecommand import MobileCommand class MobileSwitchTo ( SwitchTo ): def context ( self , context_name ): \"\"\"Sets the context for the current session. Args: context_name (str): The name of the context to switch to. Usage: driver.switch_to.context('WEBVIEW_1') \"\"\" self . _driver . execute ( MobileCommand . SWITCH_TO_CONTEXT , { 'name' : context_name })","title":"Module appium.webdriver.switch_to"},{"location":"reference/appium/webdriver/switch_to/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/switch_to/#mobileswitchto","text":"class MobileSwitchTo ( driver ) View Source class MobileSwitchTo ( SwitchTo ) : def context ( self , context_name ) : \"\"\" Sets the context for the current session. Args : context_name ( str ) : The name of the context to switch to . Usage : driver . switch_to . context ( ' WEBVIEW_1 ' ) \"\"\" self . _driver . execute ( MobileCommand . SWITCH_TO_CONTEXT , { ' name ' : context_name } )","title":"MobileSwitchTo"},{"location":"reference/appium/webdriver/switch_to/#ancestors-in-mro","text":"selenium.webdriver.remote.switch_to.SwitchTo","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/switch_to/#instance-variables","text":"active_element Returns the element with focus, or BODY if nothing has focus. :Usage: element = driver.switch_to.active_element alert Switches focus to an alert on the page. :Usage: alert = driver.switch_to.alert","title":"Instance variables"},{"location":"reference/appium/webdriver/switch_to/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/switch_to/#context","text":"def context ( self , context_name ) Sets the context for the current session. Args: context_name (str): The name of the context to switch to. Usage: driver.switch_to.context('WEBVIEW_1') View Source def context ( self , context_name ) : \"\"\" Sets the context for the current session. Args : context_name ( str ) : The name of the context to switch to . Usage : driver . switch_to . context ( ' WEBVIEW_1 ' ) \"\"\" self . _driver . execute ( MobileCommand . SWITCH_TO_CONTEXT , { ' name ' : context_name } )","title":"context"},{"location":"reference/appium/webdriver/switch_to/#default_content","text":"def default_content ( self ) Switch focus to the default frame. :Usage: driver.switch_to.default_content() View Source def default_content ( self ): \"\"\" Switch focus to the default frame. :Usage: driver.switch_to.default_content() \"\"\" self . _driver . execute ( Command . SWITCH_TO_FRAME , { 'id' : None } )","title":"default_content"},{"location":"reference/appium/webdriver/switch_to/#frame","text":"def frame ( self , frame_reference ) Switches focus to the specified frame, by index, name, or webelement. :Args: - frame_reference: The name of the window to switch to, an integer representing the index, or a webelement that is an (i)frame to switch to. :Usage: driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) View Source def frame ( self , frame_reference ) : \"\"\" Switches focus to the specified frame , by index , name , or webelement . : Args : - frame_reference : The name of the window to switch to , an integer representing the index , or a webelement that is an ( i ) frame to switch to . : Usage : driver . switch_to . frame ( ' frame_name ' ) driver . switch_to . frame ( 1 ) driver . switch_to . frame ( driver . find_elements_by_tag_name ( \" iframe \" ) [ 0 ] ) \"\"\" if isinstance ( frame_reference , basestring ) and self . _driver . w3c : try : frame_reference = self . _driver . find_element ( By . ID , frame_reference ) except NoSuchElementException : try : frame_reference = self . _driver . find_element ( By . NAME , frame_reference ) except NoSuchElementException : raise NoSuchFrameException ( frame_reference ) self . _driver . execute ( Command . SWITCH_TO_FRAME , { ' id ' : frame_reference } )","title":"frame"},{"location":"reference/appium/webdriver/switch_to/#parent_frame","text":"def parent_frame ( self ) Switches focus to the parent context. If the current context is the top level browsing context, the context remains unchanged. :Usage: driver.switch_to.parent_frame() View Source def parent_frame ( self ) : \"\"\" Switches focus to the parent context . If the current context is the top level browsing context , the context remains unchanged . : Usage : driver . switch_to . parent_frame () \"\"\" self . _driver . execute ( Command . SWITCH_TO_PARENT_FRAME )","title":"parent_frame"},{"location":"reference/appium/webdriver/switch_to/#window","text":"def window ( self , window_name ) Switches focus to the specified window. :Args: - window_name: The name or window handle of the window to switch to. :Usage: driver.switch_to.window('main') View Source def window ( self , window_name ) : \"\"\" Switches focus to the specified window . : Args : - window_name : The name or window handle of the window to switch to . : Usage : driver . switch_to . window ( ' main ' ) \"\"\" if self . _driver . w3c : self . _w3c_window ( window_name ) return data = { ' name ' : window_name } self . _driver . execute ( Command . SWITCH_TO_WINDOW , data )","title":"window"},{"location":"reference/appium/webdriver/webdriver/","text":"Module appium.webdriver.webdriver View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # pylint: disable=too-many-lines,too-many-public-methods,too-many-statements,no-self-use import base64 import copy from selenium.common.exceptions import InvalidArgumentException from selenium.webdriver.common.by import By from selenium.webdriver.remote.command import Command as RemoteCommand from selenium.webdriver.remote.remote_connection import RemoteConnection from appium.common.logger import logger from appium.webdriver.common.mobileby import MobileBy from .appium_connection import AppiumConnection from .errorhandler import MobileErrorHandler from .extensions.action_helpers import ActionHelpers from .extensions.android.activities import Activities from .extensions.android.display import Display from .extensions.android.gsm import Gsm from .extensions.android.network import Network from .extensions.android.performance import Performance from .extensions.android.power import Power from .extensions.android.sms import Sms from .extensions.android.system_bars import SystemBars from .extensions.applications import Applications from .extensions.clipboard import Clipboard from .extensions.context import Context from .extensions.device_time import DeviceTime from .extensions.execute_driver import ExecuteDriver from .extensions.hw_actions import HardwareActions from .extensions.images_comparison import ImagesComparison from .extensions.ime import IME from .extensions.keyboard import Keyboard from .extensions.location import Location from .extensions.remote_fs import RemoteFS from .extensions.screen_record import ScreenRecord from .extensions.search_context import AppiumSearchContext from .extensions.settings import Settings from .mobilecommand import MobileCommand as Command from .switch_to import MobileSwitchTo from .webelement import WebElement as MobileWebElement # From remote/webdriver.py _W3C_CAPABILITY_NAMES = frozenset ([ 'acceptInsecureCerts' , 'browserName' , 'browserVersion' , 'platformName' , 'pageLoadStrategy' , 'proxy' , 'setWindowRect' , 'timeouts' , 'unhandledPromptBehavior' , ]) # From remote/webdriver.py _OSS_W3C_CONVERSION = { 'acceptSslCerts' : 'acceptInsecureCerts' , 'version' : 'browserVersion' , 'platform' : 'platformName' } _EXTENSION_CAPABILITY = ':' _FORCE_MJSONWP = 'forceMjsonwp' # override # Add appium prefix for the non-W3C capabilities def _make_w3c_caps ( caps ): appium_prefix = 'appium:' caps = copy . deepcopy ( caps ) profile = caps . get ( 'firefox_profile' ) first_match = {} if caps . get ( 'proxy' ) and caps [ 'proxy' ] . get ( 'proxyType' ): caps [ 'proxy' ][ 'proxyType' ] = caps [ 'proxy' ][ 'proxyType' ] . lower () for k , v in caps . items (): if v and k in _OSS_W3C_CONVERSION : first_match [ _OSS_W3C_CONVERSION [ k ]] = v . lower () if k == 'platform' else v if k in _W3C_CAPABILITY_NAMES or _EXTENSION_CAPABILITY in k : first_match [ k ] = v else : if not k . startswith ( appium_prefix ): first_match [ appium_prefix + k ] = v if profile : moz_opts = first_match . get ( 'moz:firefoxOptions' , {}) # If it's already present, assume the caller did that intentionally. if 'profile' not in moz_opts : # Don't mutate the original capabilities. new_opts = copy . deepcopy ( moz_opts ) new_opts [ 'profile' ] = profile first_match [ 'moz:firefoxOptions' ] = new_opts return { 'firstMatch' : [ first_match ]} class WebDriver ( AppiumSearchContext , ActionHelpers , Activities , Applications , Clipboard , Context , DeviceTime , Display , ExecuteDriver , Gsm , HardwareActions , ImagesComparison , IME , Keyboard , Location , Network , Performance , Power , RemoteFS , ScreenRecord , Settings , Sms , SystemBars ): def __init__ ( self , command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = True , direct_connection = False ): super ( WebDriver , self ) . __init__ ( AppiumConnection ( command_executor , keep_alive = keep_alive ), desired_capabilities , browser_profile , proxy ) if hasattr ( self , 'command_executor' ): self . _addCommands () self . error_handler = MobileErrorHandler () self . _switch_to = MobileSwitchTo ( self ) if direct_connection : self . _update_command_executor ( keep_alive = keep_alive ) # add new method to the `find_by_*` pantheon By . IOS_UIAUTOMATION = MobileBy . IOS_UIAUTOMATION By . IOS_PREDICATE = MobileBy . IOS_PREDICATE By . IOS_CLASS_CHAIN = MobileBy . IOS_CLASS_CHAIN By . ANDROID_UIAUTOMATOR = MobileBy . ANDROID_UIAUTOMATOR By . ANDROID_VIEWTAG = MobileBy . ANDROID_VIEWTAG By . ACCESSIBILITY_ID = MobileBy . ACCESSIBILITY_ID By . IMAGE = MobileBy . IMAGE By . CUSTOM = MobileBy . CUSTOM def _update_command_executor ( self , keep_alive ): \"\"\"Update command executor following directConnect feature\"\"\" direct_protocol = 'directConnectProtocol' direct_host = 'directConnectHost' direct_port = 'directConnectPort' direct_path = 'directConnectPath' if ( not { direct_protocol , direct_host , direct_port , direct_path } . issubset ( set ( self . capabilities ))): message = 'Direct connect capabilities from server were: \\n ' for key in [ direct_protocol , direct_host , direct_port , direct_path ]: message += '{}: \\' {} \\'\\n ' . format ( key , self . capabilities . get ( key , '' )) logger . warning ( message ) return protocol = self . capabilities [ direct_protocol ] hostname = self . capabilities [ direct_host ] port = self . capabilities [ direct_port ] path = self . capabilities [ direct_path ] executor = '{scheme}://{hostname}:{port}{path}' . format ( scheme = protocol , hostname = hostname , port = port , path = path ) logger . info ( 'Updated request endpoint to %s ' , executor ) # Override command executor self . command_executor = RemoteConnection ( executor , keep_alive = keep_alive ) self . _addCommands () def start_session ( self , capabilities , browser_profile = None ): \"\"\"Creates a new session with the desired capabilities. Override for Appium Args: automation_name: The name of automation engine to use. platform_name: The name of target platform. platform_version: The kind of mobile device or emulator to use app: The absolute local path or remote http URL to an .ipa or .apk file, or a .zip containing one of these. Read https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/caps.md for more details. \"\"\" if not isinstance ( capabilities , dict ): raise InvalidArgumentException ( 'Capabilities must be a dictionary' ) if browser_profile : if 'moz:firefoxOptions' in capabilities : capabilities [ 'moz:firefoxOptions' ][ 'profile' ] = browser_profile . encoded else : capabilities . update ({ 'firefox_profile' : browser_profile . encoded }) parameters = self . _merge_capabilities ( capabilities ) response = self . execute ( RemoteCommand . NEW_SESSION , parameters ) if 'sessionId' not in response : response = response [ 'value' ] self . session_id = response [ 'sessionId' ] self . capabilities = response . get ( 'value' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( 'capabilities' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( 'status' ) is None self . command_executor . w3c = self . w3c def _merge_capabilities ( self , capabilities ): \"\"\"Manage capabilities whether W3C format or MJSONWP format \"\"\" if _FORCE_MJSONWP in capabilities : force_mjsonwp = capabilities [ _FORCE_MJSONWP ] del capabilities [ _FORCE_MJSONWP ] if force_mjsonwp != False : return { 'desiredCapabilities' : capabilities } w3c_caps = _make_w3c_caps ( capabilities ) return { 'capabilities' : w3c_caps , 'desiredCapabilities' : capabilities } def find_element ( self , by = By . ID , value = None ): \"\"\"'Private' method used by the find_element_by_* methods. Override for Appium Usage: Use the corresponding find_element_by_* instead of this. Returns: `appium.webdriver.webelement.WebElement` :rtype: `MobileWebElement` \"\"\" # TODO: If we need, we should enable below converter for Web context # if self.w3c: # if by == By.ID: # by = By.CSS_SELECTOR # value = '[id=\"%s\"]' % value # elif by == By.TAG_NAME: # by = By.CSS_SELECTOR # elif by == By.CLASS_NAME: # by = By.CSS_SELECTOR # value = \".%s\" % value # elif by == By.NAME: # by = By.CSS_SELECTOR # value = '[name=\"%s\"]' % value return self . execute ( RemoteCommand . FIND_ELEMENT , { 'using' : by , 'value' : value })[ 'value' ] def find_elements ( self , by = By . ID , value = None ): \"\"\"'Private' method used by the find_elements_by_* methods. Override for Appium Usage: Use the corresponding find_elements_by_* instead of this. Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` :rtype: list of `MobileWebElement` \"\"\" # TODO: If we need, we should enable below converter for Web context # if self.w3c: # if by == By.ID: # by = By.CSS_SELECTOR # value = '[id=\"%s\"]' % value # elif by == By.TAG_NAME: # by = By.CSS_SELECTOR # elif by == By.CLASS_NAME: # by = By.CSS_SELECTOR # value = \".%s\" % value # elif by == By.NAME: # by = By.CSS_SELECTOR # value = '[name=\"%s\"]' % value # Return empty list if driver returns null # See https://github.com/SeleniumHQ/selenium/issues/4555 return self . execute ( RemoteCommand . FIND_ELEMENTS , { 'using' : by , 'value' : value })[ 'value' ] or [] def find_element_by_ios_uiautomation ( self , uia_string ): \"\"\"Finds an element by uiautomation in iOS. Args: uia_string (str): The element name in the iOS UIAutomation library Usage: driver.find_element_by_ios_uiautomation('.elements()[1].cells()[2]') Returns: `appium.webdriver.webelement.WebElement` :rtype: `MobileWebElement` \"\"\" return self . find_element ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string ) def find_elements_by_ios_uiautomation ( self , uia_string ): \"\"\"Finds elements by uiautomation in iOS. Args: uia_string: The element name in the iOS UIAutomation library Usage: driver.find_elements_by_ios_uiautomation('.elements()[1].cells()[2]') Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` :rtype: list of `MobileWebElement` \"\"\" return self . find_elements ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string ) def find_element_by_ios_predicate ( self , predicate_string ): \"\"\"Find an element by ios predicate string. Args: predicate_string (str): The predicate string Usage: driver.find_element_by_ios_predicate('label == \"myLabel\"') Returns: `appium.webdriver.webelement.WebElement` :rtype: `MobileWebElement` \"\"\" return self . find_element ( by = MobileBy . IOS_PREDICATE , value = predicate_string ) def find_elements_by_ios_predicate ( self , predicate_string ): \"\"\"Finds elements by ios predicate string. Args: predicate_string (str): The predicate string Usage: driver.find_elements_by_ios_predicate('label == \"myLabel\"') Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` :rtype: list of `MobileWebElement` \"\"\" return self . find_elements ( by = MobileBy . IOS_PREDICATE , value = predicate_string ) def find_element_by_ios_class_chain ( self , class_chain_string ): \"\"\"Find an element by ios class chain string. Args: class_chain_string (str): The class chain string Usage: driver.find_element_by_ios_class_chain('XCUIElementTypeWindow/XCUIElementTypeButton[3]') Returns: `appium.webdriver.webelement.WebElement` :rtype: `MobileWebElement` \"\"\" return self . find_element ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string ) def find_elements_by_ios_class_chain ( self , class_chain_string ): \"\"\"Finds elements by ios class chain string. Args: class_chain_string (str): The class chain string Usage: driver.find_elements_by_ios_class_chain('XCUIElementTypeWindow[2]/XCUIElementTypeAny[-2]') Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` :rtype: list of `MobileWebElement` \"\"\" return self . find_elements ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string ) def find_element_by_android_uiautomator ( self , uia_string ): \"\"\"Finds element by uiautomator in Android. Args: uia_string: The element name in the Android UIAutomator library Usage: driver.find_element_by_android_uiautomator('.elements()[1].cells()[2]') Returns: `appium.webdriver.webelement.WebElement` :rtype: `MobileWebElement` \"\"\" return self . find_element ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string ) def find_elements_by_android_uiautomator ( self , uia_string ): \"\"\"Finds elements by uiautomator in Android. Args: uia_string (str): The element name in the Android UIAutomator library Usage: driver.find_elements_by_android_uiautomator('.elements()[1].cells()[2]') Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` :rtype: list of `MobileWebElement` \"\"\" return self . find_elements ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string ) def find_element_by_android_viewtag ( self , tag ): \"\"\"Finds element by [View#tags](https://developer.android.com/reference/android/view/View#tags) in Android. It works with [Espresso Driver](https://github.com/appium/appium-espresso-driver). Args: tag (str): The tag name of the view to look for Usage: driver.find_element_by_android_viewtag('a tag name') Returns: `appium.webdriver.webelement.WebElement` :rtype: `MobileWebElement` \"\"\" return self . find_element ( by = MobileBy . ANDROID_VIEWTAG , value = tag ) def find_elements_by_android_viewtag ( self , tag ): \"\"\"Finds element by [View#tags](https://developer.android.com/reference/android/view/View#tags) in Android. It works with [Espresso Driver](https://github.com/appium/appium-espresso-driver). Args: tag (str): The tag name of the view to look for Usage: driver.find_elements_by_android_viewtag('a tag name') Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` :rtype: list of `MobileWebElement` \"\"\" return self . find_elements ( by = MobileBy . ANDROID_VIEWTAG , value = tag ) def find_element_by_image ( self , img_path ): \"\"\"Finds a portion of a screenshot by an image. Uses driver.find_image_occurrence under the hood. Args: img_path (str): a string corresponding to the path of a image Returns: `appium.webdriver.webelement.WebElement` :rtype: `MobileWebElement` \"\"\" with open ( img_path , 'rb' ) as i_file : b64_data = base64 . b64encode ( i_file . read ()) . decode ( 'UTF-8' ) return self . find_element ( by = MobileBy . IMAGE , value = b64_data ) def find_elements_by_image ( self , img_path ): \"\"\"Finds a portion of a screenshot by an image. Uses driver.find_image_occurrence under the hood. Note that this will only ever return at most one element Args: img_path (str): a string corresponding to the path of a image Return: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` :rtype: list of `MobileWebElement` \"\"\" with open ( img_path , 'rb' ) as i_file : b64_data = base64 . b64encode ( i_file . read ()) . decode ( 'UTF-8' ) return self . find_elements ( by = MobileBy . IMAGE , value = b64_data ) def find_element_by_accessibility_id ( self , accessibility_id ): \"\"\"Finds an element by accessibility id. Args: accessibility_id (str): A string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize Usage: driver.find_element_by_accessibility_id() Returns: `appium.webdriver.webelement.WebElement` :rtype: `MobileWebElement` \"\"\" return self . find_element ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id ) def find_elements_by_accessibility_id ( self , accessibility_id ): \"\"\"Finds elements by accessibility id. Args: accessibility_id (str): a string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize Usage: driver.find_elements_by_accessibility_id() Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` :rtype: list of `MobileWebElement` \"\"\" return self . find_elements ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id ) def find_element_by_custom ( self , selector ): \"\"\"Finds an element in conjunction with a custom element finding plugin Args: selector (str): a string of the form \"module:selector\", where \"module\" is the shortcut name given in the customFindModules capability, and \"selector\" is the string that will be passed to the custom element finding plugin itself Usage: driver.find_element_by_custom(\"foo:bar\") Returns: `appium.webdriver.webelement.WebElement` :rtype: `MobileWebElement` \"\"\" return self . find_element ( by = MobileBy . CUSTOM , value = selector ) def find_elements_by_custom ( self , selector ): \"\"\"Finds elements in conjunction with a custom element finding plugin Args: selector: a string of the form \"module:selector\", where \"module\" is the shortcut name given in the customFindModules capability, and \"selector\" is the string that will be passed to the custom element finding plugin itself Usage: driver.find_elements_by_custom(\"foo:bar\") Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` :rtype: list of `MobileWebElement` \"\"\" return self . find_elements ( by = MobileBy . CUSTOM , value = selector ) def create_web_element ( self , element_id , w3c = False ): \"\"\"Creates a web element with the specified element_id. Overrides method in Selenium WebDriver in order to always give them Appium WebElement Args: element_id (int): The element id to create a web element w3c (bool): Whether the element is W3C or MJSONWP Returns: `MobileWebElement` \"\"\" return MobileWebElement ( self , element_id , w3c ) def press_button ( self , button_name ): \"\"\"Sends a physical button name to the device to simulate the user pressing. iOS only. Possible button names can be found in https://github.com/appium/WebDriverAgent/blob/master/WebDriverAgentLib/Categories/XCUIDevice%2BFBHelpers.h Args: button_name (str): the button name to be sent to the device Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'name' : button_name } self . execute_script ( 'mobile: pressButton' , data ) return self @property def current_package ( self ): \"\"\"Retrieves the current package running on the device. \"\"\" return self . execute ( Command . GET_CURRENT_PACKAGE )[ 'value' ] def set_value ( self , element , value ): \"\"\"Set the value on an element in the application. Args: element (`appium.webdriver.webelement.WebElement`: the element whose value will be set value (str): the value to set on the element Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'id' : element . id , 'value' : [ value ], } self . execute ( Command . SET_IMMEDIATE_VALUE , data ) return self def end_test_coverage ( self , intent , path ): \"\"\"Ends the coverage collection and pull the coverage.ec file from the device. Android only. See https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/android/android-coverage.md Args: intent (str): description of operation to be performed path (str): path to coverage.ec file to be pulled from the device Returns: TODO \"\"\" data = { 'intent' : intent , 'path' : path , } return self . execute ( Command . END_TEST_COVERAGE , data )[ 'value' ] def open_notifications ( self ): \"\"\"Open notification shade in Android (API Level 18 and above) Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . OPEN_NOTIFICATIONS , {}) return self @property def battery_info ( self ): \"\"\"Retrieves battery information for the device under test. Returns: A dictionary containing the following entries level: Battery level in range [0.0, 1.0], where 1.0 means 100% charge. Any value lower than 0 means the level cannot be retrieved state: Platform-dependent battery state value. On iOS (XCUITest): 1: Unplugged 2: Charging 3: Full Any other value means the state cannot be retrieved On Android (UIAutomator2): 2: Charging 3: Discharging 4: Not charging 5: Full Any other value means the state cannot be retrieved \"\"\" return self . execute_script ( 'mobile: batteryInfo' ) @property def session ( self ): \"\"\" Retrieves session information from the current session Usage: session = driver.session Returns: `dict containing information from the current session` \"\"\" return self . execute ( Command . GET_SESSION )[ 'value' ] @property def events ( self ): \"\"\" Retrieves events information from the current session Usage: events = driver.events Returns: `dict containing events timing information from the current session` \"\"\" try : session = self . session return session [ 'events' ] except Exception as e : logger . warning ( 'Could not find events information in the session. Error:' , e ) return {} # pylint: disable=protected-access def _addCommands ( self ): # call the overridden command binders from all mixin classes except for # appium.webdriver.webdriver.WebDriver and its sub-classes # https://github.com/appium/python-client/issues/342 for mixin_class in filter ( lambda x : not issubclass ( x , WebDriver ), self . __class__ . __mro__ ): if hasattr ( mixin_class , self . _addCommands . __name__ ): getattr ( mixin_class , self . _addCommands . __name__ , None )( self ) self . command_executor . _commands [ Command . GET_SESSION ] = \\ ( 'GET' , '/session/$sessionId' ) self . command_executor . _commands [ Command . TOUCH_ACTION ] = \\ ( 'POST' , '/session/$sessionId/touch/perform' ) self . command_executor . _commands [ Command . MULTI_ACTION ] = \\ ( 'POST' , '/session/$sessionId/touch/multi/perform' ) self . command_executor . _commands [ Command . GET_CURRENT_PACKAGE ] = \\ ( 'GET' , '/session/$sessionId/appium/device/current_package' ) self . command_executor . _commands [ Command . SET_IMMEDIATE_VALUE ] = \\ ( 'POST' , '/session/$sessionId/appium/element/$id/value' ) self . command_executor . _commands [ Command . LAUNCH_APP ] = \\ ( 'POST' , '/session/$sessionId/appium/app/launch' ) self . command_executor . _commands [ Command . CLOSE_APP ] = \\ ( 'POST' , '/session/$sessionId/appium/app/close' ) self . command_executor . _commands [ Command . END_TEST_COVERAGE ] = \\ ( 'POST' , '/session/$sessionId/appium/app/end_test_coverage' ) self . command_executor . _commands [ Command . OPEN_NOTIFICATIONS ] = \\ ( 'POST' , '/session/$sessionId/appium/device/open_notifications' ) self . command_executor . _commands [ Command . REPLACE_KEYS ] = \\ ( 'POST' , '/session/$sessionId/appium/element/$id/replace_value' ) self . command_executor . _commands [ Command . LOCATION_IN_VIEW ] = \\ ( 'GET' , '/session/$sessionId/element/$id/location_in_view' ) self . command_executor . _commands [ Command . CLEAR ] = \\ ( 'POST' , '/session/$sessionId/element/$id/clear' ) Classes WebDriver class WebDriver ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = True , direct_connection = False ) Returns appium driver search conext View Source class WebDriver ( AppiumSearchContext , ActionHelpers , Activities , Applications , Clipboard , Context , DeviceTime , Display , ExecuteDriver , Gsm , HardwareActions , ImagesComparison , IME , Keyboard , Location , Network , Performance , Power , RemoteFS , ScreenRecord , Settings , Sms , SystemBars ) : def __init__ ( self , command_executor = ' http : //127.0.0.1:4444/wd/hub', desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = True , direct_connection = False ) : super ( WebDriver , self ). __init__ ( AppiumConnection ( command_executor , keep_alive = keep_alive ), desired_capabilities , browser_profile , proxy ) if hasattr ( self , ' command_executor ' ) : self . _addCommands () self . error_handler = MobileErrorHandler () self . _switch_to = MobileSwitchTo ( self ) if direct_connection : self . _update_command_executor ( keep_alive = keep_alive ) # add new method to the `find_by_*` pantheon By . IOS_UIAUTOMATION = MobileBy . IOS_UIAUTOMATION By . IOS_PREDICATE = MobileBy . IOS_PREDICATE By . IOS_CLASS_CHAIN = MobileBy . IOS_CLASS_CHAIN By . ANDROID_UIAUTOMATOR = MobileBy . ANDROID_UIAUTOMATOR By . ANDROID_VIEWTAG = MobileBy . ANDROID_VIEWTAG By . ACCESSIBILITY_ID = MobileBy . ACCESSIBILITY_ID By . IMAGE = MobileBy . IMAGE By . CUSTOM = MobileBy . CUSTOM def _update_command_executor ( self , keep_alive ) : \"\"\"Update command executor following directConnect feature\"\"\" direct_protocol = ' directConnectProtocol ' direct_host = ' directConnectHost ' direct_port = ' directConnectPort ' direct_path = ' directConnectPath ' if ( not { direct_protocol , direct_host , direct_port , direct_path }. issubset ( set ( self . capabilities ))) : message = ' Direct connect capabilities from server were : \\ n ' for key in [ direct_protocol , direct_host , direct_port , direct_path ] : message += ' {} : \\' {} \\ '\\n' . format ( key , self . capabilities . get ( key , '' )) logger . warning ( message ) return protocol = self . capabilities [ direct_protocol ] hostname = self . capabilities [ direct_host ] port = self . capabilities [ direct_port ] path = self . capabilities [ direct_path ] executor = ' { scheme } : //{hostname}:{port}{path}'.format( scheme = protocol , hostname = hostname , port = port , path = path ) logger . info ( ' Updated request endpoint to % s ' , executor ) # Override command executor self . command_executor = RemoteConnection ( executor , keep_alive = keep_alive ) self . _addCommands () def start_session ( self , capabilities , browser_profile = None ) : \"\"\"Creates a new session with the desired capabilities. Override for Appium Args : automation_name : The name of automation engine to use . platform_name : The name of target platform . platform_version : The kind of mobile device or emulator to use app : The absolute local path or remote http URL to an . ipa or . apk file , or a . zip containing one of these . Read https : //github.com/appium/appium/blob/master/docs/en/writing-running-appium/caps.md for more details. \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( ' Capabilities must be a dictionary ' ) if browser_profile : if ' moz : firefoxOptions ' in capabilities : capabilities [ ' moz : firefoxOptions ' ][ ' profile ' ] = browser_profile . encoded else : capabilities . update ({ ' firefox_profile ' : browser_profile . encoded }) parameters = self . _merge_capabilities ( capabilities ) response = self . execute ( RemoteCommand . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c def _merge_capabilities ( self , capabilities ) : \"\"\"Manage capabilities whether W3C format or MJSONWP format \"\"\" if _FORCE_MJSONWP in capabilities : force_mjsonwp = capabilities [ _FORCE_MJSONWP ] del capabilities [ _FORCE_MJSONWP ] if force_mjsonwp != False : return { ' desiredCapabilities ' : capabilities } w3c_caps = _make_w3c_caps ( capabilities ) return { ' capabilities ' : w3c_caps , ' desiredCapabilities ' : capabilities } def find_element ( self , by = By . ID , value = None ) : \"\"\"'Private' method used by the find_element_by_* methods. Override for Appium Usage : Use the corresponding find_element_by_ * instead of this . Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" # TODO: If we need, we should enable below converter for Web context # if self.w3c: # if by == By.ID: # by = By.CSS_SELECTOR # value = '[id=\"%s\"]' % value # elif by == By.TAG_NAME: # by = By.CSS_SELECTOR # elif by == By.CLASS_NAME: # by = By.CSS_SELECTOR # value = \".%s\" % value # elif by == By.NAME: # by = By.CSS_SELECTOR # value = '[name=\"%s\"]' % value return self . execute ( RemoteCommand . FIND_ELEMENT , { ' using ' : by , ' value ' : value })[ ' value ' ] def find_elements ( self , by = By . ID , value = None ) : \"\"\"'Private' method used by the find_elements_by_* methods. Override for Appium Usage : Use the corresponding find_elements_by_ * instead of this . Returns : : obj : ` list ` of : obj : ` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" # TODO: If we need, we should enable below converter for Web context # if self.w3c: # if by == By.ID: # by = By.CSS_SELECTOR # value = '[id=\"%s\"]' % value # elif by == By.TAG_NAME: # by = By.CSS_SELECTOR # elif by == By.CLASS_NAME: # by = By.CSS_SELECTOR # value = \".%s\" % value # elif by == By.NAME: # by = By.CSS_SELECTOR # value = '[name=\"%s\"]' % value # Return empty list if driver returns null # See https: //github.com/SeleniumHQ/selenium/issues/4555 return self . execute ( RemoteCommand . FIND_ELEMENTS , { ' using ' : by , ' value ' : value })[ ' value ' ] or [] def find_element_by_ios_uiautomation ( self , uia_string ) : \"\"\"Finds an element by uiautomation in iOS. Args : uia_string ( str ) : The element name in the iOS UIAutomation library Usage : driver . find_element_by_ios_uiautomation ( ' . elements ()[ 1 ]. cells ()[ 2 ] ' ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string ) def find_elements_by_ios_uiautomation ( self , uia_string ) : \"\"\"Finds elements by uiautomation in iOS. Args : uia_string : The element name in the iOS UIAutomation library Usage : driver . find_elements_by_ios_uiautomation ( ' . elements ()[ 1 ]. cells ()[ 2 ] ' ) Returns : : obj : ` list ` of : obj : ` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string ) def find_element_by_ios_predicate ( self , predicate_string ) : \"\"\"Find an element by ios predicate string. Args : predicate_string ( str ) : The predicate string Usage : driver . find_element_by_ios_predicate ( ' label == \"myLabel\" ' ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_PREDICATE , value = predicate_string ) def find_elements_by_ios_predicate ( self , predicate_string ) : \"\"\"Finds elements by ios predicate string. Args : predicate_string ( str ) : The predicate string Usage : driver . find_elements_by_ios_predicate ( ' label == \"myLabel\" ' ) Returns : : obj : ` list ` of : obj : ` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_PREDICATE , value = predicate_string ) def find_element_by_ios_class_chain ( self , class_chain_string ) : \"\"\"Find an element by ios class chain string. Args : class_chain_string ( str ) : The class chain string Usage : driver . find_element_by_ios_class_chain ( ' XCUIElementTypeWindow / XCUIElementTypeButton [ 3 ] ' ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string ) def find_elements_by_ios_class_chain ( self , class_chain_string ) : \"\"\"Finds elements by ios class chain string. Args : class_chain_string ( str ) : The class chain string Usage : driver . find_elements_by_ios_class_chain ( ' XCUIElementTypeWindow [ 2 ] / XCUIElementTypeAny [ - 2 ] ' ) Returns : : obj : ` list ` of : obj : ` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string ) def find_element_by_android_uiautomator ( self , uia_string ) : \"\"\"Finds element by uiautomator in Android. Args : uia_string : The element name in the Android UIAutomator library Usage : driver . find_element_by_android_uiautomator ( ' . elements ()[ 1 ]. cells ()[ 2 ] ' ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string ) def find_elements_by_android_uiautomator ( self , uia_string ) : \"\"\"Finds elements by uiautomator in Android. Args : uia_string ( str ) : The element name in the Android UIAutomator library Usage : driver . find_elements_by_android_uiautomator ( ' . elements ()[ 1 ]. cells ()[ 2 ] ' ) Returns : : obj : ` list ` of : obj : ` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string ) def find_element_by_android_viewtag ( self , tag ) : \"\"\"Finds element by [View#tags](https://developer.android.com/reference/android/view/View#tags) in Android. It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : tag ( str ) : The tag name of the view to look for Usage : driver . find_element_by_android_viewtag ( ' a tag name ' ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . ANDROID_VIEWTAG , value = tag ) def find_elements_by_android_viewtag ( self , tag ) : \"\"\"Finds element by [View#tags](https://developer.android.com/reference/android/view/View#tags) in Android. It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : tag ( str ) : The tag name of the view to look for Usage : driver . find_elements_by_android_viewtag ( ' a tag name ' ) Returns : : obj : ` list ` of : obj : ` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . ANDROID_VIEWTAG , value = tag ) def find_element_by_image ( self , img_path ) : \"\"\"Finds a portion of a screenshot by an image. Uses driver . find_image_occurrence under the hood . Args : img_path ( str ) : a string corresponding to the path of a image Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" with open ( img_path , ' rb ' ) as i_file : b64_data = base64 . b64encode ( i_file . read ()). decode ( ' UTF - 8 ' ) return self . find_element ( by = MobileBy . IMAGE , value = b64_data ) def find_elements_by_image ( self , img_path ) : \"\"\"Finds a portion of a screenshot by an image. Uses driver . find_image_occurrence under the hood . Note that this will only ever return at most one element Args : img_path ( str ) : a string corresponding to the path of a image Return : : obj : ` list ` of : obj : ` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" with open ( img_path , ' rb ' ) as i_file : b64_data = base64 . b64encode ( i_file . read ()). decode ( ' UTF - 8 ' ) return self . find_elements ( by = MobileBy . IMAGE , value = b64_data ) def find_element_by_accessibility_id ( self , accessibility_id ) : \"\"\"Finds an element by accessibility id. Args : accessibility_id ( str ) : A string corresponding to a recursive element search using the Id / Name that the native Accessibility options utilize Usage : driver . find_element_by_accessibility_id () Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id ) def find_elements_by_accessibility_id ( self , accessibility_id ) : \"\"\"Finds elements by accessibility id. Args : accessibility_id ( str ) : a string corresponding to a recursive element search using the Id / Name that the native Accessibility options utilize Usage : driver . find_elements_by_accessibility_id () Returns : : obj : ` list ` of : obj : ` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id ) def find_element_by_custom ( self , selector ) : \"\"\"Finds an element in conjunction with a custom element finding plugin Args : selector ( str ) : a string of the form \"module:selector\" , where \"module\" is the shortcut name given in the customFindModules capability , and \"selector\" is the string that will be passed to the custom element finding plugin itself Usage : driver . find_element_by_custom ( \"foo:bar\" ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . CUSTOM , value = selector ) def find_elements_by_custom ( self , selector ) : \"\"\"Finds elements in conjunction with a custom element finding plugin Args : selector : a string of the form \"module:selector\" , where \"module\" is the shortcut name given in the customFindModules capability , and \"selector\" is the string that will be passed to the custom element finding plugin itself Usage : driver . find_elements_by_custom ( \"foo:bar\" ) Returns : : obj : ` list ` of : obj : ` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . CUSTOM , value = selector ) def create_web_element ( self , element_id , w3c = False ) : \"\"\"Creates a web element with the specified element_id. Overrides method in Selenium WebDriver in order to always give them Appium WebElement Args : element_id ( int ) : The element id to create a web element w3c ( bool ) : Whether the element is W3C or MJSONWP Returns : ` MobileWebElement ` \"\"\" return MobileWebElement ( self , element_id , w3c ) def press_button ( self , button_name ) : \"\"\"Sends a physical button name to the device to simulate the user pressing. iOS only . Possible button names can be found in https : //github.com/appium/WebDriverAgent/blob/master/WebDriverAgentLib/Categories/XCUIDevice%2BFBHelpers.h Args : button_name ( str ) : the button name to be sent to the device Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' name ' : button_name } self . execute_script ( ' mobile : pressButton ' , data ) return self @property def current_package ( self ) : \"\"\"Retrieves the current package running on the device. \"\"\" return self . execute ( Command . GET_CURRENT_PACKAGE )[ ' value ' ] def set_value ( self , element , value ) : \"\"\"Set the value on an element in the application. Args : element ( ` appium . webdriver . webelement . WebElement ` : the element whose value will be set value ( str ) : the value to set on the element Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' id ' : element . id , ' value ' : [ value ], } self . execute ( Command . SET_IMMEDIATE_VALUE , data ) return self def end_test_coverage ( self , intent , path ) : \"\"\"Ends the coverage collection and pull the coverage.ec file from the device. Android only . See https : //github.com/appium/appium/blob/master/docs/en/writing-running-appium/android/android-coverage.md Args : intent ( str ) : description of operation to be performed path ( str ) : path to coverage . ec file to be pulled from the device Returns : TODO \"\"\" data = { ' intent ' : intent , ' path ' : path , } return self . execute ( Command . END_TEST_COVERAGE , data )[ ' value ' ] def open_notifications ( self ) : \"\"\"Open notification shade in Android (API Level 18 and above) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . OPEN_NOTIFICATIONS , {}) return self @property def battery_info ( self ) : \"\"\"Retrieves battery information for the device under test. Returns : A dictionary containing the following entries level : Battery level in range [ 0.0 , 1.0 ], where 1.0 means 100 % charge . Any value lower than 0 means the level cannot be retrieved state : Platform - dependent battery state value . On iOS ( XCUITest ) : 1 : Unplugged 2 : Charging 3 : Full Any other value means the state cannot be retrieved On Android ( UIAutomator2 ) : 2 : Charging 3 : Discharging 4 : Not charging 5 : Full Any other value means the state cannot be retrieved \"\"\" return self . execute_script ( ' mobile : batteryInfo ' ) @property def session ( self ) : \"\"\" Retrieves session information from the current session Usage : session = driver . session Returns : ` dict containing information from the current session ` \"\"\" return self . execute ( Command . GET_SESSION )[ ' value ' ] @property def events ( self ) : \"\"\" Retrieves events information from the current session Usage : events = driver . events Returns : ` dict containing events timing information from the current session ` \"\"\" try : session = self . session return session [ ' events ' ] except Exception as e : logger . warning ( ' Could not find events information in the session . Error : ' , e ) return {} # pylint: disable=protected-access def _addCommands ( self ) : # call the overridden command binders from all mixin classes except for # appium.webdriver.webdriver.WebDriver and its sub-classes # https: //github.com/appium/python-client/issues/342 for mixin_class in filter ( lambda x : not issubclass ( x , WebDriver ), self . __class__ . __mro__ ) : if hasattr ( mixin_class , self . _addCommands . __name__ ) : getattr ( mixin_class , self . _addCommands . __name__ , None )( self ) self . command_executor . _commands [ Command . GET_SESSION ] = \\ ( ' GET ' , ' / session / $ sessionId ' ) self . command_executor . _commands [ Command . TOUCH_ACTION ] = \\ ( ' POST ' , ' / session / $ sessionId / touch / perform ' ) self . command_executor . _commands [ Command . MULTI_ACTION ] = \\ ( ' POST ' , ' / session / $ sessionId / touch / multi / perform ' ) self . command_executor . _commands [ Command . GET_CURRENT_PACKAGE ] = \\ ( ' GET ' , ' / session / $ sessionId / appium / device / current_package ' ) self . command_executor . _commands [ Command . SET_IMMEDIATE_VALUE ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / element / $ id / value ' ) self . command_executor . _commands [ Command . LAUNCH_APP ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / app / launch ' ) self . command_executor . _commands [ Command . CLOSE_APP ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / app / close ' ) self . command_executor . _commands [ Command . END_TEST_COVERAGE ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / app / end_test_coverage ' ) self . command_executor . _commands [ Command . OPEN_NOTIFICATIONS ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / device / open_notifications ' ) self . command_executor . _commands [ Command . REPLACE_KEYS ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / element / $ id / replace_value ' ) self . command_executor . _commands [ Command . LOCATION_IN_VIEW ] = \\ ( ' GET ' , ' / session / $ sessionId / element / $ id / location_in_view ' ) self . command_executor . _commands [ Command . CLEAR ] = \\ ( ' POST ' , ' / session / $ sessionId / element / $ id / clear ' ) Ancestors (in MRO) appium.webdriver.extensions.search_context.AppiumSearchContext appium.webdriver.extensions.action_helpers.ActionHelpers appium.webdriver.extensions.android.activities.Activities appium.webdriver.extensions.applications.Applications appium.webdriver.extensions.clipboard.Clipboard appium.webdriver.extensions.context.Context appium.webdriver.extensions.device_time.DeviceTime appium.webdriver.extensions.android.display.Display appium.webdriver.extensions.execute_driver.ExecuteDriver appium.webdriver.extensions.android.gsm.Gsm appium.webdriver.extensions.hw_actions.HardwareActions appium.webdriver.extensions.images_comparison.ImagesComparison appium.webdriver.extensions.ime.IME appium.webdriver.extensions.keyboard.Keyboard appium.webdriver.extensions.location.Location appium.webdriver.extensions.android.network.Network appium.webdriver.extensions.android.performance.Performance appium.webdriver.extensions.android.power.Power appium.webdriver.extensions.remote_fs.RemoteFS appium.webdriver.extensions.screen_record.ScreenRecord appium.webdriver.extensions.settings.Settings appium.webdriver.extensions.android.sms.Sms appium.webdriver.extensions.android.system_bars.SystemBars selenium.webdriver.remote.webdriver.WebDriver appium.webdriver.extensions.search_context.AndroidSearchContext appium.webdriver.extensions.search_context.BaseSearchContext Class variables AC_OFF AC_ON Instance variables active_ime_engine Returns the activity and package of the currently active IME engine(e.g., 'com.android.inputmethod.latin/.LatinIME'). Android only. Returns: str: The activity and package of the currently active IME engine application_cache Returns a ApplicationCache Object to interact with the browser app cache available_ime_engines Get the available input methods for an Android device. Package and activity are returned (e.g., ['com.android.inputmethod.latin/.LatinIME']) Android only. Returns: :obj: list of :obj: str : The available input methods for an Android device battery_info Retrieves battery information for the device under test. Returns: A dictionary containing the following entries level: Battery level in range [0.0, 1.0], where 1.0 means 100% charge. Any value lower than 0 means the level cannot be retrieved state: Platform-dependent battery state value. On iOS (XCUITest): 1: Unplugged 2: Charging 3: Full Any other value means the state cannot be retrieved On Android (UIAutomator2): 2: Charging 3: Discharging 4: Not charging 5: Full Any other value means the state cannot be retrieved context Returns the current context of the current session. Usage: driver.context Return: str: The context of the current session contexts Returns the contexts within the current session. Usage: driver.contexts Return: :obj: list of :obj: str : The contexts within the current session current_activity Retrieves the current activity running on the device. Returns: str: The current activity name running on the device current_context Returns the current context of the current session. Usage: driver.current_context Return: str: The context of the current session current_package Retrieves the current package running on the device. current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used device_time Returns the date and time from the device. Return: str: The date and time events Retrieves events information from the current session Usage: events = driver.events Returns: dict containing events timing information from the current session file_detector location Retrieves the current location Returns: A dictionary whose keys are - latitude (float) - longitude (float) - altitude (float) log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name network_connection Returns an integer bitmask specifying the network connection type. Android only. Possible values are available through the enumeration appium.webdriver.ConnectionType orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source session Retrieves session information from the current session Usage: session = driver.session Returns: dict containing information from the current session switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods activate_app def activate_app ( self , app_id ) Activates the application if it is not running or is running in the background. Args: app_id (str): the application id to be activated Returns: appium.webdriver.webdriver.WebDriver View Source def activate_app ( self , app_id ) : \"\"\" Activates the application if it is not running or is running in the background . Args : app_id ( str ) : the application id to be activated Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' appId ' : app_id , } self . execute ( Command . ACTIVATE_APP , data ) return self activate_ime_engine def activate_ime_engine ( self , engine ) Activates the given IME engine on the device. Android only. Args: engine (str): the package and activity of the IME engine to activate (e.g., 'com.android.inputmethod.latin/.LatinIME') Returns: appium.webdriver.webdriver.WebDriver View Source def activate_ime_engine ( self , engine ) : \"\"\" Activates the given IME engine on the device. Android only . Args : engine ( str ) : the package and activity of the IME engine to activate ( e . g ., ' com.android.inputmethod.latin/.LatinIME ' ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' engine ' : engine } self . execute ( Command . ACTIVATE_IME_ENGINE , data ) return self add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) app_strings def app_strings ( self , language = None , string_file = None ) Returns the application strings from the device for the specified language. Args: language (str): strings language code string_file (str): the name of the string file to query View Source def app_strings ( self , language = None , string_file = None ) : \"\"\" Returns the application strings from the device for the specified language . Args : language ( str ) : strings language code string_file ( str ) : the name of the string file to query \"\"\" data = {} if language is not None : data [ ' language ' ] = language if string_file is not None : data [ ' stringFile ' ] = string_file return self . execute ( Command . GET_APP_STRINGS , data ) [ ' value ' ] back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) background_app def background_app ( self , seconds ) Puts the application in the background on the device for a certain duration. Args: seconds (int): the duration for the application to remain in the background Returns: appium.webdriver.webdriver.WebDriver View Source def background_app ( self , seconds ) : \"\"\" Puts the application in the background on the device for a certain duration. Args : seconds ( int ) : the duration for the application to remain in the background Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' seconds ' : seconds , } self . execute ( Command . BACKGROUND , data ) return self close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) close_app def close_app ( self ) Stop the running application, specified in the desired capabilities, on the device. Returns: appium.webdriver.webdriver.WebDriver View Source def close_app ( self ) : \"\"\" Stop the running application, specified in the desired capabilities, on the device . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . CLOSE_APP ) return self create_web_element def create_web_element ( self , element_id , w3c = False ) Creates a web element with the specified element_id. Overrides method in Selenium WebDriver in order to always give them Appium WebElement Args: element_id (int): The element id to create a web element w3c (bool): Whether the element is W3C or MJSONWP Returns: MobileWebElement View Source def create_web_element ( self , element_id , w3c = False ) : \"\"\" Creates a web element with the specified element_id. Overrides method in Selenium WebDriver in order to always give them Appium WebElement Args : element_id ( int ) : The element id to create a web element w3c ( bool ) : Whether the element is W3C or MJSONWP Returns : ` MobileWebElement ` \"\"\" return MobileWebElement ( self , element_id , w3c ) deactivate_ime_engine def deactivate_ime_engine ( self ) Deactivates the currently active IME engine on the device. Android only. Returns: appium.webdriver.webdriver.WebDriver View Source def deactivate_ime_engine ( self ) : \"\"\" Deactivates the currently active IME engine on the device. Android only . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . DEACTIVATE_IME_ENGINE , {} ) return self delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) drag_and_drop def drag_and_drop ( self , origin_el , destination_el ) Drag the origin element to the destination element Args: originEl ( appium.webdriver.webelement.WebElement ): the element to drag destinationEl ( appium.webdriver.webelement.WebElement ): the element to drag to Returns: appium.webdriver.webelement.WebElement View Source def drag_and_drop ( self , origin_el , destination_el ) : \"\"\" Drag the origin element to the destination element Args : originEl ( ` appium . webdriver . webelement . WebElement ` ) : the element to drag destinationEl ( ` appium . webdriver . webelement . WebElement ` ) : the element to drag to Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" action = TouchAction ( self ) action . long_press ( origin_el ) . move_to ( destination_el ) . release () . perform () return self end_test_coverage def end_test_coverage ( self , intent , path ) Ends the coverage collection and pull the coverage.ec file from the device. Android only. See https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/android/android-coverage.md Args: intent (str): description of operation to be performed path (str): path to coverage.ec file to be pulled from the device Returns: TODO View Source def end_test_coverage ( self , intent , path ) : \"\"\" Ends the coverage collection and pull the coverage.ec file from the device. Android only . See https : // github . com / appium / appium / blob / master / docs / en / writing - running - appium / android / android - coverage . md Args : intent ( str ) : description of operation to be performed path ( str ) : path to coverage . ec file to be pulled from the device Returns : TODO \"\"\" data = { ' intent ' : intent , ' path ' : path , } return self . execute ( Command . END_TEST_COVERAGE , data ) [ ' value ' ] execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_driver def execute_driver ( self , script , script_type = 'webdriverio' , timeout_ms = None ) Run a set of script against the current session, allowing execution of many commands in one Appium request. Please read http://appium.io/docs/en/commands/session/execute-driver for more details about the acceptable scripts and the output format. Args: script (string): The string consisting of the script itself script_type (string): The name of the script type. Defaults to 'webdriverio'. timeout_ms (optional): The number of ms Appium should wait for the script to finish before killing it due to timeout_ms. Usage: self.driver.execute_driver(script='return [];') self.driver.execute_driver(script='return [];', script_type='webdriverio') self.driver.execute_driver(script='return [];', script_type='webdriverio', timeout_ms=10000) Returns: ExecuteDriver.Result: The result of the script. It has 'result' and 'logs' keys. Raises: WebDriverException: If something error happenes in the script. The message has the original error message. View Source def execute_driver ( self , script , script_type = ' webdriverio ' , timeout_ms = None ) : \"\"\" Run a set of script against the current session, allowing execution of many commands in one Appium request. Please read http : // appium . io / docs / en / commands / session / execute - driver for more details about the acceptable scripts and the output format . Args : script ( string ) : The string consisting of the script itself script_type ( string ) : The name of the script type . Defaults to ' webdriverio ' . timeout_ms ( optional ) : The number of ` ms ` Appium should wait for the script to finish before killing it due to timeout_ms . Usage : self . driver . execute_driver ( script = ' return []; ' ) self . driver . execute_driver ( script = ' return []; ' , script_type = ' webdriverio ' ) self . driver . execute_driver ( script = ' return []; ' , script_type = ' webdriverio ' , timeout_ms = 10000 ) Returns : ExecuteDriver . Result : The result of the script . It has ' result ' and ' logs ' keys . Raises : WebDriverException : If something error happenes in the script . The message has the original error message . \"\"\" class Result ( object ) : def __init__ ( self , response ) : self . result = response [ ' result ' ] self . logs = response [ ' logs ' ] option = { ' script ' : script , ' type ' : script_type } if timeout_ms is not None : option [ ' timeout ' ] = timeout_ms response = self . execute ( Command . EXECUTE_DRIVER , option ) [ ' value ' ] return Result ( response ) execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) 'Private' method used by the find_element_by_* methods. Override for Appium Usage: Use the corresponding find_element_by_* instead of this. Returns: appium.webdriver.webelement.WebElement :rtype: MobileWebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" 'Private' method used by the find_element_by_* methods. Override for Appium Usage : Use the corresponding find_element_by_ * instead of this . Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" # TODO : If we need , we should enable below converter for Web context # if self . w3c : # if by == By . ID : # by = By . CSS_SELECTOR # value = ' [id=\"%s\"] ' % value # elif by == By . TAG_NAME : # by = By . CSS_SELECTOR # elif by == By . CLASS_NAME : # by = By . CSS_SELECTOR # value = \" .%s \" % value # elif by == By . NAME : # by = By . CSS_SELECTOR # value = ' [name=\"%s\"] ' % value return self . execute ( RemoteCommand . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_accessibility_id def find_element_by_accessibility_id ( self , accessibility_id ) Finds an element by accessibility id. Args: accessibility_id (str): A string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize Usage: driver.find_element_by_accessibility_id() Returns: appium.webdriver.webelement.WebElement :rtype: MobileWebElement View Source def find_element_by_accessibility_id ( self , accessibility_id ) : \"\"\" Finds an element by accessibility id. Args : accessibility_id ( str ) : A string corresponding to a recursive element search using the Id / Name that the native Accessibility options utilize Usage : driver . find_element_by_accessibility_id () Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id ) find_element_by_android_data_matcher def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) Finds element by onData in Android It works with Espresso Driver . Args: name (:obj: str , optional): The name of a method to invoke. The method must return a Hamcrest Matcher args (:obj: str , optional): The args provided to the method className (:obj: str , optional): The class name that the method is part of (defaults to org.hamcrest.Matchers ). Can be fully qualified, or simple, and simple defaults to androidx.test.espresso.matcher package (e.g.: class=CursorMatchers fully qualified is class=androidx.test.espresso.matcher.CursorMatchers Returns: appium.webdriver.webelement.WebElement : The found element Raises: TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage: driver.find_element_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) View Source def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds element by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found element Raises : TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage : driver . find_element_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_element ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) ) find_element_by_android_uiautomator def find_element_by_android_uiautomator ( self , uia_string ) Finds element by uiautomator in Android. Args: uia_string: The element name in the Android UIAutomator library Usage: driver.find_element_by_android_uiautomator('.elements()[1].cells()[2]') Returns: appium.webdriver.webelement.WebElement :rtype: MobileWebElement View Source def find_element_by_android_uiautomator ( self , uia_string ) : \"\"\" Finds element by uiautomator in Android. Args : uia_string : The element name in the Android UIAutomator library Usage : driver . find_element_by_android_uiautomator ( ' .elements()[1].cells()[2] ' ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string ) find_element_by_android_viewtag def find_element_by_android_viewtag ( self , tag ) Finds element by View#tags in Android. It works with Espresso Driver . Args: tag (str): The tag name of the view to look for Usage: driver.find_element_by_android_viewtag('a tag name') Returns: appium.webdriver.webelement.WebElement :rtype: MobileWebElement View Source def find_element_by_android_viewtag ( self , tag ) : \"\"\"Finds element by [View#tags](https://developer.android.com/reference/android/view/View#tags) in Android. It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : tag ( str ) : The tag name of the view to look for Usage : driver . find_element_by_android_viewtag ( ' a tag name ' ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . ANDROID_VIEWTAG , value = tag ) find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_custom def find_element_by_custom ( self , selector ) Finds an element in conjunction with a custom element finding plugin Args: selector (str): a string of the form \"module:selector\", where \"module\" is the shortcut name given in the customFindModules capability, and \"selector\" is the string that will be passed to the custom element finding plugin itself Usage: driver.find_element_by_custom(\"foo:bar\") Returns: appium.webdriver.webelement.WebElement :rtype: MobileWebElement View Source def find_element_by_custom ( self , selector ) : \"\"\" Finds an element in conjunction with a custom element finding plugin Args : selector ( str ) : a string of the form \" module:selector \" , where \" module \" is the shortcut name given in the customFindModules capability , and \" selector \" is the string that will be passed to the custom element finding plugin itself Usage : driver . find_element_by_custom ( \" foo:bar \" ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . CUSTOM , value = selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_image def find_element_by_image ( self , img_path ) Finds a portion of a screenshot by an image. Uses driver.find_image_occurrence under the hood. Args: img_path (str): a string corresponding to the path of a image Returns: appium.webdriver.webelement.WebElement :rtype: MobileWebElement View Source def find_element_by_image ( self , img_path ) : \"\"\" Finds a portion of a screenshot by an image. Uses driver . find_image_occurrence under the hood . Args : img_path ( str ) : a string corresponding to the path of a image Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" with open ( img_path , ' rb ' ) as i_file : b64_data = base64 . b64encode ( i_file . read ()) . decode ( ' UTF-8 ' ) return self . find_element ( by = MobileBy . IMAGE , value = b64_data ) find_element_by_ios_class_chain def find_element_by_ios_class_chain ( self , class_chain_string ) Find an element by ios class chain string. Args: class_chain_string (str): The class chain string Usage: driver.find_element_by_ios_class_chain('XCUIElementTypeWindow/XCUIElementTypeButton[3]') Returns: appium.webdriver.webelement.WebElement :rtype: MobileWebElement View Source def find_element_by_ios_class_chain ( self , class_chain_string ) : \"\"\" Find an element by ios class chain string. Args : class_chain_string ( str ) : The class chain string Usage : driver . find_element_by_ios_class_chain ( ' XCUIElementTypeWindow/XCUIElementTypeButton[3] ' ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string ) find_element_by_ios_predicate def find_element_by_ios_predicate ( self , predicate_string ) Find an element by ios predicate string. Args: predicate_string (str): The predicate string Usage: driver.find_element_by_ios_predicate('label == \"myLabel\"') Returns: appium.webdriver.webelement.WebElement :rtype: MobileWebElement View Source def find_element_by_ios_predicate ( self , predicate_string ) : \"\"\" Find an element by ios predicate string. Args : predicate_string ( str ) : The predicate string Usage : driver . find_element_by_ios_predicate ( ' label == \"myLabel\" ' ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_PREDICATE , value = predicate_string ) find_element_by_ios_uiautomation def find_element_by_ios_uiautomation ( self , uia_string ) Finds an element by uiautomation in iOS. Args: uia_string (str): The element name in the iOS UIAutomation library Usage: driver.find_element_by_ios_uiautomation('.elements()[1].cells()[2]') Returns: appium.webdriver.webelement.WebElement :rtype: MobileWebElement View Source def find_element_by_ios_uiautomation ( self , uia_string ) : \"\"\" Finds an element by uiautomation in iOS. Args : uia_string ( str ) : The element name in the iOS UIAutomation library Usage : driver . find_element_by_ios_uiautomation ( ' .elements()[1].cells()[2] ' ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) 'Private' method used by the find_elements_by_* methods. Override for Appium Usage: Use the corresponding find_elements_by_* instead of this. Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement :rtype: list of MobileWebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" 'Private' method used by the find_elements_by_* methods. Override for Appium Usage : Use the corresponding find_elements_by_ * instead of this . Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" # TODO : If we need , we should enable below converter for Web context # if self . w3c : # if by == By . ID : # by = By . CSS_SELECTOR # value = ' [id=\"%s\"] ' % value # elif by == By . TAG_NAME : # by = By . CSS_SELECTOR # elif by == By . CLASS_NAME : # by = By . CSS_SELECTOR # value = \" .%s \" % value # elif by == By . NAME : # by = By . CSS_SELECTOR # value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( RemoteCommand . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_accessibility_id def find_elements_by_accessibility_id ( self , accessibility_id ) Finds elements by accessibility id. Args: accessibility_id (str): a string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize Usage: driver.find_elements_by_accessibility_id() Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement :rtype: list of MobileWebElement View Source def find_elements_by_accessibility_id ( self , accessibility_id ) : \"\"\" Finds elements by accessibility id. Args : accessibility_id ( str ) : a string corresponding to a recursive element search using the Id / Name that the native Accessibility options utilize Usage : driver . find_elements_by_accessibility_id () Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id ) find_elements_by_android_data_matcher def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) Finds elements by onData in Android It works with Espresso Driver . Args: name (:obj: str , optional): The name of a method to invoke. The method must return a Hamcrest Matcher args (:obj: str , optional): The args provided to the method className (:obj: str , optional): The class name that the method is part of (defaults to org.hamcrest.Matchers ). Can be fully qualified, or simple, and simple defaults to androidx.test.espresso.matcher package (e.g.: class=CursorMatchers fully qualified is class=androidx.test.espresso.matcher.CursorMatchers Returns: appium.webdriver.webelement.WebElement : The found elements Usage: driver.find_elements_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) View Source def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds elements by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found elements Usage : driver . find_elements_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_elements ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) ) find_elements_by_android_uiautomator def find_elements_by_android_uiautomator ( self , uia_string ) Finds elements by uiautomator in Android. Args: uia_string (str): The element name in the Android UIAutomator library Usage: driver.find_elements_by_android_uiautomator('.elements()[1].cells()[2]') Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement :rtype: list of MobileWebElement View Source def find_elements_by_android_uiautomator ( self , uia_string ) : \"\"\" Finds elements by uiautomator in Android. Args : uia_string ( str ) : The element name in the Android UIAutomator library Usage : driver . find_elements_by_android_uiautomator ( ' .elements()[1].cells()[2] ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string ) find_elements_by_android_viewtag def find_elements_by_android_viewtag ( self , tag ) Finds element by View#tags in Android. It works with Espresso Driver . Args: tag (str): The tag name of the view to look for Usage: driver.find_elements_by_android_viewtag('a tag name') Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement :rtype: list of MobileWebElement View Source def find_elements_by_android_viewtag ( self , tag ) : \"\"\"Finds element by [View#tags](https://developer.android.com/reference/android/view/View#tags) in Android. It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : tag ( str ) : The tag name of the view to look for Usage : driver . find_elements_by_android_viewtag ( ' a tag name ' ) Returns : : obj : ` list ` of : obj : ` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . ANDROID_VIEWTAG , value = tag ) find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_custom def find_elements_by_custom ( self , selector ) Finds elements in conjunction with a custom element finding plugin Args: selector: a string of the form \"module:selector\", where \"module\" is the shortcut name given in the customFindModules capability, and \"selector\" is the string that will be passed to the custom element finding plugin itself Usage: driver.find_elements_by_custom(\"foo:bar\") Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement :rtype: list of MobileWebElement View Source def find_elements_by_custom ( self , selector ) : \"\"\" Finds elements in conjunction with a custom element finding plugin Args : selector : a string of the form \" module:selector \" , where \" module \" is the shortcut name given in the customFindModules capability , and \" selector \" is the string that will be passed to the custom element finding plugin itself Usage : driver . find_elements_by_custom ( \" foo:bar \" ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . CUSTOM , value = selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_image def find_elements_by_image ( self , img_path ) Finds a portion of a screenshot by an image. Uses driver.find_image_occurrence under the hood. Note that this will only ever return at most one element Args: img_path (str): a string corresponding to the path of a image Return: :obj: list of :obj: appium.webdriver.webelement.WebElement :rtype: list of MobileWebElement View Source def find_elements_by_image ( self , img_path ) : \"\"\" Finds a portion of a screenshot by an image. Uses driver . find_image_occurrence under the hood . Note that this will only ever return at most one element Args : img_path ( str ) : a string corresponding to the path of a image Return : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" with open ( img_path , ' rb ' ) as i_file : b64_data = base64 . b64encode ( i_file . read ()) . decode ( ' UTF-8 ' ) return self . find_elements ( by = MobileBy . IMAGE , value = b64_data ) find_elements_by_ios_class_chain def find_elements_by_ios_class_chain ( self , class_chain_string ) Finds elements by ios class chain string. Args: class_chain_string (str): The class chain string Usage: driver.find_elements_by_ios_class_chain('XCUIElementTypeWindow[2]/XCUIElementTypeAny[-2]') Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement :rtype: list of MobileWebElement View Source def find_elements_by_ios_class_chain ( self , class_chain_string ) : \"\"\" Finds elements by ios class chain string. Args : class_chain_string ( str ) : The class chain string Usage : driver . find_elements_by_ios_class_chain ( ' XCUIElementTypeWindow[2]/XCUIElementTypeAny[-2] ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string ) find_elements_by_ios_predicate def find_elements_by_ios_predicate ( self , predicate_string ) Finds elements by ios predicate string. Args: predicate_string (str): The predicate string Usage: driver.find_elements_by_ios_predicate('label == \"myLabel\"') Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement :rtype: list of MobileWebElement View Source def find_elements_by_ios_predicate ( self , predicate_string ) : \"\"\" Finds elements by ios predicate string. Args : predicate_string ( str ) : The predicate string Usage : driver . find_elements_by_ios_predicate ( ' label == \"myLabel\" ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_PREDICATE , value = predicate_string ) find_elements_by_ios_uiautomation def find_elements_by_ios_uiautomation ( self , uia_string ) Finds elements by uiautomation in iOS. Args: uia_string: The element name in the iOS UIAutomation library Usage: driver.find_elements_by_ios_uiautomation('.elements()[1].cells()[2]') Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement :rtype: list of MobileWebElement View Source def find_elements_by_ios_uiautomation ( self , uia_string ) : \"\"\" Finds elements by uiautomation in iOS. Args : uia_string : The element name in the iOS UIAutomation library Usage : driver . find_elements_by_ios_uiautomation ( ' .elements()[1].cells()[2] ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) find_image_occurrence def find_image_occurrence ( self , base64_full_image , base64_partial_image , ** opts ) Performs images matching by template to find possible occurrence of the partial image in the full image. Read https://docs.opencv.org/2.4/doc/tutorials/imgproc/histograms/template_matching/template_matching.html for more details on this topic. The method supports all image formats, which are supported by OpenCV itself. Args: base64_full_image (bytes): base64-encoded content of the full image base64_partial_image (bytes): base64-encoded content of the partial image Keyword Args: visualize (bool): Set it to True in order to return the visualization of the matching operation. False by default Returns: visualization (bytes): base64-encoded content of PNG visualization of the current comparison operation. This entry is only present if visualize option is enabled rect (dict): The region of the partial image occurrence on the full image. The rect is represented by a dictionary with 'x', 'y', 'width' and 'height' keys View Source def find_image_occurrence ( self , base64_full_image , base64_partial_image , ** opts ) : \"\"\" Performs images matching by template to find possible occurrence of the partial image in the full image . Read https : // docs . opencv . org / 2 . 4 / doc / tutorials / imgproc / histograms / template_matching / template_matching . html for more details on this topic . The method supports all image formats , which are supported by OpenCV itself . Args : base64_full_image ( bytes ) : base64 - encoded content of the full image base64_partial_image ( bytes ) : base64 - encoded content of the partial image Keyword Args : visualize ( bool ) : Set it to True in order to return the visualization of the matching operation . False by default Returns : visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled rect ( dict ) : The region of the partial image occurrence on the full image . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys \"\"\" options = { ' mode ' : ' matchTemplate ' , ' firstImage ' : base64_full_image , ' secondImage ' : base64_partial_image , ' options ' : opts } return self . execute ( Command . COMPARE_IMAGES , options ) [ ' value ' ] finger_print def finger_print ( self , finger_id ) Authenticate users by using their finger print scans on supported Android emulators. Args: finger_id (int): Finger prints stored in Android Keystore system (from 1 to 10) Returns: TODO View Source def finger_print ( self , finger_id ) : \"\"\" Authenticate users by using their finger print scans on supported Android emulators. Args : finger_id ( int ) : Finger prints stored in Android Keystore system ( from 1 to 10 ) Returns : TODO \"\"\" return self . execute ( Command . FINGER_PRINT , { ' fingerprintId ' : finger_id } ) [ ' value ' ] flick def flick ( self , start_x , start_y , end_x , end_y ) Flick from one point to another point. Args: start_x (int): x-coordinate at which to start start_y (int): y-coordinate at which to start end_x (int): x-coordinate at which to stop end_y (int): y-coordinate at which to stop Usage: driver.flick(100, 100, 100, 400) Returns: appium.webdriver.webelement.WebElement View Source def flick ( self , start_x , start_y , end_x , end_y ) : \"\"\" Flick from one point to another point. Args : start_x ( int ) : x - coordinate at which to start start_y ( int ) : y - coordinate at which to start end_x ( int ) : x - coordinate at which to stop end_y ( int ) : y - coordinate at which to stop Usage : driver . flick ( 100 , 100 , 100 , 400 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" action = TouchAction ( self ) action \\ . press ( x = start_x , y = start_y ) \\ . move_to ( x = end_x , y = end_y ) \\ . release () action . perform () return self forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_clipboard def get_clipboard ( self , content_type = 'plaintext' ) Receives the content of the system clipboard Args: content_type (str): One of ClipboardContentType items. Only ClipboardContentType.PLAINTEXT is supported on Android Returns: base64-encoded string: Clipboard content. Or return an empty string if the clipboard is empty View Source def get_clipboard ( self , content_type = ClipboardContentType . PLAINTEXT ) : \"\"\" Receives the content of the system clipboard Args : content_type ( str ) : One of ClipboardContentType items . Only ClipboardContentType . PLAINTEXT is supported on Android Returns : base64 - encoded string : Clipboard content . Or return an empty string if the clipboard is empty \"\"\" base64_str = self . execute ( Command . GET_CLIPBOARD , { ' contentType ' : content_type } ) [ ' value ' ] return base64 . b64decode ( base64_str ) get_clipboard_text def get_clipboard_text ( self ) Receives the text of the system clipboard Return: str: The actual clipboard text or an empty string if the clipboard is empty View Source def get_clipboard_text ( self ) : \"\"\" Receives the text of the system clipboard Return : str : The actual clipboard text or an empty string if the clipboard is empty \"\"\" return self . get_clipboard ( ClipboardContentType . PLAINTEXT ) . decode ( ' UTF-8 ' ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_device_time def get_device_time ( self , format = None ) Returns the date and time from the device. Args: format (optional): The set of format specifiers. Read https://momentjs.com/docs/ to get the full list of supported datetime format specifiers. If unset, return :func: .device_time as default format is YYYY-MM-DDTHH:mm:ssZ , which complies to ISO-8601 Usage: self.driver.get_device_time() self.driver.get_device_time(\"YYYY-MM-DD\") Return: str: The date and time View Source def get_device_time ( self , format = None ) : \"\"\" Returns the date and time from the device. Args : format ( optional ) : The set of format specifiers . Read https : // momentjs . com / docs / to get the full list of supported datetime format specifiers . If unset , return : func :`. device_time ` as default format is ` YYYY - MM - DDTHH : mm : ssZ `, which complies to ISO - 8601 Usage : self . driver . get_device_time () self . driver . get_device_time ( \" YYYY-MM-DD \" ) Return : str : The date and time \"\"\" if format is None : return self . device_time return self . execute ( Command . GET_DEVICE_TIME_POST , { ' format ' : format } ) [ ' value ' ] get_display_density def get_display_density ( self ) Get the display density, Android only Returns: int: The display density of the Android device(dpi) Usage: self.driver.get_display_density() View Source def get_display_density ( self ) : \"\"\" Get the display density, Android only Returns : int : The display density of the Android device ( dpi ) Usage : self . driver . get_display_density () \"\"\" return self . execute ( Command . GET_DISPLAY_DENSITY ) [ ' value ' ] get_images_similarity def get_images_similarity ( self , base64_image1 , base64_image2 , ** opts ) Performs images matching to calculate the similarity score between them. The flow there is similar to the one used in find_image_occurrence , but it is mandatory that both images are of equal resolution. The method supports all image formats, which are supported by OpenCV itself. Args: base64_image1 (bytes): base64-encoded content of the first image base64_image2 (bytes): base64-encoded content of the second image Keyword Args: visualize (bool): Set it to True in order to return the visualization of the matching operation. False by default Returns: visualization (bytes): base64-encoded content of PNG visualization of the current comparison operation. This entry is only present if visualize option is enabled score (float): The similarity score as a float number in range [0.0, 1.0]. 1.0 is the highest score (means both images are totally equal). View Source def get_images_similarity ( self , base64_image1 , base64_image2 , ** opts ) : \"\"\" Performs images matching to calculate the similarity score between them. The flow there is similar to the one used in ` find_image_occurrence `, but it is mandatory that both images are of equal resolution . The method supports all image formats , which are supported by OpenCV itself . Args : base64_image1 ( bytes ) : base64 - encoded content of the first image base64_image2 ( bytes ) : base64 - encoded content of the second image Keyword Args : visualize ( bool ) : Set it to True in order to return the visualization of the matching operation . False by default Returns : visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled score ( float ) : The similarity score as a float number in range [ 0 . 0 , 1 . 0 ]. 1 . 0 is the highest score ( means both images are totally equal ) . \"\"\" options = { ' mode ' : ' getSimilarity ' , ' firstImage ' : base64_image1 , ' secondImage ' : base64_image2 , ' options ' : opts } return self . execute ( Command . COMPARE_IMAGES , options ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_performance_data def get_performance_data ( self , package_name , data_type , data_read_timeout = None ) Returns the information of the system state which is supported to read as like cpu, memory, network traffic, and battery. Android only. Args: package_name (str): The package name of the application data_type (str): The type of system state which wants to read. It should be one of the supported performance data types. Check :func: .get_performance_data_types for supported types data_read_timeout (:obj: int , optional): The number of attempts to read Usage: self.driver.get_performance_data('my.app.package', 'cpuinfo', 5) Returns: dict: The data along to data_type View Source def get_performance_data ( self , package_name , data_type , data_read_timeout = None ) : \"\"\" Returns the information of the system state which is supported to read as like cpu , memory , network traffic , and battery . Android only . Args : package_name ( str ) : The package name of the application data_type ( str ) : The type of system state which wants to read . It should be one of the supported performance data types . Check : func :`. get_performance_data_types ` for supported types data_read_timeout ( : obj :` int `, optional ) : The number of attempts to read Usage : self . driver . get_performance_data ( ' my.app.package ' , ' cpuinfo ' , 5 ) Returns : dict : The data along to ` data_type ` \"\"\" data = { ' packageName ' : package_name , ' dataType ' : data_type } if data_read_timeout is not None : data [ ' dataReadTimeout ' ] = data_read_timeout return self . execute ( Command . GET_PERFORMANCE_DATA , data ) [ ' value ' ] get_performance_data_types def get_performance_data_types ( self ) Returns the information types of the system state which is supported to read as like cpu, memory, network traffic, and battery. Android only. Usage: self.driver.get_performance_data_types() Returns: list: Available data types View Source def get_performance_data_types ( self ) : \"\"\" Returns the information types of the system state which is supported to read as like cpu , memory , network traffic , and battery . Android only . Usage : self . driver . get_performance_data_types () Returns : list : Available data types \"\"\" return self . execute ( Command . GET_PERFORMANCE_DATA_TYPES ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_settings def get_settings ( self ) Returns the appium server Settings for the current session. Do not get Settings confused with Desired Capabilities, they are separate concepts. See https://github.com/appium/appium/blob/master/docs/en/advanced-concepts/settings.md Returns: dict: Current settings View Source def get_settings ( self ) : \"\"\" Returns the appium server Settings for the current session. Do not get Settings confused with Desired Capabilities , they are separate concepts . See https : // github . com / appium / appium / blob / master / docs / en / advanced - concepts / settings . md Returns : dict : Current settings \"\"\" return self . execute ( Command . GET_SETTINGS , {} ) [ ' value ' ] get_system_bars def get_system_bars ( self ) Retrieve visibility and bounds information of the status and navigation bars. Android only. Returns: A dictionary whose keys are - statusBar - visible - x - y - width - height - navigationBar - visible - x - y - width - height View Source def get_system_bars ( self ) : \"\"\" Retrieve visibility and bounds information of the status and navigation bars. Android only . Returns : A dictionary whose keys are - statusBar - visible - x - y - width - height - navigationBar - visible - x - y - width - height \"\"\" return self . execute ( Command . GET_SYSTEM_BARS ) [ ' value ' ] get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } hide_keyboard def hide_keyboard ( self , key_name = None , key = None , strategy = None ) Hides the software keyboard on the device. In iOS, use key_name to press a particular key, or strategy . In Android, no parameters are used. Args: key_name (:obj: str , optional): key to press key (:obj: str , optional): strategy (:obj: str , optional): strategy for closing the keyboard (e.g., tapOutside ) View Source def hide_keyboard ( self , key_name = None , key = None , strategy = None ) : \"\"\" Hides the software keyboard on the device. In iOS , use ` key_name ` to press a particular key , or ` strategy `. In Android , no parameters are used . Args : key_name ( : obj :` str `, optional ) : key to press key ( : obj :` str `, optional ) : strategy ( : obj :` str `, optional ) : strategy for closing the keyboard ( e . g ., ` tapOutside ` ) \"\"\" data = {} if key_name is not None : data [ ' keyName ' ] = key_name elif key is not None : data [ ' key ' ] = key elif strategy is None : strategy = ' tapOutside ' data [ ' strategy ' ] = strategy self . execute ( Command . HIDE_KEYBOARD , data ) return self implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) install_app def install_app ( self , app_path , ** options ) Install the application found at app_path on the device. Args: app_path (str): the local or remote path to the application to install Keyword Args: replace (bool): [Android only] whether to reinstall/upgrade the package if it is already present on the device under test. True by default timeout (int): [Android only] how much time to wait for the installation to complete. 60000ms by default. allowTestPackages (bool): [Android only] whether to allow installation of packages marked as test in the manifest. False by default useSdcard (bool): [Android only] whether to use the SD card to install the app. False by default grantPermissions (bool): [Android only] whether to automatically grant application permissions on Android 6+ after the installation completes. False by default Returns: appium.webdriver.webdriver.WebDriver View Source def install_app ( self , app_path , ** options ) : \"\"\"Install the application found at `app_path` on the device. Args : app_path ( str ) : the local or remote path to the application to install Keyword Args : replace ( bool ) : [ Android only ] whether to reinstall / upgrade the package if it is already present on the device under test . True by default timeout ( int ) : [ Android only ] how much time to wait for the installation to complete . 60000 ms by default . allowTestPackages ( bool ) : [ Android only ] whether to allow installation of packages marked as test in the manifest . False by default useSdcard ( bool ) : [ Android only ] whether to use the SD card to install the app . False by default grantPermissions ( bool ) : [ Android only ] whether to automatically grant application permissions on Android 6 + after the installation completes . False by default Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' appPath ' : app_path , } if options : data . update ({ ' options ' : options }) self . execute ( Command . INSTALL_APP , data ) return self is_app_installed def is_app_installed ( self , bundle_id ) Checks whether the application specified by bundle_id is installed on the device. Args: bundle_id (str): the id of the application to query Returns: bool: True if app is installed View Source def is_app_installed ( self , bundle_id ) : \"\"\" Checks whether the application specified by `bundle_id` is installed on the device. Args : bundle_id ( str ) : the id of the application to query Returns : bool : ` True ` if app is installed \"\"\" data = { ' bundleId ' : bundle_id , } return self . execute ( Command . IS_APP_INSTALLED , data ) [ ' value ' ] is_ime_active def is_ime_active ( self ) Checks whether the device has IME service active. Android only. Returns: bool: True if IME service is active View Source def is_ime_active ( self ) : \"\"\" Checks whether the device has IME service active. Android only . Returns : bool : ` True ` if IME service is active \"\"\" return self . execute ( Command . IS_IME_ACTIVE , {} ) [ ' value ' ] is_keyboard_shown def is_keyboard_shown ( self ) Attempts to detect whether a software keyboard is present Returns: bool: True if keyboard is shown View Source def is_keyboard_shown ( self ) : \"\"\" Attempts to detect whether a software keyboard is present Returns : bool : ` True ` if keyboard is shown \"\"\" return self . execute ( Command . IS_KEYBOARD_SHOWN ) [ ' value ' ] is_locked def is_locked ( self ) Checks whether the device is locked. Returns: bool: True if the device is locked View Source def is_locked ( self ) : \"\"\" Checks whether the device is locked. Returns : bool : ` True ` if the device is locked \"\"\" return self . execute ( Command . IS_LOCKED ) [ ' value ' ] keyevent def keyevent ( self , keycode , metastate = None ) Sends a keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html. Args: keycode (int): the keycode to be sent to the device metastate (:obj: int , optional): meta information about the keycode being sent Returns: appium.webdriver.webdriver.WebDriver View Source def keyevent ( self , keycode , metastate = None ) : \"\"\" Sends a keycode to the device. Android only . Possible keycodes can be found in http : // developer . android . com / reference / android / view / KeyEvent . html . Args : keycode ( int ) : the keycode to be sent to the device metastate ( : obj :` int `, optional ) : meta information about the keycode being sent Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' keycode ' : keycode , } if metastate is not None : data [ ' metastate ' ] = metastate self . execute ( Command . KEY_EVENT , data ) return self launch_app def launch_app ( self ) Start on the device the application specified in the desired capabilities. Returns: appium.webdriver.webdriver.WebDriver View Source def launch_app ( self ) : \"\"\" Start on the device the application specified in the desired capabilities. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . LAUNCH_APP ) return self lock def lock ( self , seconds = None ) Lock the device. No changes are made if the device is already unlocked. Args: seconds (optional): The duration to lock the device, in seconds. The device is going to be locked forever until unlock is called if it equals or is less than zero, otherwise this call blocks until the timeout expires and unlocks the screen automatically. Returns: appium.webdriver.webdriver.WebDriver View Source def lock ( self , seconds = None ) : \"\"\" Lock the device. No changes are made if the device is already unlocked. Args : seconds ( optional ) : The duration to lock the device , in seconds . The device is going to be locked forever until ` unlock ` is called if it equals or is less than zero , otherwise this call blocks until the timeout expires and unlocks the screen automatically . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" if seconds is None : self . execute ( Command . LOCK ) else : self . execute ( Command . LOCK , { ' seconds ' : seconds } ) return self long_press_keycode def long_press_keycode ( self , keycode , metastate = None , flags = None ) Sends a long press of keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html. Args: keycode (int): the keycode to be sent to the device metastate (:obj: int , optional): meta information about the keycode being sent flags (:obj: int , optional): the set of key event flags Returns: appium.webdriver.webdriver.WebDriver View Source def long_press_keycode ( self , keycode , metastate = None , flags = None ) : \"\"\" Sends a long press of keycode to the device. Android only . Possible keycodes can be found in http : // developer . android . com / reference / android / view / KeyEvent . html . Args : keycode ( int ) : the keycode to be sent to the device metastate ( : obj :` int `, optional ) : meta information about the keycode being sent flags ( : obj :` int `, optional ) : the set of key event flags Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' keycode ' : keycode } if metastate is not None : data [ ' metastate ' ] = metastate if flags is not None : data [ ' flags ' ] = flags self . execute ( Command . LONG_PRESS_KEYCODE , data ) return self make_gsm_call def make_gsm_call ( self , phone_number , action ) Make GSM call (Emulator only) Android only. Args: phone_number (str): The phone number to call to. action (str): The call action. A member of the const appium.webdriver.extensions.android.gsm.GsmCallActions :Usage: self.driver.make_gsm_call('5551234567', GsmCallActions.CALL) View Source def make_gsm_call ( self , phone_number , action ) : \"\"\" Make GSM call (Emulator only) Android only . Args : phone_number ( str ) : The phone number to call to . action ( str ) : The call action . A member of the const ` appium . webdriver . extensions . android . gsm . GsmCallActions ` : Usage : self . driver . make_gsm_call ( ' 5551234567 ' , GsmCallActions . CALL ) \"\"\" constants = extract_const_attributes ( GsmCallActions ) if action not in constants . values () : logger . warning ( ' {} is unknown. Consider using one of {} constants. (e.g. {}.CALL) ' . format ( action , list ( constants . keys ()) , GsmCallActions . __name__ )) self . execute ( Command . MAKE_GSM_CALL , { ' phoneNumber ' : phone_number , ' action ' : action } ) return self match_images_features def match_images_features ( self , base64_image1 , base64_image2 , ** opts ) Performs images matching by features. Read https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_feature2d/py_matcher/py_matcher.html for more details on this topic. The method supports all image formats, which are supported by OpenCV itself. Args: base64_image1 (bytes): base64-encoded content of the first image base64_image2 (bytes): base64-encoded content of the second image Keyword Args: visualize (bool): Set it to True in order to return the visualization of the matching operation. matching visualization. False by default detectorName (str): One of possible feature detector names: 'AKAZE', 'AGAST', 'BRISK', 'FAST', 'GFTT', 'KAZE', 'MSER', 'SIFT', 'ORB' Some of these detectors are not enabled in the default OpenCV deployment. 'ORB' By default. matchFunc (str): One of supported matching functions names: 'FlannBased', 'BruteForce', 'BruteForceL1', 'BruteForceHamming', 'BruteForceHammingLut', 'BruteForceSL2' 'BruteForce' by default goodMatchesFactor (int): The maximum count of \"good\" matches (e. g. with minimal distances). This count is unlimited by default. Returns: The dictionary containing the following entries: visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled count ( int ) : The count of matched edges on both images . The more matching edges there are no both images the more similar they are . totalCount ( int ) : The total count of matched edges on both images . It is equal to ` count ` if ` goodMatchesFactor ` does not limit the matches , otherwise it contains the total count of matches before ` goodMatchesFactor ` is applied . points1 ( dict )) : The array of matching points on the first image . Each point is a dictionary with ' x ' and ' y ' keys rect1 ( dict ) : The bounding rect for the ` points1 ` array or a zero rect if not enough matching points were found . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys points2 ( dict ) : The array of matching points on the second image . Each point is a dictionary with ' x ' and ' y ' keys rect2 ( dict ) : The bounding rect for the ` points2 ` array or a zero rect if not enough matching points were found . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys View Source def match_images_features ( self , base64_image1 , base64_image2 , ** opts ) : \"\"\" Performs images matching by features. Read https : // docs . opencv . org / 3 . 0 - beta / doc / py_tutorials / py_feature2d / py_matcher / py_matcher . html for more details on this topic . The method supports all image formats , which are supported by OpenCV itself . Args : base64_image1 ( bytes ) : base64 - encoded content of the first image base64_image2 ( bytes ) : base64 - encoded content of the second image Keyword Args : visualize ( bool ) : Set it to True in order to return the visualization of the matching operation . matching visualization . False by default detectorName ( str ) : One of possible feature detector names : ' AKAZE ' , ' AGAST ' , ' BRISK ' , ' FAST ' , ' GFTT ' , ' KAZE ' , ' MSER ' , ' SIFT ' , ' ORB ' Some of these detectors are not enabled in the default OpenCV deployment . ' ORB ' By default . matchFunc ( str ) : One of supported matching functions names : ' FlannBased ' , ' BruteForce ' , ' BruteForceL1 ' , ' BruteForceHamming ' , ' BruteForceHammingLut ' , ' BruteForceSL2 ' ' BruteForce ' by default goodMatchesFactor ( int ) : The maximum count of \" good \" matches ( e . g . with minimal distances ) . This count is unlimited by default . Returns : The dictionary containing the following entries : visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled count ( int ) : The count of matched edges on both images . The more matching edges there are no both images the more similar they are . totalCount ( int ) : The total count of matched edges on both images . It is equal to ` count ` if ` goodMatchesFactor ` does not limit the matches , otherwise it contains the total count of matches before ` goodMatchesFactor ` is applied . points1 ( dict )) : The array of matching points on the first image . Each point is a dictionary with ' x ' and ' y ' keys rect1 ( dict ) : The bounding rect for the ` points1 ` array or a zero rect if not enough matching points were found . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys points2 ( dict ) : The array of matching points on the second image . Each point is a dictionary with ' x ' and ' y ' keys rect2 ( dict ) : The bounding rect for the ` points2 ` array or a zero rect if not enough matching points were found . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys \"\"\" options = { ' mode ' : ' matchFeatures ' , ' firstImage ' : base64_image1 , ' secondImage ' : base64_image2 , ' options ' : opts } return self . execute ( Command . COMPARE_IMAGES , options ) [ ' value ' ] maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) open_notifications def open_notifications ( self ) Open notification shade in Android (API Level 18 and above) Returns: appium.webdriver.webdriver.WebDriver View Source def open_notifications ( self ) : \"\"\" Open notification shade in Android (API Level 18 and above) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . OPEN_NOTIFICATIONS , {} ) return self press_button def press_button ( self , button_name ) Sends a physical button name to the device to simulate the user pressing. iOS only. Possible button names can be found in https://github.com/appium/WebDriverAgent/blob/master/WebDriverAgentLib/Categories/XCUIDevice%2BFBHelpers.h Args: button_name (str): the button name to be sent to the device Returns: appium.webdriver.webdriver.WebDriver View Source def press_button ( self , button_name ) : \"\"\" Sends a physical button name to the device to simulate the user pressing. iOS only . Possible button names can be found in https : // github . com / appium / WebDriverAgent / blob / master / WebDriverAgentLib / Categories / XCUIDevice % 2 BFBHelpers . h Args : button_name ( str ) : the button name to be sent to the device Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' name ' : button_name } self . execute_script ( ' mobile: pressButton ' , data ) return self press_keycode def press_keycode ( self , keycode , metastate = None , flags = None ) Sends a keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html. Args: keycode (int): the keycode to be sent to the device metastate (:obj: int , optional): meta information about the keycode being sent flags (:obj: int , optional): the set of key event flags Returns: appium.webdriver.webdriver.WebDriver View Source def press_keycode ( self , keycode , metastate = None , flags = None ) : \"\"\" Sends a keycode to the device. Android only . Possible keycodes can be found in http : // developer . android . com / reference / android / view / KeyEvent . html . Args : keycode ( int ) : the keycode to be sent to the device metastate ( : obj :` int `, optional ) : meta information about the keycode being sent flags ( : obj :` int `, optional ) : the set of key event flags Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' keycode ' : keycode , } if metastate is not None : data [ ' metastate ' ] = metastate if flags is not None : data [ ' flags ' ] = flags self . execute ( Command . PRESS_KEYCODE , data ) return self pull_file def pull_file ( self , path ) Retrieves the file at path . Args: path (str): the path to the file on the device Returns: bytes: The file's contents as base64. View Source def pull_file ( self , path ) : \"\"\" Retrieves the file at `path`. Args : path ( str ) : the path to the file on the device Returns : bytes : The file ' s contents as base64. \"\"\" data = { ' path ' : path , } return self . execute ( Command . PULL_FILE , data ) [ ' value ' ] pull_folder def pull_folder ( self , path ) Retrieves a folder at path . Args: path (str): the path to the folder on the device Returns: bytes: The folder's contents zipped and encoded as Base64. View Source def pull_folder ( self , path ) : \"\"\" Retrieves a folder at `path`. Args : path ( str ) : the path to the folder on the device Returns : bytes : The folder ' s contents zipped and encoded as Base64. \"\"\" data = { ' path ' : path , } return self . execute ( Command . PULL_FOLDER , data ) [ ' value ' ] push_file def push_file ( self , destination_path , base64data = None , source_path = None ) Puts the data from the file at source_path , encoded as Base64, in the file specified as path . Specify either base64data or source_path , if both specified default to source_path Args: destination_path (str): the location on the device/simulator where the local file contents should be saved base64data (:obj: bytes , optional): file contents, encoded as Base64, to be written to the file on the device/simulator source_path (:obj: str , optional): local file path for the file to be loaded on device Returns: appium.webdriver.webdriver.WebDriver View Source def push_file ( self , destination_path , base64data = None , source_path = None ) : \"\"\" Puts the data from the file at `source_path`, encoded as Base64, in the file specified as `path`. Specify either ` base64data ` or ` source_path `, if both specified default to ` source_path ` Args : destination_path ( str ) : the location on the device / simulator where the local file contents should be saved base64data ( : obj :` bytes `, optional ) : file contents , encoded as Base64 , to be written to the file on the device / simulator source_path ( : obj :` str `, optional ) : local file path for the file to be loaded on device Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" if source_path is None and base64data is None : raise InvalidArgumentException ( ' Must either pass base64 data or a local file path ' ) if source_path is not None : try : with open ( source_path , ' rb ' ) as f : data = f . read () except IOError : message = ' source_path {} could not be found. Are you sure the file exists? ' . format ( source_path ) raise InvalidArgumentException ( message ) base64data = base64 . b64encode ( data ) . decode ( ' utf-8 ' ) data = { ' path ' : destination_path , ' data ' : base64data , } self . execute ( Command . PUSH_FILE , data ) return self query_app_state def query_app_state ( self , app_id ) Queries the state of the application. Args: app_id (str): the application id to be queried Returns: One of possible application state constants. See ApplicationState class for more details. View Source def query_app_state ( self , app_id ) : \"\"\" Queries the state of the application. Args : app_id ( str ) : the application id to be queried Returns : One of possible application state constants . See ApplicationState class for more details . \"\"\" data = { ' appId ' : app_id , } return self . execute ( Command . QUERY_APP_STATE , data ) [ ' value ' ] quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) remove_app def remove_app ( self , app_id , ** options ) Remove the specified application from the device. Args: app_id (str): the application id to be removed Keyword Args: keepData (bool): [Android only] whether to keep application data and caches after it is uninstalled. False by default timeout (int): [Android only] how much time to wait for the uninstall to complete. 20000ms by default. Returns: appium.webdriver.webdriver.WebDriver View Source def remove_app ( self , app_id , ** options ) : \"\"\"Remove the specified application from the device. Args : app_id ( str ) : the application id to be removed Keyword Args : keepData ( bool ) : [ Android only ] whether to keep application data and caches after it is uninstalled . False by default timeout ( int ) : [ Android only ] how much time to wait for the uninstall to complete . 20000 ms by default . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' appId ' : app_id , } if options : data . update ({ ' options ' : options }) self . execute ( Command . REMOVE_APP , data ) return self reset def reset ( self ) Resets the current application on the device. View Source def reset ( self ) : \"\"\" Resets the current application on the device. \"\"\" self . execute ( Command . RESET ) return self save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) scroll def scroll ( self , origin_el , destination_el , duration = None ) Scrolls from one element to another Args: originalEl ( appium.webdriver.webelement.WebElement ): the element from which to being scrolling destinationEl ( appium.webdriver.webelement.WebElement ): the element to scroll to duration (int): a duration after pressing originalEl and move the element to destinationEl. Default is 600 ms for W3C spec. Zero for MJSONWP. Usage: driver.scroll(el1, el2) Returns: appium.webdriver.webelement.WebElement View Source def scroll ( self , origin_el , destination_el , duration = None ) : \"\"\" Scrolls from one element to another Args : originalEl ( ` appium . webdriver . webelement . WebElement ` ) : the element from which to being scrolling destinationEl ( ` appium . webdriver . webelement . WebElement ` ) : the element to scroll to duration ( int ) : a duration after pressing originalEl and move the element to destinationEl . Default is 600 ms for W3C spec . Zero for MJSONWP . Usage : driver . scroll ( el1 , el2 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" # XCUITest x W3C spec has no duration by default in server side if self . w3c and duration is None : duration = 600 action = TouchAction ( self ) if duration is None : action . press ( origin_el ) . move_to ( destination_el ) . release () . perform () else : action . press ( origin_el ) . wait ( duration ) . move_to ( destination_el ) . release () . perform () return self send_sms def send_sms ( self , phone_number , message ) Emulate send SMS event on the connected emulator. Android only. Args: phone_number (str): The phone number of message sender message (str): The message to send Usage: self.driver.send_sms('555-123-4567', 'Hey lol') Returns: appium.webdriver.webdriver.WebDriver View Source def send_sms ( self , phone_number , message ) : \"\"\" Emulate send SMS event on the connected emulator. Android only . Args : phone_number ( str ) : The phone number of message sender message ( str ) : The message to send Usage : self . driver . send_sms ( ' 555-123-4567 ' , ' Hey lol ' ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SEND_SMS , { ' phoneNumber ' : phone_number , ' message ' : message } ) return self set_clipboard def set_clipboard ( self , content , content_type = 'plaintext' , label = None ) Set the content of the system clipboard Args: content (str): The content to be set as bytearray string content_type (str): One of ClipboardContentType items. Only ClipboardContentType.PLAINTEXT is supported on Android label (:obj: str , optional): label argument, which only works for Android View Source def set_clipboard ( self , content , content_type = ClipboardContentType . PLAINTEXT , label = None ) : \"\"\" Set the content of the system clipboard Args : content ( str ) : The content to be set as bytearray string content_type ( str ) : One of ClipboardContentType items . Only ClipboardContentType . PLAINTEXT is supported on Android label ( : obj :` str `, optional ) : label argument , which only works for Android \"\"\" options = { ' content ' : base64 . b64encode ( content ) . decode ( ' UTF-8 ' ) , ' contentType ' : content_type , } if label : options [ ' label ' ] = label self . execute ( Command . SET_CLIPBOARD , options ) set_clipboard_text def set_clipboard_text ( self , text , label = None ) Copies the given text to the system clipboard Args: text (str): The text to be set label (:obj: int , optional):label argument, which only works for Android View Source def set_clipboard_text ( self , text , label = None ) : \"\"\" Copies the given text to the system clipboard Args : text ( str ) : The text to be set label ( : obj :` int `, optional ) : label argument , which only works for Android \"\"\" self . set_clipboard ( appium_bytes ( str ( text ) , ' UTF-8 ' ) , ClipboardContentType . PLAINTEXT , label ) set_gsm_signal def set_gsm_signal ( self , strength ) Set GSM signal strength (Emulator only) Android only. Args: strength (int): Signal strength. A member of the enum appium.webdriver.extensions.android.gsm.GsmSignalStrength Usage: self.driver.set_gsm_signal(GsmSignalStrength.GOOD) View Source def set_gsm_signal ( self , strength ) : \"\"\" Set GSM signal strength (Emulator only) Android only . Args : strength ( int ) : Signal strength . A member of the enum ` appium . webdriver . extensions . android . gsm . GsmSignalStrength ` Usage : self . driver . set_gsm_signal ( GsmSignalStrength . GOOD ) \"\"\" constants = extract_const_attributes ( GsmSignalStrength ) if strength not in constants . values () : logger . warning ( ' {} is out of range. Consider using one of {} constants. (e.g. {}.GOOD) ' . format ( strength , list ( constants . keys ()) , GsmSignalStrength . __name__ )) self . execute ( Command . SET_GSM_SIGNAL , { ' signalStrength ' : strength , ' signalStrengh ' : strength } ) return self set_gsm_voice def set_gsm_voice ( self , state ) Set GSM voice state (Emulator only) Android only. Args: state (str): State of GSM voice. A member of the const appium.webdriver.extensions.android.gsm.GsmVoiceState Usage: self.driver.set_gsm_voice(GsmVoiceState.HOME) View Source def set_gsm_voice ( self , state ) : \"\"\" Set GSM voice state (Emulator only) Android only . Args : state ( str ) : State of GSM voice . A member of the const ` appium . webdriver . extensions . android . gsm . GsmVoiceState ` Usage : self . driver . set_gsm_voice ( GsmVoiceState . HOME ) \"\"\" constants = extract_const_attributes ( GsmVoiceState ) if state not in constants . values () : logger . warning ( ' {} is unknown. Consider using one of {} constants. (e.g. {}.HOME) ' . format ( state , list ( constants . keys ()) , GsmVoiceState . __name__ )) self . execute ( Command . SET_GSM_VOICE , { ' state ' : state } ) return self set_location def set_location ( self , latitude , longitude , altitude = None ) Set the location of the device Args: latitude (Union[float, str]): String or numeric value between -90.0 and 90.00 longitude (Union[float, str]): String or numeric value between -180.0 and 180.0 altitude (Union[float, str], optional): String or numeric value (Android real device only) Returns: appium.webdriver.webdriver.WebDriver View Source def set_location ( self , latitude , longitude , altitude = None ) : \"\"\" Set the location of the device Args : latitude ( Union [ float , str ] ) : String or numeric value between - 90 . 0 and 90 . 00 longitude ( Union [ float , str ] ) : String or numeric value between - 180 . 0 and 180 . 0 altitude ( Union [ float , str ], optional ) : String or numeric value ( Android real device only ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { \" location \" : { \" latitude \" : latitude , \" longitude \" : longitude , } } if altitude is not None : data [ ' location ' ][ ' altitude ' ] = altitude self . execute ( Command . SET_LOCATION , data ) return self set_network_connection def set_network_connection ( self , connection_type ) Sets the network connection type. Android only. Possible values: Value (Alias) | Data | Wifi | Airplane Mode ------------------------------------------------- 0 (None) | 0 | 0 | 0 1 (Airplane Mode) | 0 | 0 | 1 2 (Wifi only) | 0 | 1 | 0 4 (Data only) | 1 | 0 | 0 6 (All network on) | 1 | 1 | 0 These are available through the enumeration appium.webdriver.ConnectionType Args: connection_type (int): a member of the enum appium.webdriver.ConnectionType Returns: appium.webdriver.webdriver.WebDriver View Source def set_network_connection ( self , connection_type ) : \"\"\" Sets the network connection type. Android only. Possible values : Value ( Alias ) | Data | Wifi | Airplane Mode ------------------------------------------------- 0 ( None ) | 0 | 0 | 0 1 ( Airplane Mode ) | 0 | 0 | 1 2 ( Wifi only ) | 0 | 1 | 0 4 ( Data only ) | 1 | 0 | 0 6 ( All network on ) | 1 | 1 | 0 These are available through the enumeration ` appium . webdriver . ConnectionType ` Args : connection_type ( int ) : a member of the enum appium . webdriver . ConnectionType Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' parameters ' : { ' type ' : connection_type } } return self . execute ( Command . SET_NETWORK_CONNECTION , data ) [ ' value ' ] set_network_speed def set_network_speed ( self , speed_type ) Set the network speed emulation. Android Emulator only. Args: speed_type (str): The network speed type. A member of the const appium.webdriver.extensions.android.network.NetSpeed. Usage: self.driver.set_network_speed(NetSpeed.LTE) Returns: appium.webdriver.webdriver.WebDriver View Source def set_network_speed ( self , speed_type ) : \"\"\" Set the network speed emulation. Android Emulator only . Args : speed_type ( str ) : The network speed type . A member of the const appium . webdriver . extensions . android . network . NetSpeed . Usage : self . driver . set_network_speed ( NetSpeed . LTE ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" constants = extract_const_attributes ( NetSpeed ) if speed_type not in constants . values () : logger . warning ( ' {} is unknown. Consider using one of {} constants. (e.g. {}.LTE) ' . format ( speed_type , list ( constants . keys ()) , NetSpeed . __name__ )) self . execute ( Command . SET_NETWORK_SPEED , { ' netspeed ' : speed_type } ) return self set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_power_ac def set_power_ac ( self , ac_state ) Emulate power state change on the connected emulator. Android only. Args: ac_state (str): The power ac state to be set. Use .AC_OFF , .AC_ON Usage: self.driver.set_power_ac(Power.AC_OFF) self.driver.set_power_ac(Power.AC_ON) Returns: appium.webdriver.webdriver.WebDriver View Source def set_power_ac ( self , ac_state ) : \"\"\" Emulate power state change on the connected emulator. Android only . Args : ac_state ( str ) : The power ac state to be set . Use `. AC_OFF `, `. AC_ON ` Usage : self . driver . set_power_ac ( Power . AC_OFF ) self . driver . set_power_ac ( Power . AC_ON ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SET_POWER_AC , { ' state ' : ac_state } ) return self set_power_capacity def set_power_capacity ( self , percent ) Emulate power capacity change on the connected emulator. Android only. Args: percent (int): The power capacity to be set. Can be set from 0 to 100 Usage: self.driver.set_power_capacity(50) Returns: appium.webdriver.webdriver.WebDriver View Source def set_power_capacity ( self , percent ) : \"\"\" Emulate power capacity change on the connected emulator. Android only . Args : percent ( int ) : The power capacity to be set . Can be set from 0 to 100 Usage : self . driver . set_power_capacity ( 50 ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SET_POWER_CAPACITY , { ' percent ' : percent } ) return self set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_value def set_value ( self , element , value ) Set the value on an element in the application. Args: element ( appium.webdriver.webelement.WebElement : the element whose value will be set value (str): the value to set on the element Returns: appium.webdriver.webdriver.WebDriver View Source def set_value ( self , element , value ) : \"\"\" Set the value on an element in the application. Args : element ( ` appium . webdriver . webelement . WebElement `: the element whose value will be set value ( str ) : the value to set on the element Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' id ' : element . id , ' value ' : [ value ], } self . execute ( Command . SET_IMMEDIATE_VALUE , data ) return self set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) shake def shake ( self ) Shake the device. Returns: appium.webdriver.webdriver.WebDriver View Source def shake ( self ) : \"\"\" Shake the device. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SHAKE ) return self start_activity def start_activity ( self , app_package , app_activity , ** opts ) Opens an arbitrary activity during a test. If the activity belongs to another application, that application is started and the activity is opened. This is an Android-only method. Args: app_package (str): The package containing the activity to start. app_activity (str): The activity to start. Keyword Args: app_wait_package (str): Begin automation after this package starts. app_wait_activity (str): Begin automation after this activity starts. intent_action (str): Intent to start. intent_category (str): Intent category to start. intent_flags (str): Flags to send to the intent. optional_intent_arguments (str): Optional arguments to the intent. dont_stop_app_on_reset (str): Should the app be stopped on reset? View Source def start_activity ( self , app_package , app_activity , ** opts ) : \"\"\" Opens an arbitrary activity during a test. If the activity belongs to another application , that application is started and the activity is opened . This is an Android - only method . Args : app_package ( str ) : The package containing the activity to start . app_activity ( str ) : The activity to start . Keyword Args : app_wait_package ( str ) : Begin automation after this package starts . app_wait_activity ( str ) : Begin automation after this activity starts . intent_action ( str ) : Intent to start . intent_category ( str ) : Intent category to start . intent_flags ( str ) : Flags to send to the intent . optional_intent_arguments ( str ) : Optional arguments to the intent . dont_stop_app_on_reset ( str ) : Should the app be stopped on reset ? \"\"\" data = { ' appPackage ' : app_package , ' appActivity ' : app_activity } arguments = { ' app_wait_package ' : ' appWaitPackage ' , ' app_wait_activity ' : ' appWaitActivity ' , ' intent_action ' : ' intentAction ' , ' intent_category ' : ' intentCategory ' , ' intent_flags ' : ' intentFlags ' , ' optional_intent_arguments ' : ' optionalIntentArguments ' , ' dont_stop_app_on_reset ' : ' dontStopAppOnReset ' } for key , value in arguments . items () : if key in opts : data [ value ] = opts [ key ] self . execute ( Command . START_ACTIVITY , data ) return self start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_recording_screen def start_recording_screen ( self , ** options ) Start asynchronous screen recording process. Keyword Args: remotePath (str): The remotePath upload option is the path to the remote location, where the resulting video from the previous screen recording should be uploaded. The following protocols are supported: http/https (multipart), ftp. Missing value (the default setting) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value, but an exception will be thrown if the generated media file is too big to fit into the available process memory. This option only has an effect if there is/was an active screen recording session and forced restart is not enabled (the default setting). user (str): The name of the user for the remote authentication. Only has an effect if both remotePath and password are set. password (str): The password for the remote authentication. Only has an effect if both remotePath and user are set. method (str): The HTTP method name ('PUT'/'POST'). PUT method is used by default. Only has an effect if remotePath is set. timeLimit (int): The actual time limit of the recorded video in seconds. The default value for both iOS and Android is 180 seconds (3 minutes). The maximum value for Android is 3 minutes. The maximum value for iOS is 10 minutes. forcedRestart (bool): Whether to ignore the result of previous capture and start a new recording immediately ( True value). By default ( False ) the endpoint will try to catch and return the result of the previous capture if it's still available. bugReport (str): Makes the recorder to display an additional information on the video overlay, such as a timestamp, that is helpful in videos captured to illustrate bugs. This option is only supported since API level 27 (Android P). videoQuality ( str ) : [ iOS only ] The video encoding quality : ' low ' , ' medium ' , ' high ' , ' photo ' . Defaults to ' medium ' . videoType ( str ) : [ iOS only ] The format of the screen capture to be recorded . Available formats : Execute ` ffmpeg - codecs ` in the terminal to see the list of supported video codecs . ' mjpeg ' by default . ( Since Appium 1.10.0 ) videoFps ( int ) : [ iOS only ] The Frames Per Second rate of the recorded video . Change this value if the resulting video is too slow or too fast . Defaults to 10. This can decrease the resulting file size . videoFilters ( str ) : [ iOS only ] The FFMPEG video filters to apply . These filters allow to scale , flip , rotate and do many other useful transformations on the source video stream . The format of the property must comply with https : //ffmpeg.org/ffmpeg-filters.html. (Since Appium 1.15) videoScale ( str ) : [ iOS only ] The scaling value to apply . Read https : //trac.ffmpeg.org/wiki/Scaling for possible values. No scale is applied by default . If videoFilters are set then the scale setting is effectively ignored . ( Since Appium 1.10.0 ) pixelFormat ( str ) : [ iOS only ] Output pixel format . Run ` ffmpeg - pix_fmts ` to list possible values . For Quicktime compatibility , set to \"yuv420p\" along with videoType : \"libx264\" . ( Since Appium 1.12.0 ) videoSize ( str ) : [ Android only ] The video size of the generated media file . The format is WIDTHxHEIGHT . The default value is the device ' s native display resolution ( if supported ), 1280 x720 if not . For best results , use a size supported by your device ' s Advanced Video Coding ( AVC ) encoder . bitRate ( int ) : [ Android only ] The video bit rate for the video , in megabits per second . The default value is 4. You can increase the bit rate to improve video quality , but doing so results in larger movie files . Returns: bytes: Base-64 encoded content of the recorded media if stop_recording_screen isn't called after previous start_recording_screen . Otherwise returns an empty string. View Source def start_recording_screen ( self , ** options ) : \"\"\"Start asynchronous screen recording process. Keyword Args : remotePath ( str ) : The remotePath upload option is the path to the remote location , where the resulting video from the previous screen recording should be uploaded . The following protocols are supported : http / https ( multipart ), ftp . Missing value ( the default setting ) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value , but an exception will be thrown if the generated media file is too big to fit into the available process memory . This option only has an effect if there is / was an active screen recording session and forced restart is not enabled ( the default setting ). user ( str ) : The name of the user for the remote authentication . Only has an effect if both ` remotePath ` and ` password ` are set . password ( str ) : The password for the remote authentication . Only has an effect if both ` remotePath ` and ` user ` are set . method ( str ) : The HTTP method name ( ' PUT '/' POST ' ). PUT method is used by default . Only has an effect if ` remotePath ` is set . timeLimit ( int ) : The actual time limit of the recorded video in seconds . The default value for both iOS and Android is 180 seconds ( 3 minutes ). The maximum value for Android is 3 minutes . The maximum value for iOS is 10 minutes . forcedRestart ( bool ) : Whether to ignore the result of previous capture and start a new recording immediately ( ` True ` value ). By default ( ` False ` ) the endpoint will try to catch and return the result of the previous capture if it ' s still available . bugReport ( str ) : Makes the recorder to display an additional information on the video overlay , such as a timestamp , that is helpful in videos captured to illustrate bugs . This option is only supported since API level 27 ( Android P ). videoQuality ( str ) : [ iOS only ] The video encoding quality : ' low ' , ' medium ' , ' high ' , ' photo ' . Defaults to ' medium ' . videoType ( str ) : [ iOS only ] The format of the screen capture to be recorded . Available formats : Execute ` ffmpeg - codecs ` in the terminal to see the list of supported video codecs . ' mjpeg ' by default . ( Since Appium 1.10.0 ) videoFps ( int ) : [ iOS only ] The Frames Per Second rate of the recorded video . Change this value if the resulting video is too slow or too fast . Defaults to 10. This can decrease the resulting file size . videoFilters ( str ) : [ iOS only ] The FFMPEG video filters to apply . These filters allow to scale , flip , rotate and do many other useful transformations on the source video stream . The format of the property must comply with https : //ffmpeg.org/ffmpeg-filters.html. (Since Appium 1.15) videoScale ( str ) : [ iOS only ] The scaling value to apply . Read https : //trac.ffmpeg.org/wiki/Scaling for possible values. No scale is applied by default . If videoFilters are set then the scale setting is effectively ignored . ( Since Appium 1.10.0 ) pixelFormat ( str ) : [ iOS only ] Output pixel format . Run ` ffmpeg - pix_fmts ` to list possible values . For Quicktime compatibility , set to \"yuv420p\" along with videoType : \"libx264\" . ( Since Appium 1.12.0 ) videoSize ( str ) : [ Android only ] The video size of the generated media file . The format is WIDTHxHEIGHT . The default value is the device ' s native display resolution ( if supported ), 1280 x720 if not . For best results , use a size supported by your device ' s Advanced Video Coding ( AVC ) encoder . bitRate ( int ) : [ Android only ] The video bit rate for the video , in megabits per second . The default value is 4. You can increase the bit rate to improve video quality , but doing so results in larger movie files . Returns : bytes : Base - 64 encoded content of the recorded media if ` stop_recording_screen ` isn ' t called after previous ` start_recording_screen ` . Otherwise returns an empty string . \"\"\" if ' password ' in options : options [ ' pass ' ] = options [ ' password ' ] del options [ ' password ' ] return self . execute ( Command . START_RECORDING_SCREEN , { ' options ' : options })[ ' value ' ] start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. Override for Appium Args: automation_name: The name of automation engine to use. platform_name: The name of target platform. platform_version: The kind of mobile device or emulator to use app: The absolute local path or remote http URL to an .ipa or .apk file, or a .zip containing one of these. Read https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/caps.md for more details. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities. Override for Appium Args : automation_name : The name of automation engine to use . platform_name : The name of target platform . platform_version : The kind of mobile device or emulator to use app : The absolute local path or remote http URL to an . ipa or . apk file , or a . zip containing one of these . Read https : // github . com / appium / appium / blob / master / docs / en / writing - running - appium / caps . md for more details . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( ' Capabilities must be a dictionary ' ) if browser_profile : if ' moz:firefoxOptions ' in capabilities : capabilities [ ' moz:firefoxOptions ' ][ ' profile ' ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) parameters = self . _merge_capabilities ( capabilities ) response = self . execute ( RemoteCommand . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass stop_recording_screen def stop_recording_screen ( self , ** options ) Gather the output from the previously started screen recording to a media file. Keyword Args: remotePath (str): The remotePath upload option is the path to the remote location, where the resulting video should be uploaded. The following protocols are supported: http/https (multipart), ftp. Missing value (the default setting) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value, but an exception will be thrown if the generated media file is too big to fit into the available process memory. user (str): The name of the user for the remote authentication. Only has an effect if both remotePath and password are set. password (str): The password for the remote authentication. Only has an effect if both remotePath and user are set. method (str): The HTTP method name ('PUT'/'POST'). PUT method is used by default. Only has an effect if remotePath is set. Returns: bytes: Base-64 encoded content of the recorded media file or an empty string if the file has been successfully uploaded to a remote location (depends on the actual remotePath value). View Source def stop_recording_screen ( self , ** options ) : \"\"\" Gather the output from the previously started screen recording to a media file. Keyword Args : remotePath ( str ) : The remotePath upload option is the path to the remote location , where the resulting video should be uploaded . The following protocols are supported : http / https ( multipart ) , ftp . Missing value ( the default setting ) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value , but an exception will be thrown if the generated media file is too big to fit into the available process memory . user ( str ) : The name of the user for the remote authentication . Only has an effect if both ` remotePath ` and ` password ` are set . password ( str ) : The password for the remote authentication . Only has an effect if both ` remotePath ` and ` user ` are set . method ( str ) : The HTTP method name ( ' PUT ' / ' POST ' ) . PUT method is used by default . Only has an effect if ` remotePath ` is set . Returns : bytes : Base - 64 encoded content of the recorded media file or an empty string if the file has been successfully uploaded to a remote location ( depends on the actual ` remotePath ` value ) . \"\"\" if ' password ' in options : options [ ' pass ' ] = options [ ' password ' ] del options [ ' password ' ] return self . execute ( Command . STOP_RECORDING_SCREEN , { ' options ' : options } ) [ ' value ' ] swipe def swipe ( self , start_x , start_y , end_x , end_y , duration = None ) Swipe from one point to another point, for an optional duration. Args: start_x (int): x-coordinate at which to start start_y (int): y-coordinate at which to start end_x (int): x-coordinate at which to stop end_y (int): y-coordinate at which to stop duration (:obj: int , optional): time to take the swipe, in ms. Usage: driver.swipe(100, 100, 100, 400) Returns: appium.webdriver.webelement.WebElement View Source def swipe ( self , start_x , start_y , end_x , end_y , duration = None ) : \"\"\" Swipe from one point to another point, for an optional duration. Args : start_x ( int ) : x - coordinate at which to start start_y ( int ) : y - coordinate at which to start end_x ( int ) : x - coordinate at which to stop end_y ( int ) : y - coordinate at which to stop duration ( : obj :` int `, optional ) : time to take the swipe , in ms . Usage : driver . swipe ( 100 , 100 , 100 , 400 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" # ` swipe ` is something like press - wait - move_to - release , which the server # will translate into the correct action action = TouchAction ( self ) action \\ . press ( x = start_x , y = start_y ) \\ . wait ( ms = duration ) \\ . move_to ( x = end_x , y = end_y ) \\ . release () action . perform () return self switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name ) tap def tap ( self , positions , duration = None ) Taps on an particular place with up to five fingers, holding for a certain time Args: positions (:obj: list of :obj: tuple ): an array of tuples representing the x/y coordinates of the fingers to tap. Length can be up to five. duration (:obj: int , optional): length of time to tap, in ms Usage: driver.tap([(100, 20), (100, 60), (100, 100)], 500) Returns: appium.webdriver.webelement.WebElement View Source def tap ( self , positions , duration = None ) : \"\"\" Taps on an particular place with up to five fingers, holding for a certain time Args : positions ( : obj :` list ` of : obj :` tuple ` ) : an array of tuples representing the x / y coordinates of the fingers to tap . Length can be up to five . duration ( : obj :` int `, optional ) : length of time to tap , in ms Usage : driver . tap ( [ ( 100 , 20 ) , ( 100 , 60 ) , ( 100 , 100 ) ], 500 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" if len ( positions ) == 1 : action = TouchAction ( self ) x = positions [ 0 ][ 0 ] y = positions [ 0 ][ 1 ] if duration : action . long_press ( x = x , y = y , duration = duration ) . release () else : action . tap ( x = x , y = y ) action . perform () else : ma = MultiAction ( self ) for position in positions : x = position [ 0 ] y = position [ 1 ] action = TouchAction ( self ) if duration : action . long_press ( x = x , y = y , duration = duration ) . release () else : action . press ( x = x , y = y ) . release () ma . add ( action ) ma . perform () return self terminate_app def terminate_app ( self , app_id , ** options ) Terminates the application if it is running. Args: app_id (str): the application id to be terminates Keyword Args: timeout (int): [Android only] how much time to wait for the uninstall to complete. 500ms by default. Returns: bool: True if the app has been successfully terminated View Source def terminate_app ( self , app_id , ** options ) : \"\"\"Terminates the application if it is running. Args : app_id ( str ) : the application id to be terminates Keyword Args : ` timeout ` ( int ) : [ Android only ] how much time to wait for the uninstall to complete . 500 ms by default . Returns : bool : True if the app has been successfully terminated \"\"\" data = { ' appId ' : app_id , } if options : data . update ({ ' options ' : options }) return self . execute ( Command . TERMINATE_APP , data )[ ' value ' ] toggle_location_services def toggle_location_services ( self ) Toggle the location services on the device. Android only. Returns: appium.webdriver.webdriver.WebDriver View Source def toggle_location_services ( self ) : \"\"\" Toggle the location services on the device. Android only . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . TOGGLE_LOCATION_SERVICES , {} ) return self toggle_touch_id_enrollment def toggle_touch_id_enrollment ( self ) Toggle enroll touchId on iOS Simulator Returns: appium.webdriver.webdriver.WebDriver View Source def toggle_touch_id_enrollment ( self ) : \"\"\" Toggle enroll touchId on iOS Simulator Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . TOGGLE_TOUCH_ID_ENROLLMENT ) return self toggle_wifi def toggle_wifi ( self ) Toggle the wifi on the device, Android only. Returns: appium.webdriver.webdriver.WebDriver View Source def toggle_wifi ( self ) : \"\"\" Toggle the wifi on the device, Android only. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . TOGGLE_WIFI , {} ) return self touch_id def touch_id ( self , match ) Simulate touchId on iOS Simulator Args: match (bool): Simulates a successful touch ( True ) or a failed touch ( False ) Returns: appium.webdriver.webdriver.WebDriver View Source def touch_id ( self , match ) : \"\"\" Simulate touchId on iOS Simulator Args : match ( bool ) : Simulates a successful touch ( ` True ` ) or a failed touch ( ` False ` ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' match ' : match } self . execute ( Command . TOUCH_ID , data ) return self unlock def unlock ( self ) Unlock the device. No changes are made if the device is already locked. Returns: appium.webdriver.webdriver.WebDriver View Source def unlock ( self ) : \"\"\" Unlock the device. No changes are made if the device is already locked. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . UNLOCK ) return self update_settings def update_settings ( self , settings ) Set settings for the current session. For more on settings, see: https://github.com/appium/appium/blob/master/docs/en/advanced-concepts/settings.md Args: settings (dict): dictionary of settings to apply to the current test session View Source def update_settings ( self , settings ) : \"\"\" Set settings for the current session. For more on settings , see : https : // github . com / appium / appium / blob / master / docs / en / advanced - concepts / settings . md Args : settings ( dict ) : dictionary of settings to apply to the current test session \"\"\" data = { \" settings \" : settings } self . execute ( Command . UPDATE_SETTINGS , data ) return self wait_activity def wait_activity ( self , activity , timeout , interval = 1 ) Wait for an activity: block until target activity presents or time out. This is an Android-only method. Args: activity (str): target activity timeout (int): max wait time, in seconds interval (int): sleep interval between retries, in seconds View Source def wait_activity ( self , activity , timeout , interval = 1 ) : \"\"\" Wait for an activity: block until target activity presents or time out. This is an Android - only method . Args : activity ( str ) : target activity timeout ( int ) : max wait time , in seconds interval ( int ) : sleep interval between retries , in seconds \"\"\" try : WebDriverWait ( self , timeout , interval ) . until ( lambda d : d . current_activity == activity ) return True except TimeoutException : return False","title":"Webdriver"},{"location":"reference/appium/webdriver/webdriver/#module-appiumwebdriverwebdriver","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # pylint: disable=too-many-lines,too-many-public-methods,too-many-statements,no-self-use import base64 import copy from selenium.common.exceptions import InvalidArgumentException from selenium.webdriver.common.by import By from selenium.webdriver.remote.command import Command as RemoteCommand from selenium.webdriver.remote.remote_connection import RemoteConnection from appium.common.logger import logger from appium.webdriver.common.mobileby import MobileBy from .appium_connection import AppiumConnection from .errorhandler import MobileErrorHandler from .extensions.action_helpers import ActionHelpers from .extensions.android.activities import Activities from .extensions.android.display import Display from .extensions.android.gsm import Gsm from .extensions.android.network import Network from .extensions.android.performance import Performance from .extensions.android.power import Power from .extensions.android.sms import Sms from .extensions.android.system_bars import SystemBars from .extensions.applications import Applications from .extensions.clipboard import Clipboard from .extensions.context import Context from .extensions.device_time import DeviceTime from .extensions.execute_driver import ExecuteDriver from .extensions.hw_actions import HardwareActions from .extensions.images_comparison import ImagesComparison from .extensions.ime import IME from .extensions.keyboard import Keyboard from .extensions.location import Location from .extensions.remote_fs import RemoteFS from .extensions.screen_record import ScreenRecord from .extensions.search_context import AppiumSearchContext from .extensions.settings import Settings from .mobilecommand import MobileCommand as Command from .switch_to import MobileSwitchTo from .webelement import WebElement as MobileWebElement # From remote/webdriver.py _W3C_CAPABILITY_NAMES = frozenset ([ 'acceptInsecureCerts' , 'browserName' , 'browserVersion' , 'platformName' , 'pageLoadStrategy' , 'proxy' , 'setWindowRect' , 'timeouts' , 'unhandledPromptBehavior' , ]) # From remote/webdriver.py _OSS_W3C_CONVERSION = { 'acceptSslCerts' : 'acceptInsecureCerts' , 'version' : 'browserVersion' , 'platform' : 'platformName' } _EXTENSION_CAPABILITY = ':' _FORCE_MJSONWP = 'forceMjsonwp' # override # Add appium prefix for the non-W3C capabilities def _make_w3c_caps ( caps ): appium_prefix = 'appium:' caps = copy . deepcopy ( caps ) profile = caps . get ( 'firefox_profile' ) first_match = {} if caps . get ( 'proxy' ) and caps [ 'proxy' ] . get ( 'proxyType' ): caps [ 'proxy' ][ 'proxyType' ] = caps [ 'proxy' ][ 'proxyType' ] . lower () for k , v in caps . items (): if v and k in _OSS_W3C_CONVERSION : first_match [ _OSS_W3C_CONVERSION [ k ]] = v . lower () if k == 'platform' else v if k in _W3C_CAPABILITY_NAMES or _EXTENSION_CAPABILITY in k : first_match [ k ] = v else : if not k . startswith ( appium_prefix ): first_match [ appium_prefix + k ] = v if profile : moz_opts = first_match . get ( 'moz:firefoxOptions' , {}) # If it's already present, assume the caller did that intentionally. if 'profile' not in moz_opts : # Don't mutate the original capabilities. new_opts = copy . deepcopy ( moz_opts ) new_opts [ 'profile' ] = profile first_match [ 'moz:firefoxOptions' ] = new_opts return { 'firstMatch' : [ first_match ]} class WebDriver ( AppiumSearchContext , ActionHelpers , Activities , Applications , Clipboard , Context , DeviceTime , Display , ExecuteDriver , Gsm , HardwareActions , ImagesComparison , IME , Keyboard , Location , Network , Performance , Power , RemoteFS , ScreenRecord , Settings , Sms , SystemBars ): def __init__ ( self , command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = True , direct_connection = False ): super ( WebDriver , self ) . __init__ ( AppiumConnection ( command_executor , keep_alive = keep_alive ), desired_capabilities , browser_profile , proxy ) if hasattr ( self , 'command_executor' ): self . _addCommands () self . error_handler = MobileErrorHandler () self . _switch_to = MobileSwitchTo ( self ) if direct_connection : self . _update_command_executor ( keep_alive = keep_alive ) # add new method to the `find_by_*` pantheon By . IOS_UIAUTOMATION = MobileBy . IOS_UIAUTOMATION By . IOS_PREDICATE = MobileBy . IOS_PREDICATE By . IOS_CLASS_CHAIN = MobileBy . IOS_CLASS_CHAIN By . ANDROID_UIAUTOMATOR = MobileBy . ANDROID_UIAUTOMATOR By . ANDROID_VIEWTAG = MobileBy . ANDROID_VIEWTAG By . ACCESSIBILITY_ID = MobileBy . ACCESSIBILITY_ID By . IMAGE = MobileBy . IMAGE By . CUSTOM = MobileBy . CUSTOM def _update_command_executor ( self , keep_alive ): \"\"\"Update command executor following directConnect feature\"\"\" direct_protocol = 'directConnectProtocol' direct_host = 'directConnectHost' direct_port = 'directConnectPort' direct_path = 'directConnectPath' if ( not { direct_protocol , direct_host , direct_port , direct_path } . issubset ( set ( self . capabilities ))): message = 'Direct connect capabilities from server were: \\n ' for key in [ direct_protocol , direct_host , direct_port , direct_path ]: message += '{}: \\' {} \\'\\n ' . format ( key , self . capabilities . get ( key , '' )) logger . warning ( message ) return protocol = self . capabilities [ direct_protocol ] hostname = self . capabilities [ direct_host ] port = self . capabilities [ direct_port ] path = self . capabilities [ direct_path ] executor = '{scheme}://{hostname}:{port}{path}' . format ( scheme = protocol , hostname = hostname , port = port , path = path ) logger . info ( 'Updated request endpoint to %s ' , executor ) # Override command executor self . command_executor = RemoteConnection ( executor , keep_alive = keep_alive ) self . _addCommands () def start_session ( self , capabilities , browser_profile = None ): \"\"\"Creates a new session with the desired capabilities. Override for Appium Args: automation_name: The name of automation engine to use. platform_name: The name of target platform. platform_version: The kind of mobile device or emulator to use app: The absolute local path or remote http URL to an .ipa or .apk file, or a .zip containing one of these. Read https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/caps.md for more details. \"\"\" if not isinstance ( capabilities , dict ): raise InvalidArgumentException ( 'Capabilities must be a dictionary' ) if browser_profile : if 'moz:firefoxOptions' in capabilities : capabilities [ 'moz:firefoxOptions' ][ 'profile' ] = browser_profile . encoded else : capabilities . update ({ 'firefox_profile' : browser_profile . encoded }) parameters = self . _merge_capabilities ( capabilities ) response = self . execute ( RemoteCommand . NEW_SESSION , parameters ) if 'sessionId' not in response : response = response [ 'value' ] self . session_id = response [ 'sessionId' ] self . capabilities = response . get ( 'value' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( 'capabilities' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( 'status' ) is None self . command_executor . w3c = self . w3c def _merge_capabilities ( self , capabilities ): \"\"\"Manage capabilities whether W3C format or MJSONWP format \"\"\" if _FORCE_MJSONWP in capabilities : force_mjsonwp = capabilities [ _FORCE_MJSONWP ] del capabilities [ _FORCE_MJSONWP ] if force_mjsonwp != False : return { 'desiredCapabilities' : capabilities } w3c_caps = _make_w3c_caps ( capabilities ) return { 'capabilities' : w3c_caps , 'desiredCapabilities' : capabilities } def find_element ( self , by = By . ID , value = None ): \"\"\"'Private' method used by the find_element_by_* methods. Override for Appium Usage: Use the corresponding find_element_by_* instead of this. Returns: `appium.webdriver.webelement.WebElement` :rtype: `MobileWebElement` \"\"\" # TODO: If we need, we should enable below converter for Web context # if self.w3c: # if by == By.ID: # by = By.CSS_SELECTOR # value = '[id=\"%s\"]' % value # elif by == By.TAG_NAME: # by = By.CSS_SELECTOR # elif by == By.CLASS_NAME: # by = By.CSS_SELECTOR # value = \".%s\" % value # elif by == By.NAME: # by = By.CSS_SELECTOR # value = '[name=\"%s\"]' % value return self . execute ( RemoteCommand . FIND_ELEMENT , { 'using' : by , 'value' : value })[ 'value' ] def find_elements ( self , by = By . ID , value = None ): \"\"\"'Private' method used by the find_elements_by_* methods. Override for Appium Usage: Use the corresponding find_elements_by_* instead of this. Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` :rtype: list of `MobileWebElement` \"\"\" # TODO: If we need, we should enable below converter for Web context # if self.w3c: # if by == By.ID: # by = By.CSS_SELECTOR # value = '[id=\"%s\"]' % value # elif by == By.TAG_NAME: # by = By.CSS_SELECTOR # elif by == By.CLASS_NAME: # by = By.CSS_SELECTOR # value = \".%s\" % value # elif by == By.NAME: # by = By.CSS_SELECTOR # value = '[name=\"%s\"]' % value # Return empty list if driver returns null # See https://github.com/SeleniumHQ/selenium/issues/4555 return self . execute ( RemoteCommand . FIND_ELEMENTS , { 'using' : by , 'value' : value })[ 'value' ] or [] def find_element_by_ios_uiautomation ( self , uia_string ): \"\"\"Finds an element by uiautomation in iOS. Args: uia_string (str): The element name in the iOS UIAutomation library Usage: driver.find_element_by_ios_uiautomation('.elements()[1].cells()[2]') Returns: `appium.webdriver.webelement.WebElement` :rtype: `MobileWebElement` \"\"\" return self . find_element ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string ) def find_elements_by_ios_uiautomation ( self , uia_string ): \"\"\"Finds elements by uiautomation in iOS. Args: uia_string: The element name in the iOS UIAutomation library Usage: driver.find_elements_by_ios_uiautomation('.elements()[1].cells()[2]') Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` :rtype: list of `MobileWebElement` \"\"\" return self . find_elements ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string ) def find_element_by_ios_predicate ( self , predicate_string ): \"\"\"Find an element by ios predicate string. Args: predicate_string (str): The predicate string Usage: driver.find_element_by_ios_predicate('label == \"myLabel\"') Returns: `appium.webdriver.webelement.WebElement` :rtype: `MobileWebElement` \"\"\" return self . find_element ( by = MobileBy . IOS_PREDICATE , value = predicate_string ) def find_elements_by_ios_predicate ( self , predicate_string ): \"\"\"Finds elements by ios predicate string. Args: predicate_string (str): The predicate string Usage: driver.find_elements_by_ios_predicate('label == \"myLabel\"') Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` :rtype: list of `MobileWebElement` \"\"\" return self . find_elements ( by = MobileBy . IOS_PREDICATE , value = predicate_string ) def find_element_by_ios_class_chain ( self , class_chain_string ): \"\"\"Find an element by ios class chain string. Args: class_chain_string (str): The class chain string Usage: driver.find_element_by_ios_class_chain('XCUIElementTypeWindow/XCUIElementTypeButton[3]') Returns: `appium.webdriver.webelement.WebElement` :rtype: `MobileWebElement` \"\"\" return self . find_element ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string ) def find_elements_by_ios_class_chain ( self , class_chain_string ): \"\"\"Finds elements by ios class chain string. Args: class_chain_string (str): The class chain string Usage: driver.find_elements_by_ios_class_chain('XCUIElementTypeWindow[2]/XCUIElementTypeAny[-2]') Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` :rtype: list of `MobileWebElement` \"\"\" return self . find_elements ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string ) def find_element_by_android_uiautomator ( self , uia_string ): \"\"\"Finds element by uiautomator in Android. Args: uia_string: The element name in the Android UIAutomator library Usage: driver.find_element_by_android_uiautomator('.elements()[1].cells()[2]') Returns: `appium.webdriver.webelement.WebElement` :rtype: `MobileWebElement` \"\"\" return self . find_element ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string ) def find_elements_by_android_uiautomator ( self , uia_string ): \"\"\"Finds elements by uiautomator in Android. Args: uia_string (str): The element name in the Android UIAutomator library Usage: driver.find_elements_by_android_uiautomator('.elements()[1].cells()[2]') Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` :rtype: list of `MobileWebElement` \"\"\" return self . find_elements ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string ) def find_element_by_android_viewtag ( self , tag ): \"\"\"Finds element by [View#tags](https://developer.android.com/reference/android/view/View#tags) in Android. It works with [Espresso Driver](https://github.com/appium/appium-espresso-driver). Args: tag (str): The tag name of the view to look for Usage: driver.find_element_by_android_viewtag('a tag name') Returns: `appium.webdriver.webelement.WebElement` :rtype: `MobileWebElement` \"\"\" return self . find_element ( by = MobileBy . ANDROID_VIEWTAG , value = tag ) def find_elements_by_android_viewtag ( self , tag ): \"\"\"Finds element by [View#tags](https://developer.android.com/reference/android/view/View#tags) in Android. It works with [Espresso Driver](https://github.com/appium/appium-espresso-driver). Args: tag (str): The tag name of the view to look for Usage: driver.find_elements_by_android_viewtag('a tag name') Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` :rtype: list of `MobileWebElement` \"\"\" return self . find_elements ( by = MobileBy . ANDROID_VIEWTAG , value = tag ) def find_element_by_image ( self , img_path ): \"\"\"Finds a portion of a screenshot by an image. Uses driver.find_image_occurrence under the hood. Args: img_path (str): a string corresponding to the path of a image Returns: `appium.webdriver.webelement.WebElement` :rtype: `MobileWebElement` \"\"\" with open ( img_path , 'rb' ) as i_file : b64_data = base64 . b64encode ( i_file . read ()) . decode ( 'UTF-8' ) return self . find_element ( by = MobileBy . IMAGE , value = b64_data ) def find_elements_by_image ( self , img_path ): \"\"\"Finds a portion of a screenshot by an image. Uses driver.find_image_occurrence under the hood. Note that this will only ever return at most one element Args: img_path (str): a string corresponding to the path of a image Return: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` :rtype: list of `MobileWebElement` \"\"\" with open ( img_path , 'rb' ) as i_file : b64_data = base64 . b64encode ( i_file . read ()) . decode ( 'UTF-8' ) return self . find_elements ( by = MobileBy . IMAGE , value = b64_data ) def find_element_by_accessibility_id ( self , accessibility_id ): \"\"\"Finds an element by accessibility id. Args: accessibility_id (str): A string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize Usage: driver.find_element_by_accessibility_id() Returns: `appium.webdriver.webelement.WebElement` :rtype: `MobileWebElement` \"\"\" return self . find_element ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id ) def find_elements_by_accessibility_id ( self , accessibility_id ): \"\"\"Finds elements by accessibility id. Args: accessibility_id (str): a string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize Usage: driver.find_elements_by_accessibility_id() Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` :rtype: list of `MobileWebElement` \"\"\" return self . find_elements ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id ) def find_element_by_custom ( self , selector ): \"\"\"Finds an element in conjunction with a custom element finding plugin Args: selector (str): a string of the form \"module:selector\", where \"module\" is the shortcut name given in the customFindModules capability, and \"selector\" is the string that will be passed to the custom element finding plugin itself Usage: driver.find_element_by_custom(\"foo:bar\") Returns: `appium.webdriver.webelement.WebElement` :rtype: `MobileWebElement` \"\"\" return self . find_element ( by = MobileBy . CUSTOM , value = selector ) def find_elements_by_custom ( self , selector ): \"\"\"Finds elements in conjunction with a custom element finding plugin Args: selector: a string of the form \"module:selector\", where \"module\" is the shortcut name given in the customFindModules capability, and \"selector\" is the string that will be passed to the custom element finding plugin itself Usage: driver.find_elements_by_custom(\"foo:bar\") Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` :rtype: list of `MobileWebElement` \"\"\" return self . find_elements ( by = MobileBy . CUSTOM , value = selector ) def create_web_element ( self , element_id , w3c = False ): \"\"\"Creates a web element with the specified element_id. Overrides method in Selenium WebDriver in order to always give them Appium WebElement Args: element_id (int): The element id to create a web element w3c (bool): Whether the element is W3C or MJSONWP Returns: `MobileWebElement` \"\"\" return MobileWebElement ( self , element_id , w3c ) def press_button ( self , button_name ): \"\"\"Sends a physical button name to the device to simulate the user pressing. iOS only. Possible button names can be found in https://github.com/appium/WebDriverAgent/blob/master/WebDriverAgentLib/Categories/XCUIDevice%2BFBHelpers.h Args: button_name (str): the button name to be sent to the device Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'name' : button_name } self . execute_script ( 'mobile: pressButton' , data ) return self @property def current_package ( self ): \"\"\"Retrieves the current package running on the device. \"\"\" return self . execute ( Command . GET_CURRENT_PACKAGE )[ 'value' ] def set_value ( self , element , value ): \"\"\"Set the value on an element in the application. Args: element (`appium.webdriver.webelement.WebElement`: the element whose value will be set value (str): the value to set on the element Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'id' : element . id , 'value' : [ value ], } self . execute ( Command . SET_IMMEDIATE_VALUE , data ) return self def end_test_coverage ( self , intent , path ): \"\"\"Ends the coverage collection and pull the coverage.ec file from the device. Android only. See https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/android/android-coverage.md Args: intent (str): description of operation to be performed path (str): path to coverage.ec file to be pulled from the device Returns: TODO \"\"\" data = { 'intent' : intent , 'path' : path , } return self . execute ( Command . END_TEST_COVERAGE , data )[ 'value' ] def open_notifications ( self ): \"\"\"Open notification shade in Android (API Level 18 and above) Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . OPEN_NOTIFICATIONS , {}) return self @property def battery_info ( self ): \"\"\"Retrieves battery information for the device under test. Returns: A dictionary containing the following entries level: Battery level in range [0.0, 1.0], where 1.0 means 100% charge. Any value lower than 0 means the level cannot be retrieved state: Platform-dependent battery state value. On iOS (XCUITest): 1: Unplugged 2: Charging 3: Full Any other value means the state cannot be retrieved On Android (UIAutomator2): 2: Charging 3: Discharging 4: Not charging 5: Full Any other value means the state cannot be retrieved \"\"\" return self . execute_script ( 'mobile: batteryInfo' ) @property def session ( self ): \"\"\" Retrieves session information from the current session Usage: session = driver.session Returns: `dict containing information from the current session` \"\"\" return self . execute ( Command . GET_SESSION )[ 'value' ] @property def events ( self ): \"\"\" Retrieves events information from the current session Usage: events = driver.events Returns: `dict containing events timing information from the current session` \"\"\" try : session = self . session return session [ 'events' ] except Exception as e : logger . warning ( 'Could not find events information in the session. Error:' , e ) return {} # pylint: disable=protected-access def _addCommands ( self ): # call the overridden command binders from all mixin classes except for # appium.webdriver.webdriver.WebDriver and its sub-classes # https://github.com/appium/python-client/issues/342 for mixin_class in filter ( lambda x : not issubclass ( x , WebDriver ), self . __class__ . __mro__ ): if hasattr ( mixin_class , self . _addCommands . __name__ ): getattr ( mixin_class , self . _addCommands . __name__ , None )( self ) self . command_executor . _commands [ Command . GET_SESSION ] = \\ ( 'GET' , '/session/$sessionId' ) self . command_executor . _commands [ Command . TOUCH_ACTION ] = \\ ( 'POST' , '/session/$sessionId/touch/perform' ) self . command_executor . _commands [ Command . MULTI_ACTION ] = \\ ( 'POST' , '/session/$sessionId/touch/multi/perform' ) self . command_executor . _commands [ Command . GET_CURRENT_PACKAGE ] = \\ ( 'GET' , '/session/$sessionId/appium/device/current_package' ) self . command_executor . _commands [ Command . SET_IMMEDIATE_VALUE ] = \\ ( 'POST' , '/session/$sessionId/appium/element/$id/value' ) self . command_executor . _commands [ Command . LAUNCH_APP ] = \\ ( 'POST' , '/session/$sessionId/appium/app/launch' ) self . command_executor . _commands [ Command . CLOSE_APP ] = \\ ( 'POST' , '/session/$sessionId/appium/app/close' ) self . command_executor . _commands [ Command . END_TEST_COVERAGE ] = \\ ( 'POST' , '/session/$sessionId/appium/app/end_test_coverage' ) self . command_executor . _commands [ Command . OPEN_NOTIFICATIONS ] = \\ ( 'POST' , '/session/$sessionId/appium/device/open_notifications' ) self . command_executor . _commands [ Command . REPLACE_KEYS ] = \\ ( 'POST' , '/session/$sessionId/appium/element/$id/replace_value' ) self . command_executor . _commands [ Command . LOCATION_IN_VIEW ] = \\ ( 'GET' , '/session/$sessionId/element/$id/location_in_view' ) self . command_executor . _commands [ Command . CLEAR ] = \\ ( 'POST' , '/session/$sessionId/element/$id/clear' )","title":"Module appium.webdriver.webdriver"},{"location":"reference/appium/webdriver/webdriver/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/webdriver/#webdriver","text":"class WebDriver ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = True , direct_connection = False ) Returns appium driver search conext View Source class WebDriver ( AppiumSearchContext , ActionHelpers , Activities , Applications , Clipboard , Context , DeviceTime , Display , ExecuteDriver , Gsm , HardwareActions , ImagesComparison , IME , Keyboard , Location , Network , Performance , Power , RemoteFS , ScreenRecord , Settings , Sms , SystemBars ) : def __init__ ( self , command_executor = ' http : //127.0.0.1:4444/wd/hub', desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = True , direct_connection = False ) : super ( WebDriver , self ). __init__ ( AppiumConnection ( command_executor , keep_alive = keep_alive ), desired_capabilities , browser_profile , proxy ) if hasattr ( self , ' command_executor ' ) : self . _addCommands () self . error_handler = MobileErrorHandler () self . _switch_to = MobileSwitchTo ( self ) if direct_connection : self . _update_command_executor ( keep_alive = keep_alive ) # add new method to the `find_by_*` pantheon By . IOS_UIAUTOMATION = MobileBy . IOS_UIAUTOMATION By . IOS_PREDICATE = MobileBy . IOS_PREDICATE By . IOS_CLASS_CHAIN = MobileBy . IOS_CLASS_CHAIN By . ANDROID_UIAUTOMATOR = MobileBy . ANDROID_UIAUTOMATOR By . ANDROID_VIEWTAG = MobileBy . ANDROID_VIEWTAG By . ACCESSIBILITY_ID = MobileBy . ACCESSIBILITY_ID By . IMAGE = MobileBy . IMAGE By . CUSTOM = MobileBy . CUSTOM def _update_command_executor ( self , keep_alive ) : \"\"\"Update command executor following directConnect feature\"\"\" direct_protocol = ' directConnectProtocol ' direct_host = ' directConnectHost ' direct_port = ' directConnectPort ' direct_path = ' directConnectPath ' if ( not { direct_protocol , direct_host , direct_port , direct_path }. issubset ( set ( self . capabilities ))) : message = ' Direct connect capabilities from server were : \\ n ' for key in [ direct_protocol , direct_host , direct_port , direct_path ] : message += ' {} : \\' {} \\ '\\n' . format ( key , self . capabilities . get ( key , '' )) logger . warning ( message ) return protocol = self . capabilities [ direct_protocol ] hostname = self . capabilities [ direct_host ] port = self . capabilities [ direct_port ] path = self . capabilities [ direct_path ] executor = ' { scheme } : //{hostname}:{port}{path}'.format( scheme = protocol , hostname = hostname , port = port , path = path ) logger . info ( ' Updated request endpoint to % s ' , executor ) # Override command executor self . command_executor = RemoteConnection ( executor , keep_alive = keep_alive ) self . _addCommands () def start_session ( self , capabilities , browser_profile = None ) : \"\"\"Creates a new session with the desired capabilities. Override for Appium Args : automation_name : The name of automation engine to use . platform_name : The name of target platform . platform_version : The kind of mobile device or emulator to use app : The absolute local path or remote http URL to an . ipa or . apk file , or a . zip containing one of these . Read https : //github.com/appium/appium/blob/master/docs/en/writing-running-appium/caps.md for more details. \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( ' Capabilities must be a dictionary ' ) if browser_profile : if ' moz : firefoxOptions ' in capabilities : capabilities [ ' moz : firefoxOptions ' ][ ' profile ' ] = browser_profile . encoded else : capabilities . update ({ ' firefox_profile ' : browser_profile . encoded }) parameters = self . _merge_capabilities ( capabilities ) response = self . execute ( RemoteCommand . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c def _merge_capabilities ( self , capabilities ) : \"\"\"Manage capabilities whether W3C format or MJSONWP format \"\"\" if _FORCE_MJSONWP in capabilities : force_mjsonwp = capabilities [ _FORCE_MJSONWP ] del capabilities [ _FORCE_MJSONWP ] if force_mjsonwp != False : return { ' desiredCapabilities ' : capabilities } w3c_caps = _make_w3c_caps ( capabilities ) return { ' capabilities ' : w3c_caps , ' desiredCapabilities ' : capabilities } def find_element ( self , by = By . ID , value = None ) : \"\"\"'Private' method used by the find_element_by_* methods. Override for Appium Usage : Use the corresponding find_element_by_ * instead of this . Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" # TODO: If we need, we should enable below converter for Web context # if self.w3c: # if by == By.ID: # by = By.CSS_SELECTOR # value = '[id=\"%s\"]' % value # elif by == By.TAG_NAME: # by = By.CSS_SELECTOR # elif by == By.CLASS_NAME: # by = By.CSS_SELECTOR # value = \".%s\" % value # elif by == By.NAME: # by = By.CSS_SELECTOR # value = '[name=\"%s\"]' % value return self . execute ( RemoteCommand . FIND_ELEMENT , { ' using ' : by , ' value ' : value })[ ' value ' ] def find_elements ( self , by = By . ID , value = None ) : \"\"\"'Private' method used by the find_elements_by_* methods. Override for Appium Usage : Use the corresponding find_elements_by_ * instead of this . Returns : : obj : ` list ` of : obj : ` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" # TODO: If we need, we should enable below converter for Web context # if self.w3c: # if by == By.ID: # by = By.CSS_SELECTOR # value = '[id=\"%s\"]' % value # elif by == By.TAG_NAME: # by = By.CSS_SELECTOR # elif by == By.CLASS_NAME: # by = By.CSS_SELECTOR # value = \".%s\" % value # elif by == By.NAME: # by = By.CSS_SELECTOR # value = '[name=\"%s\"]' % value # Return empty list if driver returns null # See https: //github.com/SeleniumHQ/selenium/issues/4555 return self . execute ( RemoteCommand . FIND_ELEMENTS , { ' using ' : by , ' value ' : value })[ ' value ' ] or [] def find_element_by_ios_uiautomation ( self , uia_string ) : \"\"\"Finds an element by uiautomation in iOS. Args : uia_string ( str ) : The element name in the iOS UIAutomation library Usage : driver . find_element_by_ios_uiautomation ( ' . elements ()[ 1 ]. cells ()[ 2 ] ' ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string ) def find_elements_by_ios_uiautomation ( self , uia_string ) : \"\"\"Finds elements by uiautomation in iOS. Args : uia_string : The element name in the iOS UIAutomation library Usage : driver . find_elements_by_ios_uiautomation ( ' . elements ()[ 1 ]. cells ()[ 2 ] ' ) Returns : : obj : ` list ` of : obj : ` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string ) def find_element_by_ios_predicate ( self , predicate_string ) : \"\"\"Find an element by ios predicate string. Args : predicate_string ( str ) : The predicate string Usage : driver . find_element_by_ios_predicate ( ' label == \"myLabel\" ' ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_PREDICATE , value = predicate_string ) def find_elements_by_ios_predicate ( self , predicate_string ) : \"\"\"Finds elements by ios predicate string. Args : predicate_string ( str ) : The predicate string Usage : driver . find_elements_by_ios_predicate ( ' label == \"myLabel\" ' ) Returns : : obj : ` list ` of : obj : ` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_PREDICATE , value = predicate_string ) def find_element_by_ios_class_chain ( self , class_chain_string ) : \"\"\"Find an element by ios class chain string. Args : class_chain_string ( str ) : The class chain string Usage : driver . find_element_by_ios_class_chain ( ' XCUIElementTypeWindow / XCUIElementTypeButton [ 3 ] ' ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string ) def find_elements_by_ios_class_chain ( self , class_chain_string ) : \"\"\"Finds elements by ios class chain string. Args : class_chain_string ( str ) : The class chain string Usage : driver . find_elements_by_ios_class_chain ( ' XCUIElementTypeWindow [ 2 ] / XCUIElementTypeAny [ - 2 ] ' ) Returns : : obj : ` list ` of : obj : ` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string ) def find_element_by_android_uiautomator ( self , uia_string ) : \"\"\"Finds element by uiautomator in Android. Args : uia_string : The element name in the Android UIAutomator library Usage : driver . find_element_by_android_uiautomator ( ' . elements ()[ 1 ]. cells ()[ 2 ] ' ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string ) def find_elements_by_android_uiautomator ( self , uia_string ) : \"\"\"Finds elements by uiautomator in Android. Args : uia_string ( str ) : The element name in the Android UIAutomator library Usage : driver . find_elements_by_android_uiautomator ( ' . elements ()[ 1 ]. cells ()[ 2 ] ' ) Returns : : obj : ` list ` of : obj : ` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string ) def find_element_by_android_viewtag ( self , tag ) : \"\"\"Finds element by [View#tags](https://developer.android.com/reference/android/view/View#tags) in Android. It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : tag ( str ) : The tag name of the view to look for Usage : driver . find_element_by_android_viewtag ( ' a tag name ' ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . ANDROID_VIEWTAG , value = tag ) def find_elements_by_android_viewtag ( self , tag ) : \"\"\"Finds element by [View#tags](https://developer.android.com/reference/android/view/View#tags) in Android. It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : tag ( str ) : The tag name of the view to look for Usage : driver . find_elements_by_android_viewtag ( ' a tag name ' ) Returns : : obj : ` list ` of : obj : ` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . ANDROID_VIEWTAG , value = tag ) def find_element_by_image ( self , img_path ) : \"\"\"Finds a portion of a screenshot by an image. Uses driver . find_image_occurrence under the hood . Args : img_path ( str ) : a string corresponding to the path of a image Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" with open ( img_path , ' rb ' ) as i_file : b64_data = base64 . b64encode ( i_file . read ()). decode ( ' UTF - 8 ' ) return self . find_element ( by = MobileBy . IMAGE , value = b64_data ) def find_elements_by_image ( self , img_path ) : \"\"\"Finds a portion of a screenshot by an image. Uses driver . find_image_occurrence under the hood . Note that this will only ever return at most one element Args : img_path ( str ) : a string corresponding to the path of a image Return : : obj : ` list ` of : obj : ` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" with open ( img_path , ' rb ' ) as i_file : b64_data = base64 . b64encode ( i_file . read ()). decode ( ' UTF - 8 ' ) return self . find_elements ( by = MobileBy . IMAGE , value = b64_data ) def find_element_by_accessibility_id ( self , accessibility_id ) : \"\"\"Finds an element by accessibility id. Args : accessibility_id ( str ) : A string corresponding to a recursive element search using the Id / Name that the native Accessibility options utilize Usage : driver . find_element_by_accessibility_id () Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id ) def find_elements_by_accessibility_id ( self , accessibility_id ) : \"\"\"Finds elements by accessibility id. Args : accessibility_id ( str ) : a string corresponding to a recursive element search using the Id / Name that the native Accessibility options utilize Usage : driver . find_elements_by_accessibility_id () Returns : : obj : ` list ` of : obj : ` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id ) def find_element_by_custom ( self , selector ) : \"\"\"Finds an element in conjunction with a custom element finding plugin Args : selector ( str ) : a string of the form \"module:selector\" , where \"module\" is the shortcut name given in the customFindModules capability , and \"selector\" is the string that will be passed to the custom element finding plugin itself Usage : driver . find_element_by_custom ( \"foo:bar\" ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . CUSTOM , value = selector ) def find_elements_by_custom ( self , selector ) : \"\"\"Finds elements in conjunction with a custom element finding plugin Args : selector : a string of the form \"module:selector\" , where \"module\" is the shortcut name given in the customFindModules capability , and \"selector\" is the string that will be passed to the custom element finding plugin itself Usage : driver . find_elements_by_custom ( \"foo:bar\" ) Returns : : obj : ` list ` of : obj : ` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . CUSTOM , value = selector ) def create_web_element ( self , element_id , w3c = False ) : \"\"\"Creates a web element with the specified element_id. Overrides method in Selenium WebDriver in order to always give them Appium WebElement Args : element_id ( int ) : The element id to create a web element w3c ( bool ) : Whether the element is W3C or MJSONWP Returns : ` MobileWebElement ` \"\"\" return MobileWebElement ( self , element_id , w3c ) def press_button ( self , button_name ) : \"\"\"Sends a physical button name to the device to simulate the user pressing. iOS only . Possible button names can be found in https : //github.com/appium/WebDriverAgent/blob/master/WebDriverAgentLib/Categories/XCUIDevice%2BFBHelpers.h Args : button_name ( str ) : the button name to be sent to the device Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' name ' : button_name } self . execute_script ( ' mobile : pressButton ' , data ) return self @property def current_package ( self ) : \"\"\"Retrieves the current package running on the device. \"\"\" return self . execute ( Command . GET_CURRENT_PACKAGE )[ ' value ' ] def set_value ( self , element , value ) : \"\"\"Set the value on an element in the application. Args : element ( ` appium . webdriver . webelement . WebElement ` : the element whose value will be set value ( str ) : the value to set on the element Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' id ' : element . id , ' value ' : [ value ], } self . execute ( Command . SET_IMMEDIATE_VALUE , data ) return self def end_test_coverage ( self , intent , path ) : \"\"\"Ends the coverage collection and pull the coverage.ec file from the device. Android only . See https : //github.com/appium/appium/blob/master/docs/en/writing-running-appium/android/android-coverage.md Args : intent ( str ) : description of operation to be performed path ( str ) : path to coverage . ec file to be pulled from the device Returns : TODO \"\"\" data = { ' intent ' : intent , ' path ' : path , } return self . execute ( Command . END_TEST_COVERAGE , data )[ ' value ' ] def open_notifications ( self ) : \"\"\"Open notification shade in Android (API Level 18 and above) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . OPEN_NOTIFICATIONS , {}) return self @property def battery_info ( self ) : \"\"\"Retrieves battery information for the device under test. Returns : A dictionary containing the following entries level : Battery level in range [ 0.0 , 1.0 ], where 1.0 means 100 % charge . Any value lower than 0 means the level cannot be retrieved state : Platform - dependent battery state value . On iOS ( XCUITest ) : 1 : Unplugged 2 : Charging 3 : Full Any other value means the state cannot be retrieved On Android ( UIAutomator2 ) : 2 : Charging 3 : Discharging 4 : Not charging 5 : Full Any other value means the state cannot be retrieved \"\"\" return self . execute_script ( ' mobile : batteryInfo ' ) @property def session ( self ) : \"\"\" Retrieves session information from the current session Usage : session = driver . session Returns : ` dict containing information from the current session ` \"\"\" return self . execute ( Command . GET_SESSION )[ ' value ' ] @property def events ( self ) : \"\"\" Retrieves events information from the current session Usage : events = driver . events Returns : ` dict containing events timing information from the current session ` \"\"\" try : session = self . session return session [ ' events ' ] except Exception as e : logger . warning ( ' Could not find events information in the session . Error : ' , e ) return {} # pylint: disable=protected-access def _addCommands ( self ) : # call the overridden command binders from all mixin classes except for # appium.webdriver.webdriver.WebDriver and its sub-classes # https: //github.com/appium/python-client/issues/342 for mixin_class in filter ( lambda x : not issubclass ( x , WebDriver ), self . __class__ . __mro__ ) : if hasattr ( mixin_class , self . _addCommands . __name__ ) : getattr ( mixin_class , self . _addCommands . __name__ , None )( self ) self . command_executor . _commands [ Command . GET_SESSION ] = \\ ( ' GET ' , ' / session / $ sessionId ' ) self . command_executor . _commands [ Command . TOUCH_ACTION ] = \\ ( ' POST ' , ' / session / $ sessionId / touch / perform ' ) self . command_executor . _commands [ Command . MULTI_ACTION ] = \\ ( ' POST ' , ' / session / $ sessionId / touch / multi / perform ' ) self . command_executor . _commands [ Command . GET_CURRENT_PACKAGE ] = \\ ( ' GET ' , ' / session / $ sessionId / appium / device / current_package ' ) self . command_executor . _commands [ Command . SET_IMMEDIATE_VALUE ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / element / $ id / value ' ) self . command_executor . _commands [ Command . LAUNCH_APP ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / app / launch ' ) self . command_executor . _commands [ Command . CLOSE_APP ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / app / close ' ) self . command_executor . _commands [ Command . END_TEST_COVERAGE ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / app / end_test_coverage ' ) self . command_executor . _commands [ Command . OPEN_NOTIFICATIONS ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / device / open_notifications ' ) self . command_executor . _commands [ Command . REPLACE_KEYS ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / element / $ id / replace_value ' ) self . command_executor . _commands [ Command . LOCATION_IN_VIEW ] = \\ ( ' GET ' , ' / session / $ sessionId / element / $ id / location_in_view ' ) self . command_executor . _commands [ Command . CLEAR ] = \\ ( ' POST ' , ' / session / $ sessionId / element / $ id / clear ' )","title":"WebDriver"},{"location":"reference/appium/webdriver/webdriver/#ancestors-in-mro","text":"appium.webdriver.extensions.search_context.AppiumSearchContext appium.webdriver.extensions.action_helpers.ActionHelpers appium.webdriver.extensions.android.activities.Activities appium.webdriver.extensions.applications.Applications appium.webdriver.extensions.clipboard.Clipboard appium.webdriver.extensions.context.Context appium.webdriver.extensions.device_time.DeviceTime appium.webdriver.extensions.android.display.Display appium.webdriver.extensions.execute_driver.ExecuteDriver appium.webdriver.extensions.android.gsm.Gsm appium.webdriver.extensions.hw_actions.HardwareActions appium.webdriver.extensions.images_comparison.ImagesComparison appium.webdriver.extensions.ime.IME appium.webdriver.extensions.keyboard.Keyboard appium.webdriver.extensions.location.Location appium.webdriver.extensions.android.network.Network appium.webdriver.extensions.android.performance.Performance appium.webdriver.extensions.android.power.Power appium.webdriver.extensions.remote_fs.RemoteFS appium.webdriver.extensions.screen_record.ScreenRecord appium.webdriver.extensions.settings.Settings appium.webdriver.extensions.android.sms.Sms appium.webdriver.extensions.android.system_bars.SystemBars selenium.webdriver.remote.webdriver.WebDriver appium.webdriver.extensions.search_context.AndroidSearchContext appium.webdriver.extensions.search_context.BaseSearchContext","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/webdriver/#class-variables","text":"AC_OFF AC_ON","title":"Class variables"},{"location":"reference/appium/webdriver/webdriver/#instance-variables","text":"active_ime_engine Returns the activity and package of the currently active IME engine(e.g., 'com.android.inputmethod.latin/.LatinIME'). Android only. Returns: str: The activity and package of the currently active IME engine application_cache Returns a ApplicationCache Object to interact with the browser app cache available_ime_engines Get the available input methods for an Android device. Package and activity are returned (e.g., ['com.android.inputmethod.latin/.LatinIME']) Android only. Returns: :obj: list of :obj: str : The available input methods for an Android device battery_info Retrieves battery information for the device under test. Returns: A dictionary containing the following entries level: Battery level in range [0.0, 1.0], where 1.0 means 100% charge. Any value lower than 0 means the level cannot be retrieved state: Platform-dependent battery state value. On iOS (XCUITest): 1: Unplugged 2: Charging 3: Full Any other value means the state cannot be retrieved On Android (UIAutomator2): 2: Charging 3: Discharging 4: Not charging 5: Full Any other value means the state cannot be retrieved context Returns the current context of the current session. Usage: driver.context Return: str: The context of the current session contexts Returns the contexts within the current session. Usage: driver.contexts Return: :obj: list of :obj: str : The contexts within the current session current_activity Retrieves the current activity running on the device. Returns: str: The current activity name running on the device current_context Returns the current context of the current session. Usage: driver.current_context Return: str: The context of the current session current_package Retrieves the current package running on the device. current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used device_time Returns the date and time from the device. Return: str: The date and time events Retrieves events information from the current session Usage: events = driver.events Returns: dict containing events timing information from the current session file_detector location Retrieves the current location Returns: A dictionary whose keys are - latitude (float) - longitude (float) - altitude (float) log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name network_connection Returns an integer bitmask specifying the network connection type. Android only. Possible values are available through the enumeration appium.webdriver.ConnectionType orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source session Retrieves session information from the current session Usage: session = driver.session Returns: dict containing information from the current session switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/webdriver/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/webdriver/#activate_app","text":"def activate_app ( self , app_id ) Activates the application if it is not running or is running in the background. Args: app_id (str): the application id to be activated Returns: appium.webdriver.webdriver.WebDriver View Source def activate_app ( self , app_id ) : \"\"\" Activates the application if it is not running or is running in the background . Args : app_id ( str ) : the application id to be activated Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' appId ' : app_id , } self . execute ( Command . ACTIVATE_APP , data ) return self","title":"activate_app"},{"location":"reference/appium/webdriver/webdriver/#activate_ime_engine","text":"def activate_ime_engine ( self , engine ) Activates the given IME engine on the device. Android only. Args: engine (str): the package and activity of the IME engine to activate (e.g., 'com.android.inputmethod.latin/.LatinIME') Returns: appium.webdriver.webdriver.WebDriver View Source def activate_ime_engine ( self , engine ) : \"\"\" Activates the given IME engine on the device. Android only . Args : engine ( str ) : the package and activity of the IME engine to activate ( e . g ., ' com.android.inputmethod.latin/.LatinIME ' ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' engine ' : engine } self . execute ( Command . ACTIVATE_IME_ENGINE , data ) return self","title":"activate_ime_engine"},{"location":"reference/appium/webdriver/webdriver/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/webdriver/#app_strings","text":"def app_strings ( self , language = None , string_file = None ) Returns the application strings from the device for the specified language. Args: language (str): strings language code string_file (str): the name of the string file to query View Source def app_strings ( self , language = None , string_file = None ) : \"\"\" Returns the application strings from the device for the specified language . Args : language ( str ) : strings language code string_file ( str ) : the name of the string file to query \"\"\" data = {} if language is not None : data [ ' language ' ] = language if string_file is not None : data [ ' stringFile ' ] = string_file return self . execute ( Command . GET_APP_STRINGS , data ) [ ' value ' ]","title":"app_strings"},{"location":"reference/appium/webdriver/webdriver/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/webdriver/#background_app","text":"def background_app ( self , seconds ) Puts the application in the background on the device for a certain duration. Args: seconds (int): the duration for the application to remain in the background Returns: appium.webdriver.webdriver.WebDriver View Source def background_app ( self , seconds ) : \"\"\" Puts the application in the background on the device for a certain duration. Args : seconds ( int ) : the duration for the application to remain in the background Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' seconds ' : seconds , } self . execute ( Command . BACKGROUND , data ) return self","title":"background_app"},{"location":"reference/appium/webdriver/webdriver/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/webdriver/#close_app","text":"def close_app ( self ) Stop the running application, specified in the desired capabilities, on the device. Returns: appium.webdriver.webdriver.WebDriver View Source def close_app ( self ) : \"\"\" Stop the running application, specified in the desired capabilities, on the device . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . CLOSE_APP ) return self","title":"close_app"},{"location":"reference/appium/webdriver/webdriver/#create_web_element","text":"def create_web_element ( self , element_id , w3c = False ) Creates a web element with the specified element_id. Overrides method in Selenium WebDriver in order to always give them Appium WebElement Args: element_id (int): The element id to create a web element w3c (bool): Whether the element is W3C or MJSONWP Returns: MobileWebElement View Source def create_web_element ( self , element_id , w3c = False ) : \"\"\" Creates a web element with the specified element_id. Overrides method in Selenium WebDriver in order to always give them Appium WebElement Args : element_id ( int ) : The element id to create a web element w3c ( bool ) : Whether the element is W3C or MJSONWP Returns : ` MobileWebElement ` \"\"\" return MobileWebElement ( self , element_id , w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/webdriver/#deactivate_ime_engine","text":"def deactivate_ime_engine ( self ) Deactivates the currently active IME engine on the device. Android only. Returns: appium.webdriver.webdriver.WebDriver View Source def deactivate_ime_engine ( self ) : \"\"\" Deactivates the currently active IME engine on the device. Android only . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . DEACTIVATE_IME_ENGINE , {} ) return self","title":"deactivate_ime_engine"},{"location":"reference/appium/webdriver/webdriver/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/webdriver/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/webdriver/#drag_and_drop","text":"def drag_and_drop ( self , origin_el , destination_el ) Drag the origin element to the destination element Args: originEl ( appium.webdriver.webelement.WebElement ): the element to drag destinationEl ( appium.webdriver.webelement.WebElement ): the element to drag to Returns: appium.webdriver.webelement.WebElement View Source def drag_and_drop ( self , origin_el , destination_el ) : \"\"\" Drag the origin element to the destination element Args : originEl ( ` appium . webdriver . webelement . WebElement ` ) : the element to drag destinationEl ( ` appium . webdriver . webelement . WebElement ` ) : the element to drag to Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" action = TouchAction ( self ) action . long_press ( origin_el ) . move_to ( destination_el ) . release () . perform () return self","title":"drag_and_drop"},{"location":"reference/appium/webdriver/webdriver/#end_test_coverage","text":"def end_test_coverage ( self , intent , path ) Ends the coverage collection and pull the coverage.ec file from the device. Android only. See https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/android/android-coverage.md Args: intent (str): description of operation to be performed path (str): path to coverage.ec file to be pulled from the device Returns: TODO View Source def end_test_coverage ( self , intent , path ) : \"\"\" Ends the coverage collection and pull the coverage.ec file from the device. Android only . See https : // github . com / appium / appium / blob / master / docs / en / writing - running - appium / android / android - coverage . md Args : intent ( str ) : description of operation to be performed path ( str ) : path to coverage . ec file to be pulled from the device Returns : TODO \"\"\" data = { ' intent ' : intent , ' path ' : path , } return self . execute ( Command . END_TEST_COVERAGE , data ) [ ' value ' ]","title":"end_test_coverage"},{"location":"reference/appium/webdriver/webdriver/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/webdriver/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/webdriver/#execute_driver","text":"def execute_driver ( self , script , script_type = 'webdriverio' , timeout_ms = None ) Run a set of script against the current session, allowing execution of many commands in one Appium request. Please read http://appium.io/docs/en/commands/session/execute-driver for more details about the acceptable scripts and the output format. Args: script (string): The string consisting of the script itself script_type (string): The name of the script type. Defaults to 'webdriverio'. timeout_ms (optional): The number of ms Appium should wait for the script to finish before killing it due to timeout_ms. Usage: self.driver.execute_driver(script='return [];') self.driver.execute_driver(script='return [];', script_type='webdriverio') self.driver.execute_driver(script='return [];', script_type='webdriverio', timeout_ms=10000) Returns: ExecuteDriver.Result: The result of the script. It has 'result' and 'logs' keys. Raises: WebDriverException: If something error happenes in the script. The message has the original error message. View Source def execute_driver ( self , script , script_type = ' webdriverio ' , timeout_ms = None ) : \"\"\" Run a set of script against the current session, allowing execution of many commands in one Appium request. Please read http : // appium . io / docs / en / commands / session / execute - driver for more details about the acceptable scripts and the output format . Args : script ( string ) : The string consisting of the script itself script_type ( string ) : The name of the script type . Defaults to ' webdriverio ' . timeout_ms ( optional ) : The number of ` ms ` Appium should wait for the script to finish before killing it due to timeout_ms . Usage : self . driver . execute_driver ( script = ' return []; ' ) self . driver . execute_driver ( script = ' return []; ' , script_type = ' webdriverio ' ) self . driver . execute_driver ( script = ' return []; ' , script_type = ' webdriverio ' , timeout_ms = 10000 ) Returns : ExecuteDriver . Result : The result of the script . It has ' result ' and ' logs ' keys . Raises : WebDriverException : If something error happenes in the script . The message has the original error message . \"\"\" class Result ( object ) : def __init__ ( self , response ) : self . result = response [ ' result ' ] self . logs = response [ ' logs ' ] option = { ' script ' : script , ' type ' : script_type } if timeout_ms is not None : option [ ' timeout ' ] = timeout_ms response = self . execute ( Command . EXECUTE_DRIVER , option ) [ ' value ' ] return Result ( response )","title":"execute_driver"},{"location":"reference/appium/webdriver/webdriver/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/webdriver/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/webdriver/#find_element","text":"def find_element ( self , by = 'id' , value = None ) 'Private' method used by the find_element_by_* methods. Override for Appium Usage: Use the corresponding find_element_by_* instead of this. Returns: appium.webdriver.webelement.WebElement :rtype: MobileWebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" 'Private' method used by the find_element_by_* methods. Override for Appium Usage : Use the corresponding find_element_by_ * instead of this . Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" # TODO : If we need , we should enable below converter for Web context # if self . w3c : # if by == By . ID : # by = By . CSS_SELECTOR # value = ' [id=\"%s\"] ' % value # elif by == By . TAG_NAME : # by = By . CSS_SELECTOR # elif by == By . CLASS_NAME : # by = By . CSS_SELECTOR # value = \" .%s \" % value # elif by == By . NAME : # by = By . CSS_SELECTOR # value = ' [name=\"%s\"] ' % value return self . execute ( RemoteCommand . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/webdriver/#find_element_by_accessibility_id","text":"def find_element_by_accessibility_id ( self , accessibility_id ) Finds an element by accessibility id. Args: accessibility_id (str): A string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize Usage: driver.find_element_by_accessibility_id() Returns: appium.webdriver.webelement.WebElement :rtype: MobileWebElement View Source def find_element_by_accessibility_id ( self , accessibility_id ) : \"\"\" Finds an element by accessibility id. Args : accessibility_id ( str ) : A string corresponding to a recursive element search using the Id / Name that the native Accessibility options utilize Usage : driver . find_element_by_accessibility_id () Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id )","title":"find_element_by_accessibility_id"},{"location":"reference/appium/webdriver/webdriver/#find_element_by_android_data_matcher","text":"def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) Finds element by onData in Android It works with Espresso Driver . Args: name (:obj: str , optional): The name of a method to invoke. The method must return a Hamcrest Matcher args (:obj: str , optional): The args provided to the method className (:obj: str , optional): The class name that the method is part of (defaults to org.hamcrest.Matchers ). Can be fully qualified, or simple, and simple defaults to androidx.test.espresso.matcher package (e.g.: class=CursorMatchers fully qualified is class=androidx.test.espresso.matcher.CursorMatchers Returns: appium.webdriver.webelement.WebElement : The found element Raises: TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage: driver.find_element_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) View Source def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds element by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found element Raises : TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage : driver . find_element_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_element ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) )","title":"find_element_by_android_data_matcher"},{"location":"reference/appium/webdriver/webdriver/#find_element_by_android_uiautomator","text":"def find_element_by_android_uiautomator ( self , uia_string ) Finds element by uiautomator in Android. Args: uia_string: The element name in the Android UIAutomator library Usage: driver.find_element_by_android_uiautomator('.elements()[1].cells()[2]') Returns: appium.webdriver.webelement.WebElement :rtype: MobileWebElement View Source def find_element_by_android_uiautomator ( self , uia_string ) : \"\"\" Finds element by uiautomator in Android. Args : uia_string : The element name in the Android UIAutomator library Usage : driver . find_element_by_android_uiautomator ( ' .elements()[1].cells()[2] ' ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string )","title":"find_element_by_android_uiautomator"},{"location":"reference/appium/webdriver/webdriver/#find_element_by_android_viewtag","text":"def find_element_by_android_viewtag ( self , tag ) Finds element by View#tags in Android. It works with Espresso Driver . Args: tag (str): The tag name of the view to look for Usage: driver.find_element_by_android_viewtag('a tag name') Returns: appium.webdriver.webelement.WebElement :rtype: MobileWebElement View Source def find_element_by_android_viewtag ( self , tag ) : \"\"\"Finds element by [View#tags](https://developer.android.com/reference/android/view/View#tags) in Android. It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : tag ( str ) : The tag name of the view to look for Usage : driver . find_element_by_android_viewtag ( ' a tag name ' ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . ANDROID_VIEWTAG , value = tag )","title":"find_element_by_android_viewtag"},{"location":"reference/appium/webdriver/webdriver/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/webdriver/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/webdriver/#find_element_by_custom","text":"def find_element_by_custom ( self , selector ) Finds an element in conjunction with a custom element finding plugin Args: selector (str): a string of the form \"module:selector\", where \"module\" is the shortcut name given in the customFindModules capability, and \"selector\" is the string that will be passed to the custom element finding plugin itself Usage: driver.find_element_by_custom(\"foo:bar\") Returns: appium.webdriver.webelement.WebElement :rtype: MobileWebElement View Source def find_element_by_custom ( self , selector ) : \"\"\" Finds an element in conjunction with a custom element finding plugin Args : selector ( str ) : a string of the form \" module:selector \" , where \" module \" is the shortcut name given in the customFindModules capability , and \" selector \" is the string that will be passed to the custom element finding plugin itself Usage : driver . find_element_by_custom ( \" foo:bar \" ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . CUSTOM , value = selector )","title":"find_element_by_custom"},{"location":"reference/appium/webdriver/webdriver/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/webdriver/#find_element_by_image","text":"def find_element_by_image ( self , img_path ) Finds a portion of a screenshot by an image. Uses driver.find_image_occurrence under the hood. Args: img_path (str): a string corresponding to the path of a image Returns: appium.webdriver.webelement.WebElement :rtype: MobileWebElement View Source def find_element_by_image ( self , img_path ) : \"\"\" Finds a portion of a screenshot by an image. Uses driver . find_image_occurrence under the hood . Args : img_path ( str ) : a string corresponding to the path of a image Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" with open ( img_path , ' rb ' ) as i_file : b64_data = base64 . b64encode ( i_file . read ()) . decode ( ' UTF-8 ' ) return self . find_element ( by = MobileBy . IMAGE , value = b64_data )","title":"find_element_by_image"},{"location":"reference/appium/webdriver/webdriver/#find_element_by_ios_class_chain","text":"def find_element_by_ios_class_chain ( self , class_chain_string ) Find an element by ios class chain string. Args: class_chain_string (str): The class chain string Usage: driver.find_element_by_ios_class_chain('XCUIElementTypeWindow/XCUIElementTypeButton[3]') Returns: appium.webdriver.webelement.WebElement :rtype: MobileWebElement View Source def find_element_by_ios_class_chain ( self , class_chain_string ) : \"\"\" Find an element by ios class chain string. Args : class_chain_string ( str ) : The class chain string Usage : driver . find_element_by_ios_class_chain ( ' XCUIElementTypeWindow/XCUIElementTypeButton[3] ' ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string )","title":"find_element_by_ios_class_chain"},{"location":"reference/appium/webdriver/webdriver/#find_element_by_ios_predicate","text":"def find_element_by_ios_predicate ( self , predicate_string ) Find an element by ios predicate string. Args: predicate_string (str): The predicate string Usage: driver.find_element_by_ios_predicate('label == \"myLabel\"') Returns: appium.webdriver.webelement.WebElement :rtype: MobileWebElement View Source def find_element_by_ios_predicate ( self , predicate_string ) : \"\"\" Find an element by ios predicate string. Args : predicate_string ( str ) : The predicate string Usage : driver . find_element_by_ios_predicate ( ' label == \"myLabel\" ' ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_PREDICATE , value = predicate_string )","title":"find_element_by_ios_predicate"},{"location":"reference/appium/webdriver/webdriver/#find_element_by_ios_uiautomation","text":"def find_element_by_ios_uiautomation ( self , uia_string ) Finds an element by uiautomation in iOS. Args: uia_string (str): The element name in the iOS UIAutomation library Usage: driver.find_element_by_ios_uiautomation('.elements()[1].cells()[2]') Returns: appium.webdriver.webelement.WebElement :rtype: MobileWebElement View Source def find_element_by_ios_uiautomation ( self , uia_string ) : \"\"\" Finds an element by uiautomation in iOS. Args : uia_string ( str ) : The element name in the iOS UIAutomation library Usage : driver . find_element_by_ios_uiautomation ( ' .elements()[1].cells()[2] ' ) Returns : ` appium . webdriver . webelement . WebElement ` : rtype : ` MobileWebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string )","title":"find_element_by_ios_uiautomation"},{"location":"reference/appium/webdriver/webdriver/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/webdriver/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/webdriver/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/webdriver/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/webdriver/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/webdriver/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) 'Private' method used by the find_elements_by_* methods. Override for Appium Usage: Use the corresponding find_elements_by_* instead of this. Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement :rtype: list of MobileWebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" 'Private' method used by the find_elements_by_* methods. Override for Appium Usage : Use the corresponding find_elements_by_ * instead of this . Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" # TODO : If we need , we should enable below converter for Web context # if self . w3c : # if by == By . ID : # by = By . CSS_SELECTOR # value = ' [id=\"%s\"] ' % value # elif by == By . TAG_NAME : # by = By . CSS_SELECTOR # elif by == By . CLASS_NAME : # by = By . CSS_SELECTOR # value = \" .%s \" % value # elif by == By . NAME : # by = By . CSS_SELECTOR # value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( RemoteCommand . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/webdriver/#find_elements_by_accessibility_id","text":"def find_elements_by_accessibility_id ( self , accessibility_id ) Finds elements by accessibility id. Args: accessibility_id (str): a string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize Usage: driver.find_elements_by_accessibility_id() Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement :rtype: list of MobileWebElement View Source def find_elements_by_accessibility_id ( self , accessibility_id ) : \"\"\" Finds elements by accessibility id. Args : accessibility_id ( str ) : a string corresponding to a recursive element search using the Id / Name that the native Accessibility options utilize Usage : driver . find_elements_by_accessibility_id () Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id )","title":"find_elements_by_accessibility_id"},{"location":"reference/appium/webdriver/webdriver/#find_elements_by_android_data_matcher","text":"def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) Finds elements by onData in Android It works with Espresso Driver . Args: name (:obj: str , optional): The name of a method to invoke. The method must return a Hamcrest Matcher args (:obj: str , optional): The args provided to the method className (:obj: str , optional): The class name that the method is part of (defaults to org.hamcrest.Matchers ). Can be fully qualified, or simple, and simple defaults to androidx.test.espresso.matcher package (e.g.: class=CursorMatchers fully qualified is class=androidx.test.espresso.matcher.CursorMatchers Returns: appium.webdriver.webelement.WebElement : The found elements Usage: driver.find_elements_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) View Source def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds elements by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found elements Usage : driver . find_elements_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_elements ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) )","title":"find_elements_by_android_data_matcher"},{"location":"reference/appium/webdriver/webdriver/#find_elements_by_android_uiautomator","text":"def find_elements_by_android_uiautomator ( self , uia_string ) Finds elements by uiautomator in Android. Args: uia_string (str): The element name in the Android UIAutomator library Usage: driver.find_elements_by_android_uiautomator('.elements()[1].cells()[2]') Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement :rtype: list of MobileWebElement View Source def find_elements_by_android_uiautomator ( self , uia_string ) : \"\"\" Finds elements by uiautomator in Android. Args : uia_string ( str ) : The element name in the Android UIAutomator library Usage : driver . find_elements_by_android_uiautomator ( ' .elements()[1].cells()[2] ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string )","title":"find_elements_by_android_uiautomator"},{"location":"reference/appium/webdriver/webdriver/#find_elements_by_android_viewtag","text":"def find_elements_by_android_viewtag ( self , tag ) Finds element by View#tags in Android. It works with Espresso Driver . Args: tag (str): The tag name of the view to look for Usage: driver.find_elements_by_android_viewtag('a tag name') Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement :rtype: list of MobileWebElement View Source def find_elements_by_android_viewtag ( self , tag ) : \"\"\"Finds element by [View#tags](https://developer.android.com/reference/android/view/View#tags) in Android. It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : tag ( str ) : The tag name of the view to look for Usage : driver . find_elements_by_android_viewtag ( ' a tag name ' ) Returns : : obj : ` list ` of : obj : ` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . ANDROID_VIEWTAG , value = tag )","title":"find_elements_by_android_viewtag"},{"location":"reference/appium/webdriver/webdriver/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/webdriver/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/webdriver/#find_elements_by_custom","text":"def find_elements_by_custom ( self , selector ) Finds elements in conjunction with a custom element finding plugin Args: selector: a string of the form \"module:selector\", where \"module\" is the shortcut name given in the customFindModules capability, and \"selector\" is the string that will be passed to the custom element finding plugin itself Usage: driver.find_elements_by_custom(\"foo:bar\") Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement :rtype: list of MobileWebElement View Source def find_elements_by_custom ( self , selector ) : \"\"\" Finds elements in conjunction with a custom element finding plugin Args : selector : a string of the form \" module:selector \" , where \" module \" is the shortcut name given in the customFindModules capability , and \" selector \" is the string that will be passed to the custom element finding plugin itself Usage : driver . find_elements_by_custom ( \" foo:bar \" ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . CUSTOM , value = selector )","title":"find_elements_by_custom"},{"location":"reference/appium/webdriver/webdriver/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/webdriver/#find_elements_by_image","text":"def find_elements_by_image ( self , img_path ) Finds a portion of a screenshot by an image. Uses driver.find_image_occurrence under the hood. Note that this will only ever return at most one element Args: img_path (str): a string corresponding to the path of a image Return: :obj: list of :obj: appium.webdriver.webelement.WebElement :rtype: list of MobileWebElement View Source def find_elements_by_image ( self , img_path ) : \"\"\" Finds a portion of a screenshot by an image. Uses driver . find_image_occurrence under the hood . Note that this will only ever return at most one element Args : img_path ( str ) : a string corresponding to the path of a image Return : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" with open ( img_path , ' rb ' ) as i_file : b64_data = base64 . b64encode ( i_file . read ()) . decode ( ' UTF-8 ' ) return self . find_elements ( by = MobileBy . IMAGE , value = b64_data )","title":"find_elements_by_image"},{"location":"reference/appium/webdriver/webdriver/#find_elements_by_ios_class_chain","text":"def find_elements_by_ios_class_chain ( self , class_chain_string ) Finds elements by ios class chain string. Args: class_chain_string (str): The class chain string Usage: driver.find_elements_by_ios_class_chain('XCUIElementTypeWindow[2]/XCUIElementTypeAny[-2]') Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement :rtype: list of MobileWebElement View Source def find_elements_by_ios_class_chain ( self , class_chain_string ) : \"\"\" Finds elements by ios class chain string. Args : class_chain_string ( str ) : The class chain string Usage : driver . find_elements_by_ios_class_chain ( ' XCUIElementTypeWindow[2]/XCUIElementTypeAny[-2] ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string )","title":"find_elements_by_ios_class_chain"},{"location":"reference/appium/webdriver/webdriver/#find_elements_by_ios_predicate","text":"def find_elements_by_ios_predicate ( self , predicate_string ) Finds elements by ios predicate string. Args: predicate_string (str): The predicate string Usage: driver.find_elements_by_ios_predicate('label == \"myLabel\"') Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement :rtype: list of MobileWebElement View Source def find_elements_by_ios_predicate ( self , predicate_string ) : \"\"\" Finds elements by ios predicate string. Args : predicate_string ( str ) : The predicate string Usage : driver . find_elements_by_ios_predicate ( ' label == \"myLabel\" ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_PREDICATE , value = predicate_string )","title":"find_elements_by_ios_predicate"},{"location":"reference/appium/webdriver/webdriver/#find_elements_by_ios_uiautomation","text":"def find_elements_by_ios_uiautomation ( self , uia_string ) Finds elements by uiautomation in iOS. Args: uia_string: The element name in the iOS UIAutomation library Usage: driver.find_elements_by_ios_uiautomation('.elements()[1].cells()[2]') Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement :rtype: list of MobileWebElement View Source def find_elements_by_ios_uiautomation ( self , uia_string ) : \"\"\" Finds elements by uiautomation in iOS. Args : uia_string : The element name in the iOS UIAutomation library Usage : driver . find_elements_by_ios_uiautomation ( ' .elements()[1].cells()[2] ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` : rtype : list of ` MobileWebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string )","title":"find_elements_by_ios_uiautomation"},{"location":"reference/appium/webdriver/webdriver/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/webdriver/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/webdriver/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/webdriver/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/webdriver/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/webdriver/#find_image_occurrence","text":"def find_image_occurrence ( self , base64_full_image , base64_partial_image , ** opts ) Performs images matching by template to find possible occurrence of the partial image in the full image. Read https://docs.opencv.org/2.4/doc/tutorials/imgproc/histograms/template_matching/template_matching.html for more details on this topic. The method supports all image formats, which are supported by OpenCV itself. Args: base64_full_image (bytes): base64-encoded content of the full image base64_partial_image (bytes): base64-encoded content of the partial image Keyword Args: visualize (bool): Set it to True in order to return the visualization of the matching operation. False by default Returns: visualization (bytes): base64-encoded content of PNG visualization of the current comparison operation. This entry is only present if visualize option is enabled rect (dict): The region of the partial image occurrence on the full image. The rect is represented by a dictionary with 'x', 'y', 'width' and 'height' keys View Source def find_image_occurrence ( self , base64_full_image , base64_partial_image , ** opts ) : \"\"\" Performs images matching by template to find possible occurrence of the partial image in the full image . Read https : // docs . opencv . org / 2 . 4 / doc / tutorials / imgproc / histograms / template_matching / template_matching . html for more details on this topic . The method supports all image formats , which are supported by OpenCV itself . Args : base64_full_image ( bytes ) : base64 - encoded content of the full image base64_partial_image ( bytes ) : base64 - encoded content of the partial image Keyword Args : visualize ( bool ) : Set it to True in order to return the visualization of the matching operation . False by default Returns : visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled rect ( dict ) : The region of the partial image occurrence on the full image . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys \"\"\" options = { ' mode ' : ' matchTemplate ' , ' firstImage ' : base64_full_image , ' secondImage ' : base64_partial_image , ' options ' : opts } return self . execute ( Command . COMPARE_IMAGES , options ) [ ' value ' ]","title":"find_image_occurrence"},{"location":"reference/appium/webdriver/webdriver/#finger_print","text":"def finger_print ( self , finger_id ) Authenticate users by using their finger print scans on supported Android emulators. Args: finger_id (int): Finger prints stored in Android Keystore system (from 1 to 10) Returns: TODO View Source def finger_print ( self , finger_id ) : \"\"\" Authenticate users by using their finger print scans on supported Android emulators. Args : finger_id ( int ) : Finger prints stored in Android Keystore system ( from 1 to 10 ) Returns : TODO \"\"\" return self . execute ( Command . FINGER_PRINT , { ' fingerprintId ' : finger_id } ) [ ' value ' ]","title":"finger_print"},{"location":"reference/appium/webdriver/webdriver/#flick","text":"def flick ( self , start_x , start_y , end_x , end_y ) Flick from one point to another point. Args: start_x (int): x-coordinate at which to start start_y (int): y-coordinate at which to start end_x (int): x-coordinate at which to stop end_y (int): y-coordinate at which to stop Usage: driver.flick(100, 100, 100, 400) Returns: appium.webdriver.webelement.WebElement View Source def flick ( self , start_x , start_y , end_x , end_y ) : \"\"\" Flick from one point to another point. Args : start_x ( int ) : x - coordinate at which to start start_y ( int ) : y - coordinate at which to start end_x ( int ) : x - coordinate at which to stop end_y ( int ) : y - coordinate at which to stop Usage : driver . flick ( 100 , 100 , 100 , 400 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" action = TouchAction ( self ) action \\ . press ( x = start_x , y = start_y ) \\ . move_to ( x = end_x , y = end_y ) \\ . release () action . perform () return self","title":"flick"},{"location":"reference/appium/webdriver/webdriver/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/webdriver/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/webdriver/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/webdriver/#get_clipboard","text":"def get_clipboard ( self , content_type = 'plaintext' ) Receives the content of the system clipboard Args: content_type (str): One of ClipboardContentType items. Only ClipboardContentType.PLAINTEXT is supported on Android Returns: base64-encoded string: Clipboard content. Or return an empty string if the clipboard is empty View Source def get_clipboard ( self , content_type = ClipboardContentType . PLAINTEXT ) : \"\"\" Receives the content of the system clipboard Args : content_type ( str ) : One of ClipboardContentType items . Only ClipboardContentType . PLAINTEXT is supported on Android Returns : base64 - encoded string : Clipboard content . Or return an empty string if the clipboard is empty \"\"\" base64_str = self . execute ( Command . GET_CLIPBOARD , { ' contentType ' : content_type } ) [ ' value ' ] return base64 . b64decode ( base64_str )","title":"get_clipboard"},{"location":"reference/appium/webdriver/webdriver/#get_clipboard_text","text":"def get_clipboard_text ( self ) Receives the text of the system clipboard Return: str: The actual clipboard text or an empty string if the clipboard is empty View Source def get_clipboard_text ( self ) : \"\"\" Receives the text of the system clipboard Return : str : The actual clipboard text or an empty string if the clipboard is empty \"\"\" return self . get_clipboard ( ClipboardContentType . PLAINTEXT ) . decode ( ' UTF-8 ' )","title":"get_clipboard_text"},{"location":"reference/appium/webdriver/webdriver/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/webdriver/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/webdriver/#get_device_time","text":"def get_device_time ( self , format = None ) Returns the date and time from the device. Args: format (optional): The set of format specifiers. Read https://momentjs.com/docs/ to get the full list of supported datetime format specifiers. If unset, return :func: .device_time as default format is YYYY-MM-DDTHH:mm:ssZ , which complies to ISO-8601 Usage: self.driver.get_device_time() self.driver.get_device_time(\"YYYY-MM-DD\") Return: str: The date and time View Source def get_device_time ( self , format = None ) : \"\"\" Returns the date and time from the device. Args : format ( optional ) : The set of format specifiers . Read https : // momentjs . com / docs / to get the full list of supported datetime format specifiers . If unset , return : func :`. device_time ` as default format is ` YYYY - MM - DDTHH : mm : ssZ `, which complies to ISO - 8601 Usage : self . driver . get_device_time () self . driver . get_device_time ( \" YYYY-MM-DD \" ) Return : str : The date and time \"\"\" if format is None : return self . device_time return self . execute ( Command . GET_DEVICE_TIME_POST , { ' format ' : format } ) [ ' value ' ]","title":"get_device_time"},{"location":"reference/appium/webdriver/webdriver/#get_display_density","text":"def get_display_density ( self ) Get the display density, Android only Returns: int: The display density of the Android device(dpi) Usage: self.driver.get_display_density() View Source def get_display_density ( self ) : \"\"\" Get the display density, Android only Returns : int : The display density of the Android device ( dpi ) Usage : self . driver . get_display_density () \"\"\" return self . execute ( Command . GET_DISPLAY_DENSITY ) [ ' value ' ]","title":"get_display_density"},{"location":"reference/appium/webdriver/webdriver/#get_images_similarity","text":"def get_images_similarity ( self , base64_image1 , base64_image2 , ** opts ) Performs images matching to calculate the similarity score between them. The flow there is similar to the one used in find_image_occurrence , but it is mandatory that both images are of equal resolution. The method supports all image formats, which are supported by OpenCV itself. Args: base64_image1 (bytes): base64-encoded content of the first image base64_image2 (bytes): base64-encoded content of the second image Keyword Args: visualize (bool): Set it to True in order to return the visualization of the matching operation. False by default Returns: visualization (bytes): base64-encoded content of PNG visualization of the current comparison operation. This entry is only present if visualize option is enabled score (float): The similarity score as a float number in range [0.0, 1.0]. 1.0 is the highest score (means both images are totally equal). View Source def get_images_similarity ( self , base64_image1 , base64_image2 , ** opts ) : \"\"\" Performs images matching to calculate the similarity score between them. The flow there is similar to the one used in ` find_image_occurrence `, but it is mandatory that both images are of equal resolution . The method supports all image formats , which are supported by OpenCV itself . Args : base64_image1 ( bytes ) : base64 - encoded content of the first image base64_image2 ( bytes ) : base64 - encoded content of the second image Keyword Args : visualize ( bool ) : Set it to True in order to return the visualization of the matching operation . False by default Returns : visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled score ( float ) : The similarity score as a float number in range [ 0 . 0 , 1 . 0 ]. 1 . 0 is the highest score ( means both images are totally equal ) . \"\"\" options = { ' mode ' : ' getSimilarity ' , ' firstImage ' : base64_image1 , ' secondImage ' : base64_image2 , ' options ' : opts } return self . execute ( Command . COMPARE_IMAGES , options ) [ ' value ' ]","title":"get_images_similarity"},{"location":"reference/appium/webdriver/webdriver/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/webdriver/#get_performance_data","text":"def get_performance_data ( self , package_name , data_type , data_read_timeout = None ) Returns the information of the system state which is supported to read as like cpu, memory, network traffic, and battery. Android only. Args: package_name (str): The package name of the application data_type (str): The type of system state which wants to read. It should be one of the supported performance data types. Check :func: .get_performance_data_types for supported types data_read_timeout (:obj: int , optional): The number of attempts to read Usage: self.driver.get_performance_data('my.app.package', 'cpuinfo', 5) Returns: dict: The data along to data_type View Source def get_performance_data ( self , package_name , data_type , data_read_timeout = None ) : \"\"\" Returns the information of the system state which is supported to read as like cpu , memory , network traffic , and battery . Android only . Args : package_name ( str ) : The package name of the application data_type ( str ) : The type of system state which wants to read . It should be one of the supported performance data types . Check : func :`. get_performance_data_types ` for supported types data_read_timeout ( : obj :` int `, optional ) : The number of attempts to read Usage : self . driver . get_performance_data ( ' my.app.package ' , ' cpuinfo ' , 5 ) Returns : dict : The data along to ` data_type ` \"\"\" data = { ' packageName ' : package_name , ' dataType ' : data_type } if data_read_timeout is not None : data [ ' dataReadTimeout ' ] = data_read_timeout return self . execute ( Command . GET_PERFORMANCE_DATA , data ) [ ' value ' ]","title":"get_performance_data"},{"location":"reference/appium/webdriver/webdriver/#get_performance_data_types","text":"def get_performance_data_types ( self ) Returns the information types of the system state which is supported to read as like cpu, memory, network traffic, and battery. Android only. Usage: self.driver.get_performance_data_types() Returns: list: Available data types View Source def get_performance_data_types ( self ) : \"\"\" Returns the information types of the system state which is supported to read as like cpu , memory , network traffic , and battery . Android only . Usage : self . driver . get_performance_data_types () Returns : list : Available data types \"\"\" return self . execute ( Command . GET_PERFORMANCE_DATA_TYPES ) [ ' value ' ]","title":"get_performance_data_types"},{"location":"reference/appium/webdriver/webdriver/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/webdriver/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/webdriver/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/webdriver/#get_settings","text":"def get_settings ( self ) Returns the appium server Settings for the current session. Do not get Settings confused with Desired Capabilities, they are separate concepts. See https://github.com/appium/appium/blob/master/docs/en/advanced-concepts/settings.md Returns: dict: Current settings View Source def get_settings ( self ) : \"\"\" Returns the appium server Settings for the current session. Do not get Settings confused with Desired Capabilities , they are separate concepts . See https : // github . com / appium / appium / blob / master / docs / en / advanced - concepts / settings . md Returns : dict : Current settings \"\"\" return self . execute ( Command . GET_SETTINGS , {} ) [ ' value ' ]","title":"get_settings"},{"location":"reference/appium/webdriver/webdriver/#get_system_bars","text":"def get_system_bars ( self ) Retrieve visibility and bounds information of the status and navigation bars. Android only. Returns: A dictionary whose keys are - statusBar - visible - x - y - width - height - navigationBar - visible - x - y - width - height View Source def get_system_bars ( self ) : \"\"\" Retrieve visibility and bounds information of the status and navigation bars. Android only . Returns : A dictionary whose keys are - statusBar - visible - x - y - width - height - navigationBar - visible - x - y - width - height \"\"\" return self . execute ( Command . GET_SYSTEM_BARS ) [ ' value ' ]","title":"get_system_bars"},{"location":"reference/appium/webdriver/webdriver/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/webdriver/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/webdriver/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/webdriver/#hide_keyboard","text":"def hide_keyboard ( self , key_name = None , key = None , strategy = None ) Hides the software keyboard on the device. In iOS, use key_name to press a particular key, or strategy . In Android, no parameters are used. Args: key_name (:obj: str , optional): key to press key (:obj: str , optional): strategy (:obj: str , optional): strategy for closing the keyboard (e.g., tapOutside ) View Source def hide_keyboard ( self , key_name = None , key = None , strategy = None ) : \"\"\" Hides the software keyboard on the device. In iOS , use ` key_name ` to press a particular key , or ` strategy `. In Android , no parameters are used . Args : key_name ( : obj :` str `, optional ) : key to press key ( : obj :` str `, optional ) : strategy ( : obj :` str `, optional ) : strategy for closing the keyboard ( e . g ., ` tapOutside ` ) \"\"\" data = {} if key_name is not None : data [ ' keyName ' ] = key_name elif key is not None : data [ ' key ' ] = key elif strategy is None : strategy = ' tapOutside ' data [ ' strategy ' ] = strategy self . execute ( Command . HIDE_KEYBOARD , data ) return self","title":"hide_keyboard"},{"location":"reference/appium/webdriver/webdriver/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/webdriver/#install_app","text":"def install_app ( self , app_path , ** options ) Install the application found at app_path on the device. Args: app_path (str): the local or remote path to the application to install Keyword Args: replace (bool): [Android only] whether to reinstall/upgrade the package if it is already present on the device under test. True by default timeout (int): [Android only] how much time to wait for the installation to complete. 60000ms by default. allowTestPackages (bool): [Android only] whether to allow installation of packages marked as test in the manifest. False by default useSdcard (bool): [Android only] whether to use the SD card to install the app. False by default grantPermissions (bool): [Android only] whether to automatically grant application permissions on Android 6+ after the installation completes. False by default Returns: appium.webdriver.webdriver.WebDriver View Source def install_app ( self , app_path , ** options ) : \"\"\"Install the application found at `app_path` on the device. Args : app_path ( str ) : the local or remote path to the application to install Keyword Args : replace ( bool ) : [ Android only ] whether to reinstall / upgrade the package if it is already present on the device under test . True by default timeout ( int ) : [ Android only ] how much time to wait for the installation to complete . 60000 ms by default . allowTestPackages ( bool ) : [ Android only ] whether to allow installation of packages marked as test in the manifest . False by default useSdcard ( bool ) : [ Android only ] whether to use the SD card to install the app . False by default grantPermissions ( bool ) : [ Android only ] whether to automatically grant application permissions on Android 6 + after the installation completes . False by default Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' appPath ' : app_path , } if options : data . update ({ ' options ' : options }) self . execute ( Command . INSTALL_APP , data ) return self","title":"install_app"},{"location":"reference/appium/webdriver/webdriver/#is_app_installed","text":"def is_app_installed ( self , bundle_id ) Checks whether the application specified by bundle_id is installed on the device. Args: bundle_id (str): the id of the application to query Returns: bool: True if app is installed View Source def is_app_installed ( self , bundle_id ) : \"\"\" Checks whether the application specified by `bundle_id` is installed on the device. Args : bundle_id ( str ) : the id of the application to query Returns : bool : ` True ` if app is installed \"\"\" data = { ' bundleId ' : bundle_id , } return self . execute ( Command . IS_APP_INSTALLED , data ) [ ' value ' ]","title":"is_app_installed"},{"location":"reference/appium/webdriver/webdriver/#is_ime_active","text":"def is_ime_active ( self ) Checks whether the device has IME service active. Android only. Returns: bool: True if IME service is active View Source def is_ime_active ( self ) : \"\"\" Checks whether the device has IME service active. Android only . Returns : bool : ` True ` if IME service is active \"\"\" return self . execute ( Command . IS_IME_ACTIVE , {} ) [ ' value ' ]","title":"is_ime_active"},{"location":"reference/appium/webdriver/webdriver/#is_keyboard_shown","text":"def is_keyboard_shown ( self ) Attempts to detect whether a software keyboard is present Returns: bool: True if keyboard is shown View Source def is_keyboard_shown ( self ) : \"\"\" Attempts to detect whether a software keyboard is present Returns : bool : ` True ` if keyboard is shown \"\"\" return self . execute ( Command . IS_KEYBOARD_SHOWN ) [ ' value ' ]","title":"is_keyboard_shown"},{"location":"reference/appium/webdriver/webdriver/#is_locked","text":"def is_locked ( self ) Checks whether the device is locked. Returns: bool: True if the device is locked View Source def is_locked ( self ) : \"\"\" Checks whether the device is locked. Returns : bool : ` True ` if the device is locked \"\"\" return self . execute ( Command . IS_LOCKED ) [ ' value ' ]","title":"is_locked"},{"location":"reference/appium/webdriver/webdriver/#keyevent","text":"def keyevent ( self , keycode , metastate = None ) Sends a keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html. Args: keycode (int): the keycode to be sent to the device metastate (:obj: int , optional): meta information about the keycode being sent Returns: appium.webdriver.webdriver.WebDriver View Source def keyevent ( self , keycode , metastate = None ) : \"\"\" Sends a keycode to the device. Android only . Possible keycodes can be found in http : // developer . android . com / reference / android / view / KeyEvent . html . Args : keycode ( int ) : the keycode to be sent to the device metastate ( : obj :` int `, optional ) : meta information about the keycode being sent Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' keycode ' : keycode , } if metastate is not None : data [ ' metastate ' ] = metastate self . execute ( Command . KEY_EVENT , data ) return self","title":"keyevent"},{"location":"reference/appium/webdriver/webdriver/#launch_app","text":"def launch_app ( self ) Start on the device the application specified in the desired capabilities. Returns: appium.webdriver.webdriver.WebDriver View Source def launch_app ( self ) : \"\"\" Start on the device the application specified in the desired capabilities. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . LAUNCH_APP ) return self","title":"launch_app"},{"location":"reference/appium/webdriver/webdriver/#lock","text":"def lock ( self , seconds = None ) Lock the device. No changes are made if the device is already unlocked. Args: seconds (optional): The duration to lock the device, in seconds. The device is going to be locked forever until unlock is called if it equals or is less than zero, otherwise this call blocks until the timeout expires and unlocks the screen automatically. Returns: appium.webdriver.webdriver.WebDriver View Source def lock ( self , seconds = None ) : \"\"\" Lock the device. No changes are made if the device is already unlocked. Args : seconds ( optional ) : The duration to lock the device , in seconds . The device is going to be locked forever until ` unlock ` is called if it equals or is less than zero , otherwise this call blocks until the timeout expires and unlocks the screen automatically . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" if seconds is None : self . execute ( Command . LOCK ) else : self . execute ( Command . LOCK , { ' seconds ' : seconds } ) return self","title":"lock"},{"location":"reference/appium/webdriver/webdriver/#long_press_keycode","text":"def long_press_keycode ( self , keycode , metastate = None , flags = None ) Sends a long press of keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html. Args: keycode (int): the keycode to be sent to the device metastate (:obj: int , optional): meta information about the keycode being sent flags (:obj: int , optional): the set of key event flags Returns: appium.webdriver.webdriver.WebDriver View Source def long_press_keycode ( self , keycode , metastate = None , flags = None ) : \"\"\" Sends a long press of keycode to the device. Android only . Possible keycodes can be found in http : // developer . android . com / reference / android / view / KeyEvent . html . Args : keycode ( int ) : the keycode to be sent to the device metastate ( : obj :` int `, optional ) : meta information about the keycode being sent flags ( : obj :` int `, optional ) : the set of key event flags Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' keycode ' : keycode } if metastate is not None : data [ ' metastate ' ] = metastate if flags is not None : data [ ' flags ' ] = flags self . execute ( Command . LONG_PRESS_KEYCODE , data ) return self","title":"long_press_keycode"},{"location":"reference/appium/webdriver/webdriver/#make_gsm_call","text":"def make_gsm_call ( self , phone_number , action ) Make GSM call (Emulator only) Android only. Args: phone_number (str): The phone number to call to. action (str): The call action. A member of the const appium.webdriver.extensions.android.gsm.GsmCallActions :Usage: self.driver.make_gsm_call('5551234567', GsmCallActions.CALL) View Source def make_gsm_call ( self , phone_number , action ) : \"\"\" Make GSM call (Emulator only) Android only . Args : phone_number ( str ) : The phone number to call to . action ( str ) : The call action . A member of the const ` appium . webdriver . extensions . android . gsm . GsmCallActions ` : Usage : self . driver . make_gsm_call ( ' 5551234567 ' , GsmCallActions . CALL ) \"\"\" constants = extract_const_attributes ( GsmCallActions ) if action not in constants . values () : logger . warning ( ' {} is unknown. Consider using one of {} constants. (e.g. {}.CALL) ' . format ( action , list ( constants . keys ()) , GsmCallActions . __name__ )) self . execute ( Command . MAKE_GSM_CALL , { ' phoneNumber ' : phone_number , ' action ' : action } ) return self","title":"make_gsm_call"},{"location":"reference/appium/webdriver/webdriver/#match_images_features","text":"def match_images_features ( self , base64_image1 , base64_image2 , ** opts ) Performs images matching by features. Read https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_feature2d/py_matcher/py_matcher.html for more details on this topic. The method supports all image formats, which are supported by OpenCV itself. Args: base64_image1 (bytes): base64-encoded content of the first image base64_image2 (bytes): base64-encoded content of the second image Keyword Args: visualize (bool): Set it to True in order to return the visualization of the matching operation. matching visualization. False by default detectorName (str): One of possible feature detector names: 'AKAZE', 'AGAST', 'BRISK', 'FAST', 'GFTT', 'KAZE', 'MSER', 'SIFT', 'ORB' Some of these detectors are not enabled in the default OpenCV deployment. 'ORB' By default. matchFunc (str): One of supported matching functions names: 'FlannBased', 'BruteForce', 'BruteForceL1', 'BruteForceHamming', 'BruteForceHammingLut', 'BruteForceSL2' 'BruteForce' by default goodMatchesFactor (int): The maximum count of \"good\" matches (e. g. with minimal distances). This count is unlimited by default. Returns: The dictionary containing the following entries: visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled count ( int ) : The count of matched edges on both images . The more matching edges there are no both images the more similar they are . totalCount ( int ) : The total count of matched edges on both images . It is equal to ` count ` if ` goodMatchesFactor ` does not limit the matches , otherwise it contains the total count of matches before ` goodMatchesFactor ` is applied . points1 ( dict )) : The array of matching points on the first image . Each point is a dictionary with ' x ' and ' y ' keys rect1 ( dict ) : The bounding rect for the ` points1 ` array or a zero rect if not enough matching points were found . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys points2 ( dict ) : The array of matching points on the second image . Each point is a dictionary with ' x ' and ' y ' keys rect2 ( dict ) : The bounding rect for the ` points2 ` array or a zero rect if not enough matching points were found . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys View Source def match_images_features ( self , base64_image1 , base64_image2 , ** opts ) : \"\"\" Performs images matching by features. Read https : // docs . opencv . org / 3 . 0 - beta / doc / py_tutorials / py_feature2d / py_matcher / py_matcher . html for more details on this topic . The method supports all image formats , which are supported by OpenCV itself . Args : base64_image1 ( bytes ) : base64 - encoded content of the first image base64_image2 ( bytes ) : base64 - encoded content of the second image Keyword Args : visualize ( bool ) : Set it to True in order to return the visualization of the matching operation . matching visualization . False by default detectorName ( str ) : One of possible feature detector names : ' AKAZE ' , ' AGAST ' , ' BRISK ' , ' FAST ' , ' GFTT ' , ' KAZE ' , ' MSER ' , ' SIFT ' , ' ORB ' Some of these detectors are not enabled in the default OpenCV deployment . ' ORB ' By default . matchFunc ( str ) : One of supported matching functions names : ' FlannBased ' , ' BruteForce ' , ' BruteForceL1 ' , ' BruteForceHamming ' , ' BruteForceHammingLut ' , ' BruteForceSL2 ' ' BruteForce ' by default goodMatchesFactor ( int ) : The maximum count of \" good \" matches ( e . g . with minimal distances ) . This count is unlimited by default . Returns : The dictionary containing the following entries : visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled count ( int ) : The count of matched edges on both images . The more matching edges there are no both images the more similar they are . totalCount ( int ) : The total count of matched edges on both images . It is equal to ` count ` if ` goodMatchesFactor ` does not limit the matches , otherwise it contains the total count of matches before ` goodMatchesFactor ` is applied . points1 ( dict )) : The array of matching points on the first image . Each point is a dictionary with ' x ' and ' y ' keys rect1 ( dict ) : The bounding rect for the ` points1 ` array or a zero rect if not enough matching points were found . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys points2 ( dict ) : The array of matching points on the second image . Each point is a dictionary with ' x ' and ' y ' keys rect2 ( dict ) : The bounding rect for the ` points2 ` array or a zero rect if not enough matching points were found . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys \"\"\" options = { ' mode ' : ' matchFeatures ' , ' firstImage ' : base64_image1 , ' secondImage ' : base64_image2 , ' options ' : opts } return self . execute ( Command . COMPARE_IMAGES , options ) [ ' value ' ]","title":"match_images_features"},{"location":"reference/appium/webdriver/webdriver/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/webdriver/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/webdriver/#open_notifications","text":"def open_notifications ( self ) Open notification shade in Android (API Level 18 and above) Returns: appium.webdriver.webdriver.WebDriver View Source def open_notifications ( self ) : \"\"\" Open notification shade in Android (API Level 18 and above) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . OPEN_NOTIFICATIONS , {} ) return self","title":"open_notifications"},{"location":"reference/appium/webdriver/webdriver/#press_button","text":"def press_button ( self , button_name ) Sends a physical button name to the device to simulate the user pressing. iOS only. Possible button names can be found in https://github.com/appium/WebDriverAgent/blob/master/WebDriverAgentLib/Categories/XCUIDevice%2BFBHelpers.h Args: button_name (str): the button name to be sent to the device Returns: appium.webdriver.webdriver.WebDriver View Source def press_button ( self , button_name ) : \"\"\" Sends a physical button name to the device to simulate the user pressing. iOS only . Possible button names can be found in https : // github . com / appium / WebDriverAgent / blob / master / WebDriverAgentLib / Categories / XCUIDevice % 2 BFBHelpers . h Args : button_name ( str ) : the button name to be sent to the device Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' name ' : button_name } self . execute_script ( ' mobile: pressButton ' , data ) return self","title":"press_button"},{"location":"reference/appium/webdriver/webdriver/#press_keycode","text":"def press_keycode ( self , keycode , metastate = None , flags = None ) Sends a keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html. Args: keycode (int): the keycode to be sent to the device metastate (:obj: int , optional): meta information about the keycode being sent flags (:obj: int , optional): the set of key event flags Returns: appium.webdriver.webdriver.WebDriver View Source def press_keycode ( self , keycode , metastate = None , flags = None ) : \"\"\" Sends a keycode to the device. Android only . Possible keycodes can be found in http : // developer . android . com / reference / android / view / KeyEvent . html . Args : keycode ( int ) : the keycode to be sent to the device metastate ( : obj :` int `, optional ) : meta information about the keycode being sent flags ( : obj :` int `, optional ) : the set of key event flags Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' keycode ' : keycode , } if metastate is not None : data [ ' metastate ' ] = metastate if flags is not None : data [ ' flags ' ] = flags self . execute ( Command . PRESS_KEYCODE , data ) return self","title":"press_keycode"},{"location":"reference/appium/webdriver/webdriver/#pull_file","text":"def pull_file ( self , path ) Retrieves the file at path . Args: path (str): the path to the file on the device Returns: bytes: The file's contents as base64. View Source def pull_file ( self , path ) : \"\"\" Retrieves the file at `path`. Args : path ( str ) : the path to the file on the device Returns : bytes : The file ' s contents as base64. \"\"\" data = { ' path ' : path , } return self . execute ( Command . PULL_FILE , data ) [ ' value ' ]","title":"pull_file"},{"location":"reference/appium/webdriver/webdriver/#pull_folder","text":"def pull_folder ( self , path ) Retrieves a folder at path . Args: path (str): the path to the folder on the device Returns: bytes: The folder's contents zipped and encoded as Base64. View Source def pull_folder ( self , path ) : \"\"\" Retrieves a folder at `path`. Args : path ( str ) : the path to the folder on the device Returns : bytes : The folder ' s contents zipped and encoded as Base64. \"\"\" data = { ' path ' : path , } return self . execute ( Command . PULL_FOLDER , data ) [ ' value ' ]","title":"pull_folder"},{"location":"reference/appium/webdriver/webdriver/#push_file","text":"def push_file ( self , destination_path , base64data = None , source_path = None ) Puts the data from the file at source_path , encoded as Base64, in the file specified as path . Specify either base64data or source_path , if both specified default to source_path Args: destination_path (str): the location on the device/simulator where the local file contents should be saved base64data (:obj: bytes , optional): file contents, encoded as Base64, to be written to the file on the device/simulator source_path (:obj: str , optional): local file path for the file to be loaded on device Returns: appium.webdriver.webdriver.WebDriver View Source def push_file ( self , destination_path , base64data = None , source_path = None ) : \"\"\" Puts the data from the file at `source_path`, encoded as Base64, in the file specified as `path`. Specify either ` base64data ` or ` source_path `, if both specified default to ` source_path ` Args : destination_path ( str ) : the location on the device / simulator where the local file contents should be saved base64data ( : obj :` bytes `, optional ) : file contents , encoded as Base64 , to be written to the file on the device / simulator source_path ( : obj :` str `, optional ) : local file path for the file to be loaded on device Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" if source_path is None and base64data is None : raise InvalidArgumentException ( ' Must either pass base64 data or a local file path ' ) if source_path is not None : try : with open ( source_path , ' rb ' ) as f : data = f . read () except IOError : message = ' source_path {} could not be found. Are you sure the file exists? ' . format ( source_path ) raise InvalidArgumentException ( message ) base64data = base64 . b64encode ( data ) . decode ( ' utf-8 ' ) data = { ' path ' : destination_path , ' data ' : base64data , } self . execute ( Command . PUSH_FILE , data ) return self","title":"push_file"},{"location":"reference/appium/webdriver/webdriver/#query_app_state","text":"def query_app_state ( self , app_id ) Queries the state of the application. Args: app_id (str): the application id to be queried Returns: One of possible application state constants. See ApplicationState class for more details. View Source def query_app_state ( self , app_id ) : \"\"\" Queries the state of the application. Args : app_id ( str ) : the application id to be queried Returns : One of possible application state constants . See ApplicationState class for more details . \"\"\" data = { ' appId ' : app_id , } return self . execute ( Command . QUERY_APP_STATE , data ) [ ' value ' ]","title":"query_app_state"},{"location":"reference/appium/webdriver/webdriver/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/webdriver/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/webdriver/#remove_app","text":"def remove_app ( self , app_id , ** options ) Remove the specified application from the device. Args: app_id (str): the application id to be removed Keyword Args: keepData (bool): [Android only] whether to keep application data and caches after it is uninstalled. False by default timeout (int): [Android only] how much time to wait for the uninstall to complete. 20000ms by default. Returns: appium.webdriver.webdriver.WebDriver View Source def remove_app ( self , app_id , ** options ) : \"\"\"Remove the specified application from the device. Args : app_id ( str ) : the application id to be removed Keyword Args : keepData ( bool ) : [ Android only ] whether to keep application data and caches after it is uninstalled . False by default timeout ( int ) : [ Android only ] how much time to wait for the uninstall to complete . 20000 ms by default . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' appId ' : app_id , } if options : data . update ({ ' options ' : options }) self . execute ( Command . REMOVE_APP , data ) return self","title":"remove_app"},{"location":"reference/appium/webdriver/webdriver/#reset","text":"def reset ( self ) Resets the current application on the device. View Source def reset ( self ) : \"\"\" Resets the current application on the device. \"\"\" self . execute ( Command . RESET ) return self","title":"reset"},{"location":"reference/appium/webdriver/webdriver/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/webdriver/#scroll","text":"def scroll ( self , origin_el , destination_el , duration = None ) Scrolls from one element to another Args: originalEl ( appium.webdriver.webelement.WebElement ): the element from which to being scrolling destinationEl ( appium.webdriver.webelement.WebElement ): the element to scroll to duration (int): a duration after pressing originalEl and move the element to destinationEl. Default is 600 ms for W3C spec. Zero for MJSONWP. Usage: driver.scroll(el1, el2) Returns: appium.webdriver.webelement.WebElement View Source def scroll ( self , origin_el , destination_el , duration = None ) : \"\"\" Scrolls from one element to another Args : originalEl ( ` appium . webdriver . webelement . WebElement ` ) : the element from which to being scrolling destinationEl ( ` appium . webdriver . webelement . WebElement ` ) : the element to scroll to duration ( int ) : a duration after pressing originalEl and move the element to destinationEl . Default is 600 ms for W3C spec . Zero for MJSONWP . Usage : driver . scroll ( el1 , el2 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" # XCUITest x W3C spec has no duration by default in server side if self . w3c and duration is None : duration = 600 action = TouchAction ( self ) if duration is None : action . press ( origin_el ) . move_to ( destination_el ) . release () . perform () else : action . press ( origin_el ) . wait ( duration ) . move_to ( destination_el ) . release () . perform () return self","title":"scroll"},{"location":"reference/appium/webdriver/webdriver/#send_sms","text":"def send_sms ( self , phone_number , message ) Emulate send SMS event on the connected emulator. Android only. Args: phone_number (str): The phone number of message sender message (str): The message to send Usage: self.driver.send_sms('555-123-4567', 'Hey lol') Returns: appium.webdriver.webdriver.WebDriver View Source def send_sms ( self , phone_number , message ) : \"\"\" Emulate send SMS event on the connected emulator. Android only . Args : phone_number ( str ) : The phone number of message sender message ( str ) : The message to send Usage : self . driver . send_sms ( ' 555-123-4567 ' , ' Hey lol ' ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SEND_SMS , { ' phoneNumber ' : phone_number , ' message ' : message } ) return self","title":"send_sms"},{"location":"reference/appium/webdriver/webdriver/#set_clipboard","text":"def set_clipboard ( self , content , content_type = 'plaintext' , label = None ) Set the content of the system clipboard Args: content (str): The content to be set as bytearray string content_type (str): One of ClipboardContentType items. Only ClipboardContentType.PLAINTEXT is supported on Android label (:obj: str , optional): label argument, which only works for Android View Source def set_clipboard ( self , content , content_type = ClipboardContentType . PLAINTEXT , label = None ) : \"\"\" Set the content of the system clipboard Args : content ( str ) : The content to be set as bytearray string content_type ( str ) : One of ClipboardContentType items . Only ClipboardContentType . PLAINTEXT is supported on Android label ( : obj :` str `, optional ) : label argument , which only works for Android \"\"\" options = { ' content ' : base64 . b64encode ( content ) . decode ( ' UTF-8 ' ) , ' contentType ' : content_type , } if label : options [ ' label ' ] = label self . execute ( Command . SET_CLIPBOARD , options )","title":"set_clipboard"},{"location":"reference/appium/webdriver/webdriver/#set_clipboard_text","text":"def set_clipboard_text ( self , text , label = None ) Copies the given text to the system clipboard Args: text (str): The text to be set label (:obj: int , optional):label argument, which only works for Android View Source def set_clipboard_text ( self , text , label = None ) : \"\"\" Copies the given text to the system clipboard Args : text ( str ) : The text to be set label ( : obj :` int `, optional ) : label argument , which only works for Android \"\"\" self . set_clipboard ( appium_bytes ( str ( text ) , ' UTF-8 ' ) , ClipboardContentType . PLAINTEXT , label )","title":"set_clipboard_text"},{"location":"reference/appium/webdriver/webdriver/#set_gsm_signal","text":"def set_gsm_signal ( self , strength ) Set GSM signal strength (Emulator only) Android only. Args: strength (int): Signal strength. A member of the enum appium.webdriver.extensions.android.gsm.GsmSignalStrength Usage: self.driver.set_gsm_signal(GsmSignalStrength.GOOD) View Source def set_gsm_signal ( self , strength ) : \"\"\" Set GSM signal strength (Emulator only) Android only . Args : strength ( int ) : Signal strength . A member of the enum ` appium . webdriver . extensions . android . gsm . GsmSignalStrength ` Usage : self . driver . set_gsm_signal ( GsmSignalStrength . GOOD ) \"\"\" constants = extract_const_attributes ( GsmSignalStrength ) if strength not in constants . values () : logger . warning ( ' {} is out of range. Consider using one of {} constants. (e.g. {}.GOOD) ' . format ( strength , list ( constants . keys ()) , GsmSignalStrength . __name__ )) self . execute ( Command . SET_GSM_SIGNAL , { ' signalStrength ' : strength , ' signalStrengh ' : strength } ) return self","title":"set_gsm_signal"},{"location":"reference/appium/webdriver/webdriver/#set_gsm_voice","text":"def set_gsm_voice ( self , state ) Set GSM voice state (Emulator only) Android only. Args: state (str): State of GSM voice. A member of the const appium.webdriver.extensions.android.gsm.GsmVoiceState Usage: self.driver.set_gsm_voice(GsmVoiceState.HOME) View Source def set_gsm_voice ( self , state ) : \"\"\" Set GSM voice state (Emulator only) Android only . Args : state ( str ) : State of GSM voice . A member of the const ` appium . webdriver . extensions . android . gsm . GsmVoiceState ` Usage : self . driver . set_gsm_voice ( GsmVoiceState . HOME ) \"\"\" constants = extract_const_attributes ( GsmVoiceState ) if state not in constants . values () : logger . warning ( ' {} is unknown. Consider using one of {} constants. (e.g. {}.HOME) ' . format ( state , list ( constants . keys ()) , GsmVoiceState . __name__ )) self . execute ( Command . SET_GSM_VOICE , { ' state ' : state } ) return self","title":"set_gsm_voice"},{"location":"reference/appium/webdriver/webdriver/#set_location","text":"def set_location ( self , latitude , longitude , altitude = None ) Set the location of the device Args: latitude (Union[float, str]): String or numeric value between -90.0 and 90.00 longitude (Union[float, str]): String or numeric value between -180.0 and 180.0 altitude (Union[float, str], optional): String or numeric value (Android real device only) Returns: appium.webdriver.webdriver.WebDriver View Source def set_location ( self , latitude , longitude , altitude = None ) : \"\"\" Set the location of the device Args : latitude ( Union [ float , str ] ) : String or numeric value between - 90 . 0 and 90 . 00 longitude ( Union [ float , str ] ) : String or numeric value between - 180 . 0 and 180 . 0 altitude ( Union [ float , str ], optional ) : String or numeric value ( Android real device only ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { \" location \" : { \" latitude \" : latitude , \" longitude \" : longitude , } } if altitude is not None : data [ ' location ' ][ ' altitude ' ] = altitude self . execute ( Command . SET_LOCATION , data ) return self","title":"set_location"},{"location":"reference/appium/webdriver/webdriver/#set_network_connection","text":"def set_network_connection ( self , connection_type ) Sets the network connection type. Android only. Possible values: Value (Alias) | Data | Wifi | Airplane Mode ------------------------------------------------- 0 (None) | 0 | 0 | 0 1 (Airplane Mode) | 0 | 0 | 1 2 (Wifi only) | 0 | 1 | 0 4 (Data only) | 1 | 0 | 0 6 (All network on) | 1 | 1 | 0 These are available through the enumeration appium.webdriver.ConnectionType Args: connection_type (int): a member of the enum appium.webdriver.ConnectionType Returns: appium.webdriver.webdriver.WebDriver View Source def set_network_connection ( self , connection_type ) : \"\"\" Sets the network connection type. Android only. Possible values : Value ( Alias ) | Data | Wifi | Airplane Mode ------------------------------------------------- 0 ( None ) | 0 | 0 | 0 1 ( Airplane Mode ) | 0 | 0 | 1 2 ( Wifi only ) | 0 | 1 | 0 4 ( Data only ) | 1 | 0 | 0 6 ( All network on ) | 1 | 1 | 0 These are available through the enumeration ` appium . webdriver . ConnectionType ` Args : connection_type ( int ) : a member of the enum appium . webdriver . ConnectionType Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' parameters ' : { ' type ' : connection_type } } return self . execute ( Command . SET_NETWORK_CONNECTION , data ) [ ' value ' ]","title":"set_network_connection"},{"location":"reference/appium/webdriver/webdriver/#set_network_speed","text":"def set_network_speed ( self , speed_type ) Set the network speed emulation. Android Emulator only. Args: speed_type (str): The network speed type. A member of the const appium.webdriver.extensions.android.network.NetSpeed. Usage: self.driver.set_network_speed(NetSpeed.LTE) Returns: appium.webdriver.webdriver.WebDriver View Source def set_network_speed ( self , speed_type ) : \"\"\" Set the network speed emulation. Android Emulator only . Args : speed_type ( str ) : The network speed type . A member of the const appium . webdriver . extensions . android . network . NetSpeed . Usage : self . driver . set_network_speed ( NetSpeed . LTE ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" constants = extract_const_attributes ( NetSpeed ) if speed_type not in constants . values () : logger . warning ( ' {} is unknown. Consider using one of {} constants. (e.g. {}.LTE) ' . format ( speed_type , list ( constants . keys ()) , NetSpeed . __name__ )) self . execute ( Command . SET_NETWORK_SPEED , { ' netspeed ' : speed_type } ) return self","title":"set_network_speed"},{"location":"reference/appium/webdriver/webdriver/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/webdriver/#set_power_ac","text":"def set_power_ac ( self , ac_state ) Emulate power state change on the connected emulator. Android only. Args: ac_state (str): The power ac state to be set. Use .AC_OFF , .AC_ON Usage: self.driver.set_power_ac(Power.AC_OFF) self.driver.set_power_ac(Power.AC_ON) Returns: appium.webdriver.webdriver.WebDriver View Source def set_power_ac ( self , ac_state ) : \"\"\" Emulate power state change on the connected emulator. Android only . Args : ac_state ( str ) : The power ac state to be set . Use `. AC_OFF `, `. AC_ON ` Usage : self . driver . set_power_ac ( Power . AC_OFF ) self . driver . set_power_ac ( Power . AC_ON ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SET_POWER_AC , { ' state ' : ac_state } ) return self","title":"set_power_ac"},{"location":"reference/appium/webdriver/webdriver/#set_power_capacity","text":"def set_power_capacity ( self , percent ) Emulate power capacity change on the connected emulator. Android only. Args: percent (int): The power capacity to be set. Can be set from 0 to 100 Usage: self.driver.set_power_capacity(50) Returns: appium.webdriver.webdriver.WebDriver View Source def set_power_capacity ( self , percent ) : \"\"\" Emulate power capacity change on the connected emulator. Android only . Args : percent ( int ) : The power capacity to be set . Can be set from 0 to 100 Usage : self . driver . set_power_capacity ( 50 ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SET_POWER_CAPACITY , { ' percent ' : percent } ) return self","title":"set_power_capacity"},{"location":"reference/appium/webdriver/webdriver/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/webdriver/#set_value","text":"def set_value ( self , element , value ) Set the value on an element in the application. Args: element ( appium.webdriver.webelement.WebElement : the element whose value will be set value (str): the value to set on the element Returns: appium.webdriver.webdriver.WebDriver View Source def set_value ( self , element , value ) : \"\"\" Set the value on an element in the application. Args : element ( ` appium . webdriver . webelement . WebElement `: the element whose value will be set value ( str ) : the value to set on the element Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' id ' : element . id , ' value ' : [ value ], } self . execute ( Command . SET_IMMEDIATE_VALUE , data ) return self","title":"set_value"},{"location":"reference/appium/webdriver/webdriver/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/webdriver/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/webdriver/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/webdriver/#shake","text":"def shake ( self ) Shake the device. Returns: appium.webdriver.webdriver.WebDriver View Source def shake ( self ) : \"\"\" Shake the device. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SHAKE ) return self","title":"shake"},{"location":"reference/appium/webdriver/webdriver/#start_activity","text":"def start_activity ( self , app_package , app_activity , ** opts ) Opens an arbitrary activity during a test. If the activity belongs to another application, that application is started and the activity is opened. This is an Android-only method. Args: app_package (str): The package containing the activity to start. app_activity (str): The activity to start. Keyword Args: app_wait_package (str): Begin automation after this package starts. app_wait_activity (str): Begin automation after this activity starts. intent_action (str): Intent to start. intent_category (str): Intent category to start. intent_flags (str): Flags to send to the intent. optional_intent_arguments (str): Optional arguments to the intent. dont_stop_app_on_reset (str): Should the app be stopped on reset? View Source def start_activity ( self , app_package , app_activity , ** opts ) : \"\"\" Opens an arbitrary activity during a test. If the activity belongs to another application , that application is started and the activity is opened . This is an Android - only method . Args : app_package ( str ) : The package containing the activity to start . app_activity ( str ) : The activity to start . Keyword Args : app_wait_package ( str ) : Begin automation after this package starts . app_wait_activity ( str ) : Begin automation after this activity starts . intent_action ( str ) : Intent to start . intent_category ( str ) : Intent category to start . intent_flags ( str ) : Flags to send to the intent . optional_intent_arguments ( str ) : Optional arguments to the intent . dont_stop_app_on_reset ( str ) : Should the app be stopped on reset ? \"\"\" data = { ' appPackage ' : app_package , ' appActivity ' : app_activity } arguments = { ' app_wait_package ' : ' appWaitPackage ' , ' app_wait_activity ' : ' appWaitActivity ' , ' intent_action ' : ' intentAction ' , ' intent_category ' : ' intentCategory ' , ' intent_flags ' : ' intentFlags ' , ' optional_intent_arguments ' : ' optionalIntentArguments ' , ' dont_stop_app_on_reset ' : ' dontStopAppOnReset ' } for key , value in arguments . items () : if key in opts : data [ value ] = opts [ key ] self . execute ( Command . START_ACTIVITY , data ) return self","title":"start_activity"},{"location":"reference/appium/webdriver/webdriver/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/webdriver/#start_recording_screen","text":"def start_recording_screen ( self , ** options ) Start asynchronous screen recording process. Keyword Args: remotePath (str): The remotePath upload option is the path to the remote location, where the resulting video from the previous screen recording should be uploaded. The following protocols are supported: http/https (multipart), ftp. Missing value (the default setting) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value, but an exception will be thrown if the generated media file is too big to fit into the available process memory. This option only has an effect if there is/was an active screen recording session and forced restart is not enabled (the default setting). user (str): The name of the user for the remote authentication. Only has an effect if both remotePath and password are set. password (str): The password for the remote authentication. Only has an effect if both remotePath and user are set. method (str): The HTTP method name ('PUT'/'POST'). PUT method is used by default. Only has an effect if remotePath is set. timeLimit (int): The actual time limit of the recorded video in seconds. The default value for both iOS and Android is 180 seconds (3 minutes). The maximum value for Android is 3 minutes. The maximum value for iOS is 10 minutes. forcedRestart (bool): Whether to ignore the result of previous capture and start a new recording immediately ( True value). By default ( False ) the endpoint will try to catch and return the result of the previous capture if it's still available. bugReport (str): Makes the recorder to display an additional information on the video overlay, such as a timestamp, that is helpful in videos captured to illustrate bugs. This option is only supported since API level 27 (Android P). videoQuality ( str ) : [ iOS only ] The video encoding quality : ' low ' , ' medium ' , ' high ' , ' photo ' . Defaults to ' medium ' . videoType ( str ) : [ iOS only ] The format of the screen capture to be recorded . Available formats : Execute ` ffmpeg - codecs ` in the terminal to see the list of supported video codecs . ' mjpeg ' by default . ( Since Appium 1.10.0 ) videoFps ( int ) : [ iOS only ] The Frames Per Second rate of the recorded video . Change this value if the resulting video is too slow or too fast . Defaults to 10. This can decrease the resulting file size . videoFilters ( str ) : [ iOS only ] The FFMPEG video filters to apply . These filters allow to scale , flip , rotate and do many other useful transformations on the source video stream . The format of the property must comply with https : //ffmpeg.org/ffmpeg-filters.html. (Since Appium 1.15) videoScale ( str ) : [ iOS only ] The scaling value to apply . Read https : //trac.ffmpeg.org/wiki/Scaling for possible values. No scale is applied by default . If videoFilters are set then the scale setting is effectively ignored . ( Since Appium 1.10.0 ) pixelFormat ( str ) : [ iOS only ] Output pixel format . Run ` ffmpeg - pix_fmts ` to list possible values . For Quicktime compatibility , set to \"yuv420p\" along with videoType : \"libx264\" . ( Since Appium 1.12.0 ) videoSize ( str ) : [ Android only ] The video size of the generated media file . The format is WIDTHxHEIGHT . The default value is the device ' s native display resolution ( if supported ), 1280 x720 if not . For best results , use a size supported by your device ' s Advanced Video Coding ( AVC ) encoder . bitRate ( int ) : [ Android only ] The video bit rate for the video , in megabits per second . The default value is 4. You can increase the bit rate to improve video quality , but doing so results in larger movie files . Returns: bytes: Base-64 encoded content of the recorded media if stop_recording_screen isn't called after previous start_recording_screen . Otherwise returns an empty string. View Source def start_recording_screen ( self , ** options ) : \"\"\"Start asynchronous screen recording process. Keyword Args : remotePath ( str ) : The remotePath upload option is the path to the remote location , where the resulting video from the previous screen recording should be uploaded . The following protocols are supported : http / https ( multipart ), ftp . Missing value ( the default setting ) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value , but an exception will be thrown if the generated media file is too big to fit into the available process memory . This option only has an effect if there is / was an active screen recording session and forced restart is not enabled ( the default setting ). user ( str ) : The name of the user for the remote authentication . Only has an effect if both ` remotePath ` and ` password ` are set . password ( str ) : The password for the remote authentication . Only has an effect if both ` remotePath ` and ` user ` are set . method ( str ) : The HTTP method name ( ' PUT '/' POST ' ). PUT method is used by default . Only has an effect if ` remotePath ` is set . timeLimit ( int ) : The actual time limit of the recorded video in seconds . The default value for both iOS and Android is 180 seconds ( 3 minutes ). The maximum value for Android is 3 minutes . The maximum value for iOS is 10 minutes . forcedRestart ( bool ) : Whether to ignore the result of previous capture and start a new recording immediately ( ` True ` value ). By default ( ` False ` ) the endpoint will try to catch and return the result of the previous capture if it ' s still available . bugReport ( str ) : Makes the recorder to display an additional information on the video overlay , such as a timestamp , that is helpful in videos captured to illustrate bugs . This option is only supported since API level 27 ( Android P ). videoQuality ( str ) : [ iOS only ] The video encoding quality : ' low ' , ' medium ' , ' high ' , ' photo ' . Defaults to ' medium ' . videoType ( str ) : [ iOS only ] The format of the screen capture to be recorded . Available formats : Execute ` ffmpeg - codecs ` in the terminal to see the list of supported video codecs . ' mjpeg ' by default . ( Since Appium 1.10.0 ) videoFps ( int ) : [ iOS only ] The Frames Per Second rate of the recorded video . Change this value if the resulting video is too slow or too fast . Defaults to 10. This can decrease the resulting file size . videoFilters ( str ) : [ iOS only ] The FFMPEG video filters to apply . These filters allow to scale , flip , rotate and do many other useful transformations on the source video stream . The format of the property must comply with https : //ffmpeg.org/ffmpeg-filters.html. (Since Appium 1.15) videoScale ( str ) : [ iOS only ] The scaling value to apply . Read https : //trac.ffmpeg.org/wiki/Scaling for possible values. No scale is applied by default . If videoFilters are set then the scale setting is effectively ignored . ( Since Appium 1.10.0 ) pixelFormat ( str ) : [ iOS only ] Output pixel format . Run ` ffmpeg - pix_fmts ` to list possible values . For Quicktime compatibility , set to \"yuv420p\" along with videoType : \"libx264\" . ( Since Appium 1.12.0 ) videoSize ( str ) : [ Android only ] The video size of the generated media file . The format is WIDTHxHEIGHT . The default value is the device ' s native display resolution ( if supported ), 1280 x720 if not . For best results , use a size supported by your device ' s Advanced Video Coding ( AVC ) encoder . bitRate ( int ) : [ Android only ] The video bit rate for the video , in megabits per second . The default value is 4. You can increase the bit rate to improve video quality , but doing so results in larger movie files . Returns : bytes : Base - 64 encoded content of the recorded media if ` stop_recording_screen ` isn ' t called after previous ` start_recording_screen ` . Otherwise returns an empty string . \"\"\" if ' password ' in options : options [ ' pass ' ] = options [ ' password ' ] del options [ ' password ' ] return self . execute ( Command . START_RECORDING_SCREEN , { ' options ' : options })[ ' value ' ]","title":"start_recording_screen"},{"location":"reference/appium/webdriver/webdriver/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. Override for Appium Args: automation_name: The name of automation engine to use. platform_name: The name of target platform. platform_version: The kind of mobile device or emulator to use app: The absolute local path or remote http URL to an .ipa or .apk file, or a .zip containing one of these. Read https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/caps.md for more details. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities. Override for Appium Args : automation_name : The name of automation engine to use . platform_name : The name of target platform . platform_version : The kind of mobile device or emulator to use app : The absolute local path or remote http URL to an . ipa or . apk file , or a . zip containing one of these . Read https : // github . com / appium / appium / blob / master / docs / en / writing - running - appium / caps . md for more details . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( ' Capabilities must be a dictionary ' ) if browser_profile : if ' moz:firefoxOptions ' in capabilities : capabilities [ ' moz:firefoxOptions ' ][ ' profile ' ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) parameters = self . _merge_capabilities ( capabilities ) response = self . execute ( RemoteCommand . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/webdriver/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/webdriver/#stop_recording_screen","text":"def stop_recording_screen ( self , ** options ) Gather the output from the previously started screen recording to a media file. Keyword Args: remotePath (str): The remotePath upload option is the path to the remote location, where the resulting video should be uploaded. The following protocols are supported: http/https (multipart), ftp. Missing value (the default setting) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value, but an exception will be thrown if the generated media file is too big to fit into the available process memory. user (str): The name of the user for the remote authentication. Only has an effect if both remotePath and password are set. password (str): The password for the remote authentication. Only has an effect if both remotePath and user are set. method (str): The HTTP method name ('PUT'/'POST'). PUT method is used by default. Only has an effect if remotePath is set. Returns: bytes: Base-64 encoded content of the recorded media file or an empty string if the file has been successfully uploaded to a remote location (depends on the actual remotePath value). View Source def stop_recording_screen ( self , ** options ) : \"\"\" Gather the output from the previously started screen recording to a media file. Keyword Args : remotePath ( str ) : The remotePath upload option is the path to the remote location , where the resulting video should be uploaded . The following protocols are supported : http / https ( multipart ) , ftp . Missing value ( the default setting ) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value , but an exception will be thrown if the generated media file is too big to fit into the available process memory . user ( str ) : The name of the user for the remote authentication . Only has an effect if both ` remotePath ` and ` password ` are set . password ( str ) : The password for the remote authentication . Only has an effect if both ` remotePath ` and ` user ` are set . method ( str ) : The HTTP method name ( ' PUT ' / ' POST ' ) . PUT method is used by default . Only has an effect if ` remotePath ` is set . Returns : bytes : Base - 64 encoded content of the recorded media file or an empty string if the file has been successfully uploaded to a remote location ( depends on the actual ` remotePath ` value ) . \"\"\" if ' password ' in options : options [ ' pass ' ] = options [ ' password ' ] del options [ ' password ' ] return self . execute ( Command . STOP_RECORDING_SCREEN , { ' options ' : options } ) [ ' value ' ]","title":"stop_recording_screen"},{"location":"reference/appium/webdriver/webdriver/#swipe","text":"def swipe ( self , start_x , start_y , end_x , end_y , duration = None ) Swipe from one point to another point, for an optional duration. Args: start_x (int): x-coordinate at which to start start_y (int): y-coordinate at which to start end_x (int): x-coordinate at which to stop end_y (int): y-coordinate at which to stop duration (:obj: int , optional): time to take the swipe, in ms. Usage: driver.swipe(100, 100, 100, 400) Returns: appium.webdriver.webelement.WebElement View Source def swipe ( self , start_x , start_y , end_x , end_y , duration = None ) : \"\"\" Swipe from one point to another point, for an optional duration. Args : start_x ( int ) : x - coordinate at which to start start_y ( int ) : y - coordinate at which to start end_x ( int ) : x - coordinate at which to stop end_y ( int ) : y - coordinate at which to stop duration ( : obj :` int `, optional ) : time to take the swipe , in ms . Usage : driver . swipe ( 100 , 100 , 100 , 400 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" # ` swipe ` is something like press - wait - move_to - release , which the server # will translate into the correct action action = TouchAction ( self ) action \\ . press ( x = start_x , y = start_y ) \\ . wait ( ms = duration ) \\ . move_to ( x = end_x , y = end_y ) \\ . release () action . perform () return self","title":"swipe"},{"location":"reference/appium/webdriver/webdriver/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/webdriver/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/webdriver/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/webdriver/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/webdriver/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/webdriver/#tap","text":"def tap ( self , positions , duration = None ) Taps on an particular place with up to five fingers, holding for a certain time Args: positions (:obj: list of :obj: tuple ): an array of tuples representing the x/y coordinates of the fingers to tap. Length can be up to five. duration (:obj: int , optional): length of time to tap, in ms Usage: driver.tap([(100, 20), (100, 60), (100, 100)], 500) Returns: appium.webdriver.webelement.WebElement View Source def tap ( self , positions , duration = None ) : \"\"\" Taps on an particular place with up to five fingers, holding for a certain time Args : positions ( : obj :` list ` of : obj :` tuple ` ) : an array of tuples representing the x / y coordinates of the fingers to tap . Length can be up to five . duration ( : obj :` int `, optional ) : length of time to tap , in ms Usage : driver . tap ( [ ( 100 , 20 ) , ( 100 , 60 ) , ( 100 , 100 ) ], 500 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" if len ( positions ) == 1 : action = TouchAction ( self ) x = positions [ 0 ][ 0 ] y = positions [ 0 ][ 1 ] if duration : action . long_press ( x = x , y = y , duration = duration ) . release () else : action . tap ( x = x , y = y ) action . perform () else : ma = MultiAction ( self ) for position in positions : x = position [ 0 ] y = position [ 1 ] action = TouchAction ( self ) if duration : action . long_press ( x = x , y = y , duration = duration ) . release () else : action . press ( x = x , y = y ) . release () ma . add ( action ) ma . perform () return self","title":"tap"},{"location":"reference/appium/webdriver/webdriver/#terminate_app","text":"def terminate_app ( self , app_id , ** options ) Terminates the application if it is running. Args: app_id (str): the application id to be terminates Keyword Args: timeout (int): [Android only] how much time to wait for the uninstall to complete. 500ms by default. Returns: bool: True if the app has been successfully terminated View Source def terminate_app ( self , app_id , ** options ) : \"\"\"Terminates the application if it is running. Args : app_id ( str ) : the application id to be terminates Keyword Args : ` timeout ` ( int ) : [ Android only ] how much time to wait for the uninstall to complete . 500 ms by default . Returns : bool : True if the app has been successfully terminated \"\"\" data = { ' appId ' : app_id , } if options : data . update ({ ' options ' : options }) return self . execute ( Command . TERMINATE_APP , data )[ ' value ' ]","title":"terminate_app"},{"location":"reference/appium/webdriver/webdriver/#toggle_location_services","text":"def toggle_location_services ( self ) Toggle the location services on the device. Android only. Returns: appium.webdriver.webdriver.WebDriver View Source def toggle_location_services ( self ) : \"\"\" Toggle the location services on the device. Android only . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . TOGGLE_LOCATION_SERVICES , {} ) return self","title":"toggle_location_services"},{"location":"reference/appium/webdriver/webdriver/#toggle_touch_id_enrollment","text":"def toggle_touch_id_enrollment ( self ) Toggle enroll touchId on iOS Simulator Returns: appium.webdriver.webdriver.WebDriver View Source def toggle_touch_id_enrollment ( self ) : \"\"\" Toggle enroll touchId on iOS Simulator Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . TOGGLE_TOUCH_ID_ENROLLMENT ) return self","title":"toggle_touch_id_enrollment"},{"location":"reference/appium/webdriver/webdriver/#toggle_wifi","text":"def toggle_wifi ( self ) Toggle the wifi on the device, Android only. Returns: appium.webdriver.webdriver.WebDriver View Source def toggle_wifi ( self ) : \"\"\" Toggle the wifi on the device, Android only. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . TOGGLE_WIFI , {} ) return self","title":"toggle_wifi"},{"location":"reference/appium/webdriver/webdriver/#touch_id","text":"def touch_id ( self , match ) Simulate touchId on iOS Simulator Args: match (bool): Simulates a successful touch ( True ) or a failed touch ( False ) Returns: appium.webdriver.webdriver.WebDriver View Source def touch_id ( self , match ) : \"\"\" Simulate touchId on iOS Simulator Args : match ( bool ) : Simulates a successful touch ( ` True ` ) or a failed touch ( ` False ` ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' match ' : match } self . execute ( Command . TOUCH_ID , data ) return self","title":"touch_id"},{"location":"reference/appium/webdriver/webdriver/#unlock","text":"def unlock ( self ) Unlock the device. No changes are made if the device is already locked. Returns: appium.webdriver.webdriver.WebDriver View Source def unlock ( self ) : \"\"\" Unlock the device. No changes are made if the device is already locked. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . UNLOCK ) return self","title":"unlock"},{"location":"reference/appium/webdriver/webdriver/#update_settings","text":"def update_settings ( self , settings ) Set settings for the current session. For more on settings, see: https://github.com/appium/appium/blob/master/docs/en/advanced-concepts/settings.md Args: settings (dict): dictionary of settings to apply to the current test session View Source def update_settings ( self , settings ) : \"\"\" Set settings for the current session. For more on settings , see : https : // github . com / appium / appium / blob / master / docs / en / advanced - concepts / settings . md Args : settings ( dict ) : dictionary of settings to apply to the current test session \"\"\" data = { \" settings \" : settings } self . execute ( Command . UPDATE_SETTINGS , data ) return self","title":"update_settings"},{"location":"reference/appium/webdriver/webdriver/#wait_activity","text":"def wait_activity ( self , activity , timeout , interval = 1 ) Wait for an activity: block until target activity presents or time out. This is an Android-only method. Args: activity (str): target activity timeout (int): max wait time, in seconds interval (int): sleep interval between retries, in seconds View Source def wait_activity ( self , activity , timeout , interval = 1 ) : \"\"\" Wait for an activity: block until target activity presents or time out. This is an Android - only method . Args : activity ( str ) : target activity timeout ( int ) : max wait time , in seconds interval ( int ) : sleep interval between retries , in seconds \"\"\" try : WebDriverWait ( self , timeout , interval ) . until ( lambda d : d . current_activity == activity ) return True except TimeoutException : return False","title":"wait_activity"},{"location":"reference/appium/webdriver/webelement/","text":"Module appium.webdriver.webelement View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import json from selenium.webdriver.common.by import By from selenium.webdriver.remote.command import Command as RemoteCommand from appium.webdriver.common.mobileby import MobileBy from .extensions.search_context import AppiumWebElementSearchContext from .mobilecommand import MobileCommand as Command # Python 3 imports try : str = basestring except NameError : pass class WebElement ( AppiumWebElementSearchContext ): # Override def get_attribute ( self , name ): \"\"\"Gets the given attribute or property of the element. This method will first try to return the value of a property with the given name. If a property with that name doesn't exist, it returns the value of the attribute with the same name. If there's no attribute with that name, ``None`` is returned. Values which are considered truthy, that is equals \"true\" or \"false\", are returned as booleans. All other non-``None`` values are returned as strings. For attributes or properties which do not exist, ``None`` is returned. Args: name (str): Name of the attribute/property to retrieve. Usage: # Check if the \"active\" CSS class is applied to an element. is_active = \"active\" in target_element.get_attribute(\"class\") Returns: str: The given attribute or property of the element \"\"\" resp = self . _execute ( RemoteCommand . GET_ELEMENT_ATTRIBUTE , { 'name' : name }) attributeValue = resp . get ( 'value' ) if attributeValue is None : return None if not isinstance ( attributeValue , str ): attributeValue = unicode ( attributeValue ) if name != 'value' and attributeValue . lower () in ( 'true' , 'false' ): return attributeValue . lower () return attributeValue # Override def is_displayed ( self ): \"\"\"Whether the element is visible to a user.\"\"\" return self . _execute ( RemoteCommand . IS_ELEMENT_DISPLAYED )[ 'value' ] def find_element_by_ios_uiautomation ( self , uia_string ): \"\"\"Finds an element by uiautomation in iOS. Args: uia_string (str): The element name in the iOS UIAutomation library Usage: driver.find_element_by_ios_uiautomation('.elements()[1].cells()[2]') Returns: `appium.webdriver.webelement.WebElement` \"\"\" return self . find_element ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string ) def find_elements_by_ios_uiautomation ( self , uia_string ): \"\"\"Finds elements by uiautomation in iOS. Args: uia_string (str): The element name in the iOS UIAutomation library Usage: driver.find_elements_by_ios_uiautomation('.elements()[1].cells()[2]') Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` \"\"\" return self . find_elements ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string ) def find_element_by_ios_predicate ( self , predicate_string ): \"\"\"Find an element by ios predicate string. Args: predicate_string (str): The predicate string Usage: driver.find_element_by_ios_predicate('label == \"myLabel\"') Returns: `appium.webdriver.webelement.WebElement` \"\"\" return self . find_element ( by = MobileBy . IOS_PREDICATE , value = predicate_string ) def find_elements_by_ios_predicate ( self , predicate_string ): \"\"\"Finds elements by ios predicate string. Args: predicate_string (str): The predicate string Usage: driver.find_elements_by_ios_predicate('label == \"myLabel\"') Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` \"\"\" return self . find_elements ( by = MobileBy . IOS_PREDICATE , value = predicate_string ) def find_element_by_ios_class_chain ( self , class_chain_string ): \"\"\"Find an element by ios class chain string. Args: class_chain_string (str): The class chain string Usage: driver.find_element_by_ios_class_chain('XCUIElementTypeWindow/XCUIElementTypeButton[3]') Returns: `appium.webdriver.webelement.WebElement` \"\"\" return self . find_element ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string ) def find_elements_by_ios_class_chain ( self , class_chain_string ): \"\"\"Finds elements by ios class chain string. Args: class_chain_string (str): The class chain string Usage: driver.find_elements_by_ios_class_chain('XCUIElementTypeWindow[2]/XCUIElementTypeAny[-2]') Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` \"\"\" return self . find_elements ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string ) def find_element_by_android_uiautomator ( self , uia_string ): \"\"\"Finds element by uiautomator in Android. Args: uia_string (str): The element name in the Android UIAutomator library Usage: driver.find_element_by_android_uiautomator('.elements()[1].cells()[2]') Returns: `appium.webdriver.webelement.WebElement` \"\"\" return self . find_element ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string ) def find_elements_by_android_uiautomator ( self , uia_string ): \"\"\"Finds elements by uiautomator in Android. Args: uia_string (str): The element name in the Android UIAutomator library Usage: driver.find_elements_by_android_uiautomator('.elements()[1].cells()[2]') Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` \"\"\" return self . find_elements ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string ) def find_element_by_accessibility_id ( self , accessibility_id ): \"\"\"Finds an element by accessibility id. Args: accessibility_id (str): a string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize Usage: driver.find_element_by_accessibility_id() Returns: `appium.webdriver.webelement.WebElement` \"\"\" return self . find_element ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id ) def find_elements_by_accessibility_id ( self , accessibility_id ): \"\"\"Finds elements by accessibility id. Args: accessibility_id (str): a string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize Usage: driver.find_elements_by_accessibility_id() Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` \"\"\" return self . find_elements ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id ) def find_element ( self , by = By . ID , value = None ): \"\"\"Find an element given a By strategy and locator Prefer the find_element_by_* methods when possible. Args: by (:obj:`str`, optional): The strategy value (:obj:`str`, optional): The locator Usage: element = element.find_element(By.ID, 'foo') Returns: `appium.webdriver.webelement.WebElement` \"\"\" # TODO: If we need, we should enable below converter for Web context # if self._w3c: # if by == By.ID: # by = By.CSS_SELECTOR # value = '[id=\"%s\"]' % value # elif by == By.TAG_NAME: # by = By.CSS_SELECTOR # elif by == By.CLASS_NAME: # by = By.CSS_SELECTOR # value = \".%s\" % value # elif by == By.NAME: # by = By.CSS_SELECTOR # value = '[name=\"%s\"]' % value return self . _execute ( RemoteCommand . FIND_CHILD_ELEMENT , { \"using\" : by , \"value\" : value })[ 'value' ] def find_elements ( self , by = By . ID , value = None ): \"\"\"Find elements given a By strategy and locator Prefer the find_elements_by_* methods when possible. Args: by (:obj:`str`, optional): The strategy value (:obj:`str`, optional): The locator Usage: element = element.find_elements(By.CLASS_NAME, 'foo') Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` \"\"\" # TODO: If we need, we should enable below converter for Web context # if self._w3c: # if by == By.ID: # by = By.CSS_SELECTOR # value = '[id=\"%s\"]' % value # elif by == By.TAG_NAME: # by = By.CSS_SELECTOR # elif by == By.CLASS_NAME: # by = By.CSS_SELECTOR # value = \".%s\" % value # elif by == By.NAME: # by = By.CSS_SELECTOR # value = '[name=\"%s\"]' % value return self . _execute ( RemoteCommand . FIND_CHILD_ELEMENTS , { \"using\" : by , \"value\" : value })[ 'value' ] def set_text ( self , keys = '' ): \"\"\"Sends text to the element. Previous text is removed. Android only. Args: keys (str): the text to be sent to the element. Usage: element.set_text('some text') Returns: `appium.webdriver.webelement.WebElement` \"\"\" data = { 'id' : self . _id , 'value' : [ keys ] } self . _execute ( Command . REPLACE_KEYS , data ) return self @property def location_in_view ( self ): \"\"\"Gets the location of an element relative to the view. Usage: location = element.location_in_view x = location['x'] y = location['y'] Returns: dict: The location of an element relative to the view \"\"\" return self . _execute ( Command . LOCATION_IN_VIEW )[ 'value' ] def set_value ( self , value ): \"\"\"Set the value on this element in the application Args: value (str): The value to be set Returns: `appium.webdriver.webelement.WebElement` \"\"\" data = { 'id' : self . id , 'value' : [ value ], } self . _execute ( Command . SET_IMMEDIATE_VALUE , data ) return self def clear ( self ): \"\"\"Clears text. Returns: `appium.webdriver.webelement.WebElement` \"\"\" data = { 'id' : self . id } self . _execute ( Command . CLEAR , data ) return self Classes WebElement class WebElement ( parent , id_ , w3c = False ) Returns appium web element search context View Source class WebElement ( AppiumWebElementSearchContext ) : # Override def get_attribute ( self , name ) : \"\"\" Gets the given attribute or property of the element. This method will first try to return the value of a property with the given name . If a property with that name doesn ' t exist, it returns the value of the attribute with the same name . If there ' s no attribute with that name , `` None `` is returned . Values which are considered truthy , that is equals \" true \" or \" false \" , are returned as booleans . All other non - `` None `` values are returned as strings . For attributes or properties which do not exist , `` None `` is returned . Args : name ( str ) : Name of the attribute / property to retrieve . Usage : # Check if the \" active \" CSS class is applied to an element . is_active = \" active \" in target_element . get_attribute ( \" class \" ) Returns : str : The given attribute or property of the element \"\"\" resp = self . _execute ( RemoteCommand . GET_ELEMENT_ATTRIBUTE , { ' name ' : name } ) attributeValue = resp . get ( ' value ' ) if attributeValue is None : return None if not isinstance ( attributeValue , str ) : attributeValue = unicode ( attributeValue ) if name != ' value ' and attributeValue . lower () in ( ' true ' , ' false ' ) : return attributeValue . lower () return attributeValue # Override def is_displayed ( self ) : \"\"\" Whether the element is visible to a user. \"\"\" return self . _execute ( RemoteCommand . IS_ELEMENT_DISPLAYED ) [ ' value ' ] def find_element_by_ios_uiautomation ( self , uia_string ) : \"\"\" Finds an element by uiautomation in iOS. Args : uia_string ( str ) : The element name in the iOS UIAutomation library Usage : driver . find_element_by_ios_uiautomation ( ' .elements()[1].cells()[2] ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string ) def find_elements_by_ios_uiautomation ( self , uia_string ) : \"\"\" Finds elements by uiautomation in iOS. Args : uia_string ( str ) : The element name in the iOS UIAutomation library Usage : driver . find_elements_by_ios_uiautomation ( ' .elements()[1].cells()[2] ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string ) def find_element_by_ios_predicate ( self , predicate_string ) : \"\"\" Find an element by ios predicate string. Args : predicate_string ( str ) : The predicate string Usage : driver . find_element_by_ios_predicate ( ' label == \"myLabel\" ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_PREDICATE , value = predicate_string ) def find_elements_by_ios_predicate ( self , predicate_string ) : \"\"\" Finds elements by ios predicate string. Args : predicate_string ( str ) : The predicate string Usage : driver . find_elements_by_ios_predicate ( ' label == \"myLabel\" ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_PREDICATE , value = predicate_string ) def find_element_by_ios_class_chain ( self , class_chain_string ) : \"\"\" Find an element by ios class chain string. Args : class_chain_string ( str ) : The class chain string Usage : driver . find_element_by_ios_class_chain ( ' XCUIElementTypeWindow/XCUIElementTypeButton[3] ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string ) def find_elements_by_ios_class_chain ( self , class_chain_string ) : \"\"\" Finds elements by ios class chain string. Args : class_chain_string ( str ) : The class chain string Usage : driver . find_elements_by_ios_class_chain ( ' XCUIElementTypeWindow[2]/XCUIElementTypeAny[-2] ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string ) def find_element_by_android_uiautomator ( self , uia_string ) : \"\"\" Finds element by uiautomator in Android. Args : uia_string ( str ) : The element name in the Android UIAutomator library Usage : driver . find_element_by_android_uiautomator ( ' .elements()[1].cells()[2] ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_element ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string ) def find_elements_by_android_uiautomator ( self , uia_string ) : \"\"\" Finds elements by uiautomator in Android. Args : uia_string ( str ) : The element name in the Android UIAutomator library Usage : driver . find_elements_by_android_uiautomator ( ' .elements()[1].cells()[2] ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_elements ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string ) def find_element_by_accessibility_id ( self , accessibility_id ) : \"\"\" Finds an element by accessibility id. Args : accessibility_id ( str ) : a string corresponding to a recursive element search using the Id / Name that the native Accessibility options utilize Usage : driver . find_element_by_accessibility_id () Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_element ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id ) def find_elements_by_accessibility_id ( self , accessibility_id ) : \"\"\" Finds elements by accessibility id. Args : accessibility_id ( str ) : a string corresponding to a recursive element search using the Id / Name that the native Accessibility options utilize Usage : driver . find_elements_by_accessibility_id () Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_elements ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id ) def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator Prefer the find_element_by_ * methods when possible . Args : by ( : obj :` str `, optional ) : The strategy value ( : obj :` str `, optional ) : The locator Usage : element = element . find_element ( By . ID , ' foo ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" # TODO : If we need , we should enable below converter for Web context # if self . _w3c : # if by == By . ID : # by = By . CSS_SELECTOR # value = ' [id=\"%s\"] ' % value # elif by == By . TAG_NAME : # by = By . CSS_SELECTOR # elif by == By . CLASS_NAME : # by = By . CSS_SELECTOR # value = \" .%s \" % value # elif by == By . NAME : # by = By . CSS_SELECTOR # value = ' [name=\"%s\"] ' % value return self . _execute ( RemoteCommand . FIND_CHILD_ELEMENT , { \" using \" : by , \" value \" : value } ) [ ' value ' ] def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator Prefer the find_elements_by_ * methods when possible . Args : by ( : obj :` str `, optional ) : The strategy value ( : obj :` str `, optional ) : The locator Usage : element = element . find_elements ( By . CLASS_NAME , ' foo ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" # TODO : If we need , we should enable below converter for Web context # if self . _w3c : # if by == By . ID : # by = By . CSS_SELECTOR # value = ' [id=\"%s\"] ' % value # elif by == By . TAG_NAME : # by = By . CSS_SELECTOR # elif by == By . CLASS_NAME : # by = By . CSS_SELECTOR # value = \" .%s \" % value # elif by == By . NAME : # by = By . CSS_SELECTOR # value = ' [name=\"%s\"] ' % value return self . _execute ( RemoteCommand . FIND_CHILD_ELEMENTS , { \" using \" : by , \" value \" : value } ) [ ' value ' ] def set_text ( self , keys = '' ) : \"\"\" Sends text to the element. Previous text is removed . Android only . Args : keys ( str ) : the text to be sent to the element . Usage : element . set_text ( ' some text ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" data = { ' id ' : self . _id , ' value ' : [ keys ] } self . _execute ( Command . REPLACE_KEYS , data ) return self @ property def location_in_view ( self ) : \"\"\" Gets the location of an element relative to the view. Usage : location = element . location_in_view x = location [ ' x ' ] y = location [ ' y ' ] Returns : dict : The location of an element relative to the view \"\"\" return self . _execute ( Command . LOCATION_IN_VIEW ) [ ' value ' ] def set_value ( self , value ) : \"\"\" Set the value on this element in the application Args : value ( str ) : The value to be set Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" data = { ' id ' : self . id , ' value ' : [ value ], } self . _execute ( Command . SET_IMMEDIATE_VALUE , data ) return self def clear ( self ) : \"\"\" Clears text. Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" data = { ' id ' : self . id } self . _execute ( Command . CLEAR , data ) return self Ancestors (in MRO) appium.webdriver.extensions.search_context.AppiumWebElementSearchContext selenium.webdriver.remote.webelement.WebElement appium.webdriver.extensions.search_context.AndroidSearchContext appium.webdriver.extensions.search_context.BaseSearchContext Instance variables id Internal ID used by selenium. This is mainly for internal use. Simple use cases such as checking if 2 webelements refer to the same element, can be done using == :: if element1 == element2 : print ( \" These 2 are equal \" ) location The location of the element in the renderable canvas. location_in_view Gets the location of an element relative to the view. Usage: location = element.location_in_view x = location['x'] y = location['y'] Returns: dict: The location of an element relative to the view location_once_scrolled_into_view THIS PROPERTY MAY CHANGE WITHOUT WARNING. Use this to discover where on the screen an element is so that we can click it. This method should cause the element to be scrolled into view. Returns the top lefthand corner location on the screen, or None if the element is not visible. parent Internal reference to the WebDriver instance this element was found from. rect A dictionary with the size and location of the element. screenshot_as_base64 Gets the screenshot of the current element as a base64 encoded string. :Usage: img_b64 = element.screenshot_as_base64 screenshot_as_png Gets the screenshot of the current element as a binary data. :Usage: element_png = element.screenshot_as_png size The size of the element. tag_name This element's tagName property. text The text of the element. Methods clear def clear ( self ) Clears text. Returns: appium.webdriver.webelement.WebElement View Source def clear ( self ) : \"\"\" Clears text. Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" data = { ' id ' : self . id } self . _execute ( Command . CLEAR , data ) return self click def click ( self ) Clicks the element. View Source def click ( self ): \"\"\"Clicks the element.\"\"\" self . _execute ( Command . CLICK_ELEMENT ) find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator Prefer the find_element_by_* methods when possible. Args: by (:obj: str , optional): The strategy value (:obj: str , optional): The locator Usage: element = element.find_element(By.ID, 'foo') Returns: appium.webdriver.webelement.WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator Prefer the find_element_by_ * methods when possible . Args : by ( : obj :` str `, optional ) : The strategy value ( : obj :` str `, optional ) : The locator Usage : element = element . find_element ( By . ID , ' foo ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" # TODO : If we need , we should enable below converter for Web context # if self . _w3c : # if by == By . ID : # by = By . CSS_SELECTOR # value = ' [id=\"%s\"] ' % value # elif by == By . TAG_NAME : # by = By . CSS_SELECTOR # elif by == By . CLASS_NAME : # by = By . CSS_SELECTOR # value = \" .%s \" % value # elif by == By . NAME : # by = By . CSS_SELECTOR # value = ' [name=\"%s\"] ' % value return self . _execute ( RemoteCommand . FIND_CHILD_ELEMENT , { \" using \" : by , \" value \" : value } ) [ ' value ' ] find_element_by_accessibility_id def find_element_by_accessibility_id ( self , accessibility_id ) Finds an element by accessibility id. Args: accessibility_id (str): a string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize Usage: driver.find_element_by_accessibility_id() Returns: appium.webdriver.webelement.WebElement View Source def find_element_by_accessibility_id ( self , accessibility_id ) : \"\"\" Finds an element by accessibility id. Args : accessibility_id ( str ) : a string corresponding to a recursive element search using the Id / Name that the native Accessibility options utilize Usage : driver . find_element_by_accessibility_id () Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_element ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id ) find_element_by_android_data_matcher def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) Finds element by onData in Android It works with Espresso Driver . Args: name (:obj: str , optional): The name of a method to invoke. The method must return a Hamcrest Matcher args (:obj: str , optional): The args provided to the method className (:obj: str , optional): The class name that the method is part of (defaults to org.hamcrest.Matchers ). Can be fully qualified, or simple, and simple defaults to androidx.test.espresso.matcher package (e.g.: class=CursorMatchers fully qualified is class=androidx.test.espresso.matcher.CursorMatchers Returns: appium.webdriver.webelement.WebElement : The found element Raises: TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage: driver.find_element_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) View Source def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds element by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found element Raises : TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage : driver . find_element_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_element ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) ) find_element_by_android_uiautomator def find_element_by_android_uiautomator ( self , uia_string ) Finds element by uiautomator in Android. Args: uia_string (str): The element name in the Android UIAutomator library Usage: driver.find_element_by_android_uiautomator('.elements()[1].cells()[2]') Returns: appium.webdriver.webelement.WebElement View Source def find_element_by_android_uiautomator ( self , uia_string ) : \"\"\" Finds element by uiautomator in Android. Args : uia_string ( str ) : The element name in the Android UIAutomator library Usage : driver . find_element_by_android_uiautomator ( ' .elements()[1].cells()[2] ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_element ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string ) find_element_by_class_name def find_element_by_class_name ( self , name ) Finds element within this element's children by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds element within this element's children by class name. :Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds element within this element's children by CSS selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds element within this element's children by CSS selector. :Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds element within this element's children by ID. :Args: - id_ - ID of child element to locate. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: foo_element = element.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds element within this element's children by ID. :Args : - id \\ _ - ID of child element to locate . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : foo_element = element . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_ios_class_chain def find_element_by_ios_class_chain ( self , class_chain_string ) Find an element by ios class chain string. Args: class_chain_string (str): The class chain string Usage: driver.find_element_by_ios_class_chain('XCUIElementTypeWindow/XCUIElementTypeButton[3]') Returns: appium.webdriver.webelement.WebElement View Source def find_element_by_ios_class_chain ( self , class_chain_string ) : \"\"\" Find an element by ios class chain string. Args : class_chain_string ( str ) : The class chain string Usage : driver . find_element_by_ios_class_chain ( ' XCUIElementTypeWindow/XCUIElementTypeButton[3] ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string ) find_element_by_ios_predicate def find_element_by_ios_predicate ( self , predicate_string ) Find an element by ios predicate string. Args: predicate_string (str): The predicate string Usage: driver.find_element_by_ios_predicate('label == \"myLabel\"') Returns: appium.webdriver.webelement.WebElement View Source def find_element_by_ios_predicate ( self , predicate_string ) : \"\"\" Find an element by ios predicate string. Args : predicate_string ( str ) : The predicate string Usage : driver . find_element_by_ios_predicate ( ' label == \"myLabel\" ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_PREDICATE , value = predicate_string ) find_element_by_ios_uiautomation def find_element_by_ios_uiautomation ( self , uia_string ) Finds an element by uiautomation in iOS. Args: uia_string (str): The element name in the iOS UIAutomation library Usage: driver.find_element_by_ios_uiautomation('.elements()[1].cells()[2]') Returns: appium.webdriver.webelement.WebElement View Source def find_element_by_ios_uiautomation ( self , uia_string ) : \"\"\" Finds an element by uiautomation in iOS. Args : uia_string ( str ) : The element name in the iOS UIAutomation library Usage : driver . find_element_by_ios_uiautomation ( ' .elements()[1].cells()[2] ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds element within this element's children by visible link text. :Args: - link_text - Link text string to search for. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds element within this element's children by visible link text. :Args : - link_text - Link text string to search for . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds element within this element's children by name. :Args: - name - name property of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds element within this element's children by name. :Args : - name - name property of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds element within this element's children by partially visible link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds element within this element's children by partially visible link text. :Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds element within this element's children by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds element within this element's children by tag name. :Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds element by xpath. :Args: - xpath - xpath of element to locate. \"//input[@class='myelement']\" Note: The base path will be relative to this element's location. This will select the first link under this element. :: myelement . find_element_by_xpath ( \".//a\" ) However, this will select the first link on the page. :: myelement . find_element_by_xpath ( \"//a\" ) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds element by xpath. :Args : - xpath - xpath of element to locate . \" //input[@class='myelement'] \" Note : The base path will be relative to this element ' s location. This will select the first link under this element . :: myelement . find_element_by_xpath ( \" .//a \" ) However , this will select the first link on the page . :: myelement . find_element_by_xpath ( \" //a \" ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator Prefer the find_elements_by_* methods when possible. Args: by (:obj: str , optional): The strategy value (:obj: str , optional): The locator Usage: element = element.find_elements(By.CLASS_NAME, 'foo') Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator Prefer the find_elements_by_ * methods when possible . Args : by ( : obj :` str `, optional ) : The strategy value ( : obj :` str `, optional ) : The locator Usage : element = element . find_elements ( By . CLASS_NAME , ' foo ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" # TODO : If we need , we should enable below converter for Web context # if self . _w3c : # if by == By . ID : # by = By . CSS_SELECTOR # value = ' [id=\"%s\"] ' % value # elif by == By . TAG_NAME : # by = By . CSS_SELECTOR # elif by == By . CLASS_NAME : # by = By . CSS_SELECTOR # value = \" .%s \" % value # elif by == By . NAME : # by = By . CSS_SELECTOR # value = ' [name=\"%s\"] ' % value return self . _execute ( RemoteCommand . FIND_CHILD_ELEMENTS , { \" using \" : by , \" value \" : value } ) [ ' value ' ] find_elements_by_accessibility_id def find_elements_by_accessibility_id ( self , accessibility_id ) Finds elements by accessibility id. Args: accessibility_id (str): a string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize Usage: driver.find_elements_by_accessibility_id() Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement View Source def find_elements_by_accessibility_id ( self , accessibility_id ) : \"\"\" Finds elements by accessibility id. Args : accessibility_id ( str ) : a string corresponding to a recursive element search using the Id / Name that the native Accessibility options utilize Usage : driver . find_elements_by_accessibility_id () Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_elements ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id ) find_elements_by_android_data_matcher def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) Finds elements by onData in Android It works with Espresso Driver . Args: name (:obj: str , optional): The name of a method to invoke. The method must return a Hamcrest Matcher args (:obj: str , optional): The args provided to the method className (:obj: str , optional): The class name that the method is part of (defaults to org.hamcrest.Matchers ). Can be fully qualified, or simple, and simple defaults to androidx.test.espresso.matcher package (e.g.: class=CursorMatchers fully qualified is class=androidx.test.espresso.matcher.CursorMatchers Returns: appium.webdriver.webelement.WebElement : The found elements Usage: driver.find_elements_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) View Source def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds elements by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found elements Usage : driver . find_elements_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_elements ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) ) find_elements_by_android_uiautomator def find_elements_by_android_uiautomator ( self , uia_string ) Finds elements by uiautomator in Android. Args: uia_string (str): The element name in the Android UIAutomator library Usage: driver.find_elements_by_android_uiautomator('.elements()[1].cells()[2]') Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement View Source def find_elements_by_android_uiautomator ( self , uia_string ) : \"\"\" Finds elements by uiautomator in Android. Args : uia_string ( str ) : The element name in the Android UIAutomator library Usage : driver . find_elements_by_android_uiautomator ( ' .elements()[1].cells()[2] ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_elements ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string ) find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds a list of elements within this element's children by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = element.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds a list of elements within this element's children by class name. :Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = element . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds a list of elements within this element's children by CSS selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = element.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds a list of elements within this element's children by CSS selector. :Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = element . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds a list of elements within this element's children by ID. Will return a list of webelements if found, or an empty list if not. :Args: - id_ - Id of child element to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = element.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds a list of elements within this element's children by ID. Will return a list of webelements if found , or an empty list if not . : Args : - id \\ _ - Id of child element to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = element . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_ios_class_chain def find_elements_by_ios_class_chain ( self , class_chain_string ) Finds elements by ios class chain string. Args: class_chain_string (str): The class chain string Usage: driver.find_elements_by_ios_class_chain('XCUIElementTypeWindow[2]/XCUIElementTypeAny[-2]') Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement View Source def find_elements_by_ios_class_chain ( self , class_chain_string ) : \"\"\" Finds elements by ios class chain string. Args : class_chain_string ( str ) : The class chain string Usage : driver . find_elements_by_ios_class_chain ( ' XCUIElementTypeWindow[2]/XCUIElementTypeAny[-2] ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string ) find_elements_by_ios_predicate def find_elements_by_ios_predicate ( self , predicate_string ) Finds elements by ios predicate string. Args: predicate_string (str): The predicate string Usage: driver.find_elements_by_ios_predicate('label == \"myLabel\"') Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement View Source def find_elements_by_ios_predicate ( self , predicate_string ) : \"\"\" Finds elements by ios predicate string. Args : predicate_string ( str ) : The predicate string Usage : driver . find_elements_by_ios_predicate ( ' label == \"myLabel\" ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_PREDICATE , value = predicate_string ) find_elements_by_ios_uiautomation def find_elements_by_ios_uiautomation ( self , uia_string ) Finds elements by uiautomation in iOS. Args: uia_string (str): The element name in the iOS UIAutomation library Usage: driver.find_elements_by_ios_uiautomation('.elements()[1].cells()[2]') Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement View Source def find_elements_by_ios_uiautomation ( self , uia_string ) : \"\"\" Finds elements by uiautomation in iOS. Args : uia_string ( str ) : The element name in the iOS UIAutomation library Usage : driver . find_elements_by_ios_uiautomation ( ' .elements()[1].cells()[2] ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string ) find_elements_by_link_text def find_elements_by_link_text ( self , link_text ) Finds a list of elements within this element's children by visible link text. :Args: - link_text - Link text string to search for. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = element.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , link_text ) : \"\"\" Finds a list of elements within this element's children by visible link text. :Args : - link_text - Link text string to search for . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = element . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = link_text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds a list of elements within this element's children by name. :Args: - name - name property to search for. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = element.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds a list of elements within this element's children by name. :Args : - name - name property to search for . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = element . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds a list of elements within this element's children by link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = element.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds a list of elements within this element's children by link text. :Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = element . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds a list of elements within this element's children by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = element.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds a list of elements within this element's children by tag name. :Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = element . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds elements within the element by xpath. :Args: - xpath - xpath locator string. Note: The base path will be relative to this element's location. This will select all links under this element. :: myelement . find_elements_by_xpath ( \".//a\" ) However, this will select all links in the page itself. :: myelement . find_elements_by_xpath ( \"//a\" ) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = element.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds elements within the element by xpath. :Args : - xpath - xpath locator string . Note : The base path will be relative to this element ' s location. This will select all links under this element . :: myelement . find_elements_by_xpath ( \" .//a \" ) However , this will select all links in the page itself . :: myelement . find_elements_by_xpath ( \" //a \" ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = element . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) get_attribute def get_attribute ( self , name ) Gets the given attribute or property of the element. This method will first try to return the value of a property with the given name. If a property with that name doesn't exist, it returns the value of the attribute with the same name. If there's no attribute with that name, None is returned. Values which are considered truthy, that is equals \"true\" or \"false\", are returned as booleans. All other non- None values are returned as strings. For attributes or properties which do not exist, None is returned. Args: name (str): Name of the attribute/property to retrieve. Usage: # Check if the \"active\" CSS class is applied to an element. is_active = \"active\" in target_element.get_attribute(\"class\") Returns: str: The given attribute or property of the element View Source def get_attribute ( self , name ) : \"\"\" Gets the given attribute or property of the element. This method will first try to return the value of a property with the given name . If a property with that name doesn ' t exist, it returns the value of the attribute with the same name . If there ' s no attribute with that name , `` None `` is returned . Values which are considered truthy , that is equals \" true \" or \" false \" , are returned as booleans . All other non - `` None `` values are returned as strings . For attributes or properties which do not exist , `` None `` is returned . Args : name ( str ) : Name of the attribute / property to retrieve . Usage : # Check if the \" active \" CSS class is applied to an element . is_active = \" active \" in target_element . get_attribute ( \" class \" ) Returns : str : The given attribute or property of the element \"\"\" resp = self . _execute ( RemoteCommand . GET_ELEMENT_ATTRIBUTE , { ' name ' : name } ) attributeValue = resp . get ( ' value ' ) if attributeValue is None : return None if not isinstance ( attributeValue , str ) : attributeValue = unicode ( attributeValue ) if name != ' value ' and attributeValue . lower () in ( ' true ' , ' false ' ) : return attributeValue . lower () return attributeValue get_property def get_property ( self , name ) Gets the given property of the element. :Args: - name - Name of the property to retrieve. Example:: text_length = target_element . get_property ( \"text_length\" ) View Source def get_property ( self , name ) : \"\"\" Gets the given property of the element . : Args : - name - Name of the property to retrieve . Example :: text_length = target_element . get_property ( \" text_length \" ) \"\"\" try : return self . _execute ( Command . GET_ELEMENT_PROPERTY , { \" name \" : name } ) [ \" value \" ] except WebDriverException : # if we hit an end point that doesnt understand getElementProperty lets fake it return self . parent . execute_script ( ' return arguments[0][arguments[1]] ' , self , name ) is_displayed def is_displayed ( self ) Whether the element is visible to a user. View Source def is_displayed ( self ) : \"\"\" Whether the element is visible to a user. \"\"\" return self . _execute ( RemoteCommand . IS_ELEMENT_DISPLAYED ) [ ' value ' ] is_enabled def is_enabled ( self ) Returns whether the element is enabled. View Source def is_enabled ( self ) : \"\"\" Returns whether the element is enabled. \"\"\" return self . _execute ( Command . IS_ELEMENT_ENABLED ) [ ' value ' ] is_selected def is_selected ( self ) Returns whether the element is selected. Can be used to check if a checkbox or radio button is selected. View Source def is_selected ( self ) : \"\"\" Returns whether the element is selected. Can be used to check if a checkbox or radio button is selected . \"\"\" return self . _execute ( Command . IS_ELEMENT_SELECTED ) [ ' value ' ] screenshot def screenshot ( self , filename ) Saves a screenshot of the current element to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: element.screenshot('/Screenshots/foo.png') View Source def screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current element to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : element . screenshot ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . screenshot_as_png try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True send_keys def send_keys ( self , * value ) Simulates typing into the element. :Args: - value - A string for typing, or setting form fields. For setting file inputs, this could be a local file path. Use this to send simple key events or to fill out form fields:: form_textfield = driver . find_element_by_name ( 'username' ) form_textfield . send_keys ( \"admin\" ) This can also be used to set file inputs. :: file_input = driver . find_element_by_name ( ' profilePic ' ) file_input . send_keys ( \" path/to/profilepic.gif \" ) # Generally it ' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \" path/to/profilepic.gif \" )) View Source def send_keys ( self , * value ) : \"\"\" Simulates typing into the element. :Args : - value - A string for typing , or setting form fields . For setting file inputs , this could be a local file path . Use this to send simple key events or to fill out form fields :: form_textfield = driver . find_element_by_name ( ' username ' ) form_textfield . send_keys ( \" admin \" ) This can also be used to set file inputs . :: file_input = driver . find_element_by_name ( ' profilePic ' ) file_input . send_keys ( \" path/to/profilepic.gif \" ) # Generally it ' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \" path/to/profilepic.gif \" )) \"\"\" # transfer file to another machine only if remote driver is used # the same behaviour as for java binding if self . parent . _is_remote : local_file = self . parent . file_detector . is_local_file ( * value ) if local_file is not None : value = self . _upload ( local_file ) self . _execute ( Command . SEND_KEYS_TO_ELEMENT , { ' text ' : \"\" . join ( keys_to_typing ( value )) , ' value ' : keys_to_typing ( value ) } ) set_text def set_text ( self , keys = '' ) Sends text to the element. Previous text is removed. Android only. Args: keys (str): the text to be sent to the element. Usage: element.set_text('some text') Returns: appium.webdriver.webelement.WebElement View Source def set_text ( self , keys = '' ) : \"\"\" Sends text to the element. Previous text is removed . Android only . Args : keys ( str ) : the text to be sent to the element . Usage : element . set_text ( ' some text ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" data = { ' id ' : self . _id , ' value ' : [ keys ] } self . _execute ( Command . REPLACE_KEYS , data ) return self set_value def set_value ( self , value ) Set the value on this element in the application Args: value (str): The value to be set Returns: appium.webdriver.webelement.WebElement View Source def set_value ( self , value ) : \"\"\" Set the value on this element in the application Args : value ( str ) : The value to be set Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" data = { ' id ' : self . id , ' value ' : [ value ], } self . _execute ( Command . SET_IMMEDIATE_VALUE , data ) return self submit def submit ( self ) Submits a form. View Source def submit ( self ) : \"\"\" Submits a form. \"\"\" if self . _w3c : form = self . find_element ( By . XPATH , \" ./ancestor-or-self::form \" ) self . _parent . execute_script ( \" var e = arguments[0].ownerDocument.createEvent('Event'); \" \" e.initEvent('submit', true, true); \" \" if (arguments[0].dispatchEvent(e)) { arguments[0].submit() } \" , form ) else : self . _execute ( Command . SUBMIT_ELEMENT ) value_of_css_property def value_of_css_property ( self , property_name ) The value of a CSS property. View Source def value_of_css_property ( self , property_name ) : \"\"\" The value of a CSS property. \"\"\" return self . _execute ( Command . GET_ELEMENT_VALUE_OF_CSS_PROPERTY , { ' propertyName ' : property_name } ) [ ' value ' ]","title":"Webelement"},{"location":"reference/appium/webdriver/webelement/#module-appiumwebdriverwebelement","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import json from selenium.webdriver.common.by import By from selenium.webdriver.remote.command import Command as RemoteCommand from appium.webdriver.common.mobileby import MobileBy from .extensions.search_context import AppiumWebElementSearchContext from .mobilecommand import MobileCommand as Command # Python 3 imports try : str = basestring except NameError : pass class WebElement ( AppiumWebElementSearchContext ): # Override def get_attribute ( self , name ): \"\"\"Gets the given attribute or property of the element. This method will first try to return the value of a property with the given name. If a property with that name doesn't exist, it returns the value of the attribute with the same name. If there's no attribute with that name, ``None`` is returned. Values which are considered truthy, that is equals \"true\" or \"false\", are returned as booleans. All other non-``None`` values are returned as strings. For attributes or properties which do not exist, ``None`` is returned. Args: name (str): Name of the attribute/property to retrieve. Usage: # Check if the \"active\" CSS class is applied to an element. is_active = \"active\" in target_element.get_attribute(\"class\") Returns: str: The given attribute or property of the element \"\"\" resp = self . _execute ( RemoteCommand . GET_ELEMENT_ATTRIBUTE , { 'name' : name }) attributeValue = resp . get ( 'value' ) if attributeValue is None : return None if not isinstance ( attributeValue , str ): attributeValue = unicode ( attributeValue ) if name != 'value' and attributeValue . lower () in ( 'true' , 'false' ): return attributeValue . lower () return attributeValue # Override def is_displayed ( self ): \"\"\"Whether the element is visible to a user.\"\"\" return self . _execute ( RemoteCommand . IS_ELEMENT_DISPLAYED )[ 'value' ] def find_element_by_ios_uiautomation ( self , uia_string ): \"\"\"Finds an element by uiautomation in iOS. Args: uia_string (str): The element name in the iOS UIAutomation library Usage: driver.find_element_by_ios_uiautomation('.elements()[1].cells()[2]') Returns: `appium.webdriver.webelement.WebElement` \"\"\" return self . find_element ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string ) def find_elements_by_ios_uiautomation ( self , uia_string ): \"\"\"Finds elements by uiautomation in iOS. Args: uia_string (str): The element name in the iOS UIAutomation library Usage: driver.find_elements_by_ios_uiautomation('.elements()[1].cells()[2]') Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` \"\"\" return self . find_elements ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string ) def find_element_by_ios_predicate ( self , predicate_string ): \"\"\"Find an element by ios predicate string. Args: predicate_string (str): The predicate string Usage: driver.find_element_by_ios_predicate('label == \"myLabel\"') Returns: `appium.webdriver.webelement.WebElement` \"\"\" return self . find_element ( by = MobileBy . IOS_PREDICATE , value = predicate_string ) def find_elements_by_ios_predicate ( self , predicate_string ): \"\"\"Finds elements by ios predicate string. Args: predicate_string (str): The predicate string Usage: driver.find_elements_by_ios_predicate('label == \"myLabel\"') Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` \"\"\" return self . find_elements ( by = MobileBy . IOS_PREDICATE , value = predicate_string ) def find_element_by_ios_class_chain ( self , class_chain_string ): \"\"\"Find an element by ios class chain string. Args: class_chain_string (str): The class chain string Usage: driver.find_element_by_ios_class_chain('XCUIElementTypeWindow/XCUIElementTypeButton[3]') Returns: `appium.webdriver.webelement.WebElement` \"\"\" return self . find_element ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string ) def find_elements_by_ios_class_chain ( self , class_chain_string ): \"\"\"Finds elements by ios class chain string. Args: class_chain_string (str): The class chain string Usage: driver.find_elements_by_ios_class_chain('XCUIElementTypeWindow[2]/XCUIElementTypeAny[-2]') Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` \"\"\" return self . find_elements ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string ) def find_element_by_android_uiautomator ( self , uia_string ): \"\"\"Finds element by uiautomator in Android. Args: uia_string (str): The element name in the Android UIAutomator library Usage: driver.find_element_by_android_uiautomator('.elements()[1].cells()[2]') Returns: `appium.webdriver.webelement.WebElement` \"\"\" return self . find_element ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string ) def find_elements_by_android_uiautomator ( self , uia_string ): \"\"\"Finds elements by uiautomator in Android. Args: uia_string (str): The element name in the Android UIAutomator library Usage: driver.find_elements_by_android_uiautomator('.elements()[1].cells()[2]') Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` \"\"\" return self . find_elements ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string ) def find_element_by_accessibility_id ( self , accessibility_id ): \"\"\"Finds an element by accessibility id. Args: accessibility_id (str): a string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize Usage: driver.find_element_by_accessibility_id() Returns: `appium.webdriver.webelement.WebElement` \"\"\" return self . find_element ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id ) def find_elements_by_accessibility_id ( self , accessibility_id ): \"\"\"Finds elements by accessibility id. Args: accessibility_id (str): a string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize Usage: driver.find_elements_by_accessibility_id() Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` \"\"\" return self . find_elements ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id ) def find_element ( self , by = By . ID , value = None ): \"\"\"Find an element given a By strategy and locator Prefer the find_element_by_* methods when possible. Args: by (:obj:`str`, optional): The strategy value (:obj:`str`, optional): The locator Usage: element = element.find_element(By.ID, 'foo') Returns: `appium.webdriver.webelement.WebElement` \"\"\" # TODO: If we need, we should enable below converter for Web context # if self._w3c: # if by == By.ID: # by = By.CSS_SELECTOR # value = '[id=\"%s\"]' % value # elif by == By.TAG_NAME: # by = By.CSS_SELECTOR # elif by == By.CLASS_NAME: # by = By.CSS_SELECTOR # value = \".%s\" % value # elif by == By.NAME: # by = By.CSS_SELECTOR # value = '[name=\"%s\"]' % value return self . _execute ( RemoteCommand . FIND_CHILD_ELEMENT , { \"using\" : by , \"value\" : value })[ 'value' ] def find_elements ( self , by = By . ID , value = None ): \"\"\"Find elements given a By strategy and locator Prefer the find_elements_by_* methods when possible. Args: by (:obj:`str`, optional): The strategy value (:obj:`str`, optional): The locator Usage: element = element.find_elements(By.CLASS_NAME, 'foo') Returns: :obj:`list` of :obj:`appium.webdriver.webelement.WebElement` \"\"\" # TODO: If we need, we should enable below converter for Web context # if self._w3c: # if by == By.ID: # by = By.CSS_SELECTOR # value = '[id=\"%s\"]' % value # elif by == By.TAG_NAME: # by = By.CSS_SELECTOR # elif by == By.CLASS_NAME: # by = By.CSS_SELECTOR # value = \".%s\" % value # elif by == By.NAME: # by = By.CSS_SELECTOR # value = '[name=\"%s\"]' % value return self . _execute ( RemoteCommand . FIND_CHILD_ELEMENTS , { \"using\" : by , \"value\" : value })[ 'value' ] def set_text ( self , keys = '' ): \"\"\"Sends text to the element. Previous text is removed. Android only. Args: keys (str): the text to be sent to the element. Usage: element.set_text('some text') Returns: `appium.webdriver.webelement.WebElement` \"\"\" data = { 'id' : self . _id , 'value' : [ keys ] } self . _execute ( Command . REPLACE_KEYS , data ) return self @property def location_in_view ( self ): \"\"\"Gets the location of an element relative to the view. Usage: location = element.location_in_view x = location['x'] y = location['y'] Returns: dict: The location of an element relative to the view \"\"\" return self . _execute ( Command . LOCATION_IN_VIEW )[ 'value' ] def set_value ( self , value ): \"\"\"Set the value on this element in the application Args: value (str): The value to be set Returns: `appium.webdriver.webelement.WebElement` \"\"\" data = { 'id' : self . id , 'value' : [ value ], } self . _execute ( Command . SET_IMMEDIATE_VALUE , data ) return self def clear ( self ): \"\"\"Clears text. Returns: `appium.webdriver.webelement.WebElement` \"\"\" data = { 'id' : self . id } self . _execute ( Command . CLEAR , data ) return self","title":"Module appium.webdriver.webelement"},{"location":"reference/appium/webdriver/webelement/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/webelement/#webelement","text":"class WebElement ( parent , id_ , w3c = False ) Returns appium web element search context View Source class WebElement ( AppiumWebElementSearchContext ) : # Override def get_attribute ( self , name ) : \"\"\" Gets the given attribute or property of the element. This method will first try to return the value of a property with the given name . If a property with that name doesn ' t exist, it returns the value of the attribute with the same name . If there ' s no attribute with that name , `` None `` is returned . Values which are considered truthy , that is equals \" true \" or \" false \" , are returned as booleans . All other non - `` None `` values are returned as strings . For attributes or properties which do not exist , `` None `` is returned . Args : name ( str ) : Name of the attribute / property to retrieve . Usage : # Check if the \" active \" CSS class is applied to an element . is_active = \" active \" in target_element . get_attribute ( \" class \" ) Returns : str : The given attribute or property of the element \"\"\" resp = self . _execute ( RemoteCommand . GET_ELEMENT_ATTRIBUTE , { ' name ' : name } ) attributeValue = resp . get ( ' value ' ) if attributeValue is None : return None if not isinstance ( attributeValue , str ) : attributeValue = unicode ( attributeValue ) if name != ' value ' and attributeValue . lower () in ( ' true ' , ' false ' ) : return attributeValue . lower () return attributeValue # Override def is_displayed ( self ) : \"\"\" Whether the element is visible to a user. \"\"\" return self . _execute ( RemoteCommand . IS_ELEMENT_DISPLAYED ) [ ' value ' ] def find_element_by_ios_uiautomation ( self , uia_string ) : \"\"\" Finds an element by uiautomation in iOS. Args : uia_string ( str ) : The element name in the iOS UIAutomation library Usage : driver . find_element_by_ios_uiautomation ( ' .elements()[1].cells()[2] ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string ) def find_elements_by_ios_uiautomation ( self , uia_string ) : \"\"\" Finds elements by uiautomation in iOS. Args : uia_string ( str ) : The element name in the iOS UIAutomation library Usage : driver . find_elements_by_ios_uiautomation ( ' .elements()[1].cells()[2] ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string ) def find_element_by_ios_predicate ( self , predicate_string ) : \"\"\" Find an element by ios predicate string. Args : predicate_string ( str ) : The predicate string Usage : driver . find_element_by_ios_predicate ( ' label == \"myLabel\" ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_PREDICATE , value = predicate_string ) def find_elements_by_ios_predicate ( self , predicate_string ) : \"\"\" Finds elements by ios predicate string. Args : predicate_string ( str ) : The predicate string Usage : driver . find_elements_by_ios_predicate ( ' label == \"myLabel\" ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_PREDICATE , value = predicate_string ) def find_element_by_ios_class_chain ( self , class_chain_string ) : \"\"\" Find an element by ios class chain string. Args : class_chain_string ( str ) : The class chain string Usage : driver . find_element_by_ios_class_chain ( ' XCUIElementTypeWindow/XCUIElementTypeButton[3] ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string ) def find_elements_by_ios_class_chain ( self , class_chain_string ) : \"\"\" Finds elements by ios class chain string. Args : class_chain_string ( str ) : The class chain string Usage : driver . find_elements_by_ios_class_chain ( ' XCUIElementTypeWindow[2]/XCUIElementTypeAny[-2] ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string ) def find_element_by_android_uiautomator ( self , uia_string ) : \"\"\" Finds element by uiautomator in Android. Args : uia_string ( str ) : The element name in the Android UIAutomator library Usage : driver . find_element_by_android_uiautomator ( ' .elements()[1].cells()[2] ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_element ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string ) def find_elements_by_android_uiautomator ( self , uia_string ) : \"\"\" Finds elements by uiautomator in Android. Args : uia_string ( str ) : The element name in the Android UIAutomator library Usage : driver . find_elements_by_android_uiautomator ( ' .elements()[1].cells()[2] ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_elements ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string ) def find_element_by_accessibility_id ( self , accessibility_id ) : \"\"\" Finds an element by accessibility id. Args : accessibility_id ( str ) : a string corresponding to a recursive element search using the Id / Name that the native Accessibility options utilize Usage : driver . find_element_by_accessibility_id () Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_element ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id ) def find_elements_by_accessibility_id ( self , accessibility_id ) : \"\"\" Finds elements by accessibility id. Args : accessibility_id ( str ) : a string corresponding to a recursive element search using the Id / Name that the native Accessibility options utilize Usage : driver . find_elements_by_accessibility_id () Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_elements ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id ) def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator Prefer the find_element_by_ * methods when possible . Args : by ( : obj :` str `, optional ) : The strategy value ( : obj :` str `, optional ) : The locator Usage : element = element . find_element ( By . ID , ' foo ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" # TODO : If we need , we should enable below converter for Web context # if self . _w3c : # if by == By . ID : # by = By . CSS_SELECTOR # value = ' [id=\"%s\"] ' % value # elif by == By . TAG_NAME : # by = By . CSS_SELECTOR # elif by == By . CLASS_NAME : # by = By . CSS_SELECTOR # value = \" .%s \" % value # elif by == By . NAME : # by = By . CSS_SELECTOR # value = ' [name=\"%s\"] ' % value return self . _execute ( RemoteCommand . FIND_CHILD_ELEMENT , { \" using \" : by , \" value \" : value } ) [ ' value ' ] def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator Prefer the find_elements_by_ * methods when possible . Args : by ( : obj :` str `, optional ) : The strategy value ( : obj :` str `, optional ) : The locator Usage : element = element . find_elements ( By . CLASS_NAME , ' foo ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" # TODO : If we need , we should enable below converter for Web context # if self . _w3c : # if by == By . ID : # by = By . CSS_SELECTOR # value = ' [id=\"%s\"] ' % value # elif by == By . TAG_NAME : # by = By . CSS_SELECTOR # elif by == By . CLASS_NAME : # by = By . CSS_SELECTOR # value = \" .%s \" % value # elif by == By . NAME : # by = By . CSS_SELECTOR # value = ' [name=\"%s\"] ' % value return self . _execute ( RemoteCommand . FIND_CHILD_ELEMENTS , { \" using \" : by , \" value \" : value } ) [ ' value ' ] def set_text ( self , keys = '' ) : \"\"\" Sends text to the element. Previous text is removed . Android only . Args : keys ( str ) : the text to be sent to the element . Usage : element . set_text ( ' some text ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" data = { ' id ' : self . _id , ' value ' : [ keys ] } self . _execute ( Command . REPLACE_KEYS , data ) return self @ property def location_in_view ( self ) : \"\"\" Gets the location of an element relative to the view. Usage : location = element . location_in_view x = location [ ' x ' ] y = location [ ' y ' ] Returns : dict : The location of an element relative to the view \"\"\" return self . _execute ( Command . LOCATION_IN_VIEW ) [ ' value ' ] def set_value ( self , value ) : \"\"\" Set the value on this element in the application Args : value ( str ) : The value to be set Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" data = { ' id ' : self . id , ' value ' : [ value ], } self . _execute ( Command . SET_IMMEDIATE_VALUE , data ) return self def clear ( self ) : \"\"\" Clears text. Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" data = { ' id ' : self . id } self . _execute ( Command . CLEAR , data ) return self","title":"WebElement"},{"location":"reference/appium/webdriver/webelement/#ancestors-in-mro","text":"appium.webdriver.extensions.search_context.AppiumWebElementSearchContext selenium.webdriver.remote.webelement.WebElement appium.webdriver.extensions.search_context.AndroidSearchContext appium.webdriver.extensions.search_context.BaseSearchContext","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/webelement/#instance-variables","text":"id Internal ID used by selenium. This is mainly for internal use. Simple use cases such as checking if 2 webelements refer to the same element, can be done using == :: if element1 == element2 : print ( \" These 2 are equal \" ) location The location of the element in the renderable canvas. location_in_view Gets the location of an element relative to the view. Usage: location = element.location_in_view x = location['x'] y = location['y'] Returns: dict: The location of an element relative to the view location_once_scrolled_into_view THIS PROPERTY MAY CHANGE WITHOUT WARNING. Use this to discover where on the screen an element is so that we can click it. This method should cause the element to be scrolled into view. Returns the top lefthand corner location on the screen, or None if the element is not visible. parent Internal reference to the WebDriver instance this element was found from. rect A dictionary with the size and location of the element. screenshot_as_base64 Gets the screenshot of the current element as a base64 encoded string. :Usage: img_b64 = element.screenshot_as_base64 screenshot_as_png Gets the screenshot of the current element as a binary data. :Usage: element_png = element.screenshot_as_png size The size of the element. tag_name This element's tagName property. text The text of the element.","title":"Instance variables"},{"location":"reference/appium/webdriver/webelement/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/webelement/#clear","text":"def clear ( self ) Clears text. Returns: appium.webdriver.webelement.WebElement View Source def clear ( self ) : \"\"\" Clears text. Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" data = { ' id ' : self . id } self . _execute ( Command . CLEAR , data ) return self","title":"clear"},{"location":"reference/appium/webdriver/webelement/#click","text":"def click ( self ) Clicks the element. View Source def click ( self ): \"\"\"Clicks the element.\"\"\" self . _execute ( Command . CLICK_ELEMENT )","title":"click"},{"location":"reference/appium/webdriver/webelement/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator Prefer the find_element_by_* methods when possible. Args: by (:obj: str , optional): The strategy value (:obj: str , optional): The locator Usage: element = element.find_element(By.ID, 'foo') Returns: appium.webdriver.webelement.WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator Prefer the find_element_by_ * methods when possible . Args : by ( : obj :` str `, optional ) : The strategy value ( : obj :` str `, optional ) : The locator Usage : element = element . find_element ( By . ID , ' foo ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" # TODO : If we need , we should enable below converter for Web context # if self . _w3c : # if by == By . ID : # by = By . CSS_SELECTOR # value = ' [id=\"%s\"] ' % value # elif by == By . TAG_NAME : # by = By . CSS_SELECTOR # elif by == By . CLASS_NAME : # by = By . CSS_SELECTOR # value = \" .%s \" % value # elif by == By . NAME : # by = By . CSS_SELECTOR # value = ' [name=\"%s\"] ' % value return self . _execute ( RemoteCommand . FIND_CHILD_ELEMENT , { \" using \" : by , \" value \" : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/webelement/#find_element_by_accessibility_id","text":"def find_element_by_accessibility_id ( self , accessibility_id ) Finds an element by accessibility id. Args: accessibility_id (str): a string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize Usage: driver.find_element_by_accessibility_id() Returns: appium.webdriver.webelement.WebElement View Source def find_element_by_accessibility_id ( self , accessibility_id ) : \"\"\" Finds an element by accessibility id. Args : accessibility_id ( str ) : a string corresponding to a recursive element search using the Id / Name that the native Accessibility options utilize Usage : driver . find_element_by_accessibility_id () Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_element ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id )","title":"find_element_by_accessibility_id"},{"location":"reference/appium/webdriver/webelement/#find_element_by_android_data_matcher","text":"def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) Finds element by onData in Android It works with Espresso Driver . Args: name (:obj: str , optional): The name of a method to invoke. The method must return a Hamcrest Matcher args (:obj: str , optional): The args provided to the method className (:obj: str , optional): The class name that the method is part of (defaults to org.hamcrest.Matchers ). Can be fully qualified, or simple, and simple defaults to androidx.test.espresso.matcher package (e.g.: class=CursorMatchers fully qualified is class=androidx.test.espresso.matcher.CursorMatchers Returns: appium.webdriver.webelement.WebElement : The found element Raises: TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage: driver.find_element_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) View Source def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds element by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found element Raises : TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage : driver . find_element_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_element ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) )","title":"find_element_by_android_data_matcher"},{"location":"reference/appium/webdriver/webelement/#find_element_by_android_uiautomator","text":"def find_element_by_android_uiautomator ( self , uia_string ) Finds element by uiautomator in Android. Args: uia_string (str): The element name in the Android UIAutomator library Usage: driver.find_element_by_android_uiautomator('.elements()[1].cells()[2]') Returns: appium.webdriver.webelement.WebElement View Source def find_element_by_android_uiautomator ( self , uia_string ) : \"\"\" Finds element by uiautomator in Android. Args : uia_string ( str ) : The element name in the Android UIAutomator library Usage : driver . find_element_by_android_uiautomator ( ' .elements()[1].cells()[2] ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_element ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string )","title":"find_element_by_android_uiautomator"},{"location":"reference/appium/webdriver/webelement/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds element within this element's children by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds element within this element's children by class name. :Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/webelement/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds element within this element's children by CSS selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds element within this element's children by CSS selector. :Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/webelement/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds element within this element's children by ID. :Args: - id_ - ID of child element to locate. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: foo_element = element.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds element within this element's children by ID. :Args : - id \\ _ - ID of child element to locate . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : foo_element = element . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/webelement/#find_element_by_ios_class_chain","text":"def find_element_by_ios_class_chain ( self , class_chain_string ) Find an element by ios class chain string. Args: class_chain_string (str): The class chain string Usage: driver.find_element_by_ios_class_chain('XCUIElementTypeWindow/XCUIElementTypeButton[3]') Returns: appium.webdriver.webelement.WebElement View Source def find_element_by_ios_class_chain ( self , class_chain_string ) : \"\"\" Find an element by ios class chain string. Args : class_chain_string ( str ) : The class chain string Usage : driver . find_element_by_ios_class_chain ( ' XCUIElementTypeWindow/XCUIElementTypeButton[3] ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string )","title":"find_element_by_ios_class_chain"},{"location":"reference/appium/webdriver/webelement/#find_element_by_ios_predicate","text":"def find_element_by_ios_predicate ( self , predicate_string ) Find an element by ios predicate string. Args: predicate_string (str): The predicate string Usage: driver.find_element_by_ios_predicate('label == \"myLabel\"') Returns: appium.webdriver.webelement.WebElement View Source def find_element_by_ios_predicate ( self , predicate_string ) : \"\"\" Find an element by ios predicate string. Args : predicate_string ( str ) : The predicate string Usage : driver . find_element_by_ios_predicate ( ' label == \"myLabel\" ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_PREDICATE , value = predicate_string )","title":"find_element_by_ios_predicate"},{"location":"reference/appium/webdriver/webelement/#find_element_by_ios_uiautomation","text":"def find_element_by_ios_uiautomation ( self , uia_string ) Finds an element by uiautomation in iOS. Args: uia_string (str): The element name in the iOS UIAutomation library Usage: driver.find_element_by_ios_uiautomation('.elements()[1].cells()[2]') Returns: appium.webdriver.webelement.WebElement View Source def find_element_by_ios_uiautomation ( self , uia_string ) : \"\"\" Finds an element by uiautomation in iOS. Args : uia_string ( str ) : The element name in the iOS UIAutomation library Usage : driver . find_element_by_ios_uiautomation ( ' .elements()[1].cells()[2] ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_element ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string )","title":"find_element_by_ios_uiautomation"},{"location":"reference/appium/webdriver/webelement/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds element within this element's children by visible link text. :Args: - link_text - Link text string to search for. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds element within this element's children by visible link text. :Args : - link_text - Link text string to search for . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/webelement/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds element within this element's children by name. :Args: - name - name property of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds element within this element's children by name. :Args : - name - name property of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/webelement/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds element within this element's children by partially visible link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds element within this element's children by partially visible link text. :Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/webelement/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds element within this element's children by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds element within this element's children by tag name. :Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/webelement/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds element by xpath. :Args: - xpath - xpath of element to locate. \"//input[@class='myelement']\" Note: The base path will be relative to this element's location. This will select the first link under this element. :: myelement . find_element_by_xpath ( \".//a\" ) However, this will select the first link on the page. :: myelement . find_element_by_xpath ( \"//a\" ) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds element by xpath. :Args : - xpath - xpath of element to locate . \" //input[@class='myelement'] \" Note : The base path will be relative to this element ' s location. This will select the first link under this element . :: myelement . find_element_by_xpath ( \" .//a \" ) However , this will select the first link on the page . :: myelement . find_element_by_xpath ( \" //a \" ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/webelement/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator Prefer the find_elements_by_* methods when possible. Args: by (:obj: str , optional): The strategy value (:obj: str , optional): The locator Usage: element = element.find_elements(By.CLASS_NAME, 'foo') Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator Prefer the find_elements_by_ * methods when possible . Args : by ( : obj :` str `, optional ) : The strategy value ( : obj :` str `, optional ) : The locator Usage : element = element . find_elements ( By . CLASS_NAME , ' foo ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" # TODO : If we need , we should enable below converter for Web context # if self . _w3c : # if by == By . ID : # by = By . CSS_SELECTOR # value = ' [id=\"%s\"] ' % value # elif by == By . TAG_NAME : # by = By . CSS_SELECTOR # elif by == By . CLASS_NAME : # by = By . CSS_SELECTOR # value = \" .%s \" % value # elif by == By . NAME : # by = By . CSS_SELECTOR # value = ' [name=\"%s\"] ' % value return self . _execute ( RemoteCommand . FIND_CHILD_ELEMENTS , { \" using \" : by , \" value \" : value } ) [ ' value ' ]","title":"find_elements"},{"location":"reference/appium/webdriver/webelement/#find_elements_by_accessibility_id","text":"def find_elements_by_accessibility_id ( self , accessibility_id ) Finds elements by accessibility id. Args: accessibility_id (str): a string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize Usage: driver.find_elements_by_accessibility_id() Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement View Source def find_elements_by_accessibility_id ( self , accessibility_id ) : \"\"\" Finds elements by accessibility id. Args : accessibility_id ( str ) : a string corresponding to a recursive element search using the Id / Name that the native Accessibility options utilize Usage : driver . find_elements_by_accessibility_id () Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_elements ( by = MobileBy . ACCESSIBILITY_ID , value = accessibility_id )","title":"find_elements_by_accessibility_id"},{"location":"reference/appium/webdriver/webelement/#find_elements_by_android_data_matcher","text":"def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) Finds elements by onData in Android It works with Espresso Driver . Args: name (:obj: str , optional): The name of a method to invoke. The method must return a Hamcrest Matcher args (:obj: str , optional): The args provided to the method className (:obj: str , optional): The class name that the method is part of (defaults to org.hamcrest.Matchers ). Can be fully qualified, or simple, and simple defaults to androidx.test.espresso.matcher package (e.g.: class=CursorMatchers fully qualified is class=androidx.test.espresso.matcher.CursorMatchers Returns: appium.webdriver.webelement.WebElement : The found elements Usage: driver.find_elements_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) View Source def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds elements by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found elements Usage : driver . find_elements_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_elements ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) )","title":"find_elements_by_android_data_matcher"},{"location":"reference/appium/webdriver/webelement/#find_elements_by_android_uiautomator","text":"def find_elements_by_android_uiautomator ( self , uia_string ) Finds elements by uiautomator in Android. Args: uia_string (str): The element name in the Android UIAutomator library Usage: driver.find_elements_by_android_uiautomator('.elements()[1].cells()[2]') Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement View Source def find_elements_by_android_uiautomator ( self , uia_string ) : \"\"\" Finds elements by uiautomator in Android. Args : uia_string ( str ) : The element name in the Android UIAutomator library Usage : driver . find_elements_by_android_uiautomator ( ' .elements()[1].cells()[2] ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_elements ( by = MobileBy . ANDROID_UIAUTOMATOR , value = uia_string )","title":"find_elements_by_android_uiautomator"},{"location":"reference/appium/webdriver/webelement/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds a list of elements within this element's children by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = element.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds a list of elements within this element's children by class name. :Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = element . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/webelement/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds a list of elements within this element's children by CSS selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = element.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds a list of elements within this element's children by CSS selector. :Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = element . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/webelement/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds a list of elements within this element's children by ID. Will return a list of webelements if found, or an empty list if not. :Args: - id_ - Id of child element to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = element.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds a list of elements within this element's children by ID. Will return a list of webelements if found , or an empty list if not . : Args : - id \\ _ - Id of child element to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = element . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/webelement/#find_elements_by_ios_class_chain","text":"def find_elements_by_ios_class_chain ( self , class_chain_string ) Finds elements by ios class chain string. Args: class_chain_string (str): The class chain string Usage: driver.find_elements_by_ios_class_chain('XCUIElementTypeWindow[2]/XCUIElementTypeAny[-2]') Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement View Source def find_elements_by_ios_class_chain ( self , class_chain_string ) : \"\"\" Finds elements by ios class chain string. Args : class_chain_string ( str ) : The class chain string Usage : driver . find_elements_by_ios_class_chain ( ' XCUIElementTypeWindow[2]/XCUIElementTypeAny[-2] ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_CLASS_CHAIN , value = class_chain_string )","title":"find_elements_by_ios_class_chain"},{"location":"reference/appium/webdriver/webelement/#find_elements_by_ios_predicate","text":"def find_elements_by_ios_predicate ( self , predicate_string ) Finds elements by ios predicate string. Args: predicate_string (str): The predicate string Usage: driver.find_elements_by_ios_predicate('label == \"myLabel\"') Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement View Source def find_elements_by_ios_predicate ( self , predicate_string ) : \"\"\" Finds elements by ios predicate string. Args : predicate_string ( str ) : The predicate string Usage : driver . find_elements_by_ios_predicate ( ' label == \"myLabel\" ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_PREDICATE , value = predicate_string )","title":"find_elements_by_ios_predicate"},{"location":"reference/appium/webdriver/webelement/#find_elements_by_ios_uiautomation","text":"def find_elements_by_ios_uiautomation ( self , uia_string ) Finds elements by uiautomation in iOS. Args: uia_string (str): The element name in the iOS UIAutomation library Usage: driver.find_elements_by_ios_uiautomation('.elements()[1].cells()[2]') Returns: :obj: list of :obj: appium.webdriver.webelement.WebElement View Source def find_elements_by_ios_uiautomation ( self , uia_string ) : \"\"\" Finds elements by uiautomation in iOS. Args : uia_string ( str ) : The element name in the iOS UIAutomation library Usage : driver . find_elements_by_ios_uiautomation ( ' .elements()[1].cells()[2] ' ) Returns : : obj :` list ` of : obj :` appium . webdriver . webelement . WebElement ` \"\"\" return self . find_elements ( by = MobileBy . IOS_UIAUTOMATION , value = uia_string )","title":"find_elements_by_ios_uiautomation"},{"location":"reference/appium/webdriver/webelement/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , link_text ) Finds a list of elements within this element's children by visible link text. :Args: - link_text - Link text string to search for. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = element.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , link_text ) : \"\"\" Finds a list of elements within this element's children by visible link text. :Args : - link_text - Link text string to search for . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = element . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = link_text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/webelement/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds a list of elements within this element's children by name. :Args: - name - name property to search for. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = element.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds a list of elements within this element's children by name. :Args : - name - name property to search for . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = element . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/webelement/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds a list of elements within this element's children by link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = element.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds a list of elements within this element's children by link text. :Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = element . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/webelement/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds a list of elements within this element's children by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = element.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds a list of elements within this element's children by tag name. :Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = element . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/webelement/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds elements within the element by xpath. :Args: - xpath - xpath locator string. Note: The base path will be relative to this element's location. This will select all links under this element. :: myelement . find_elements_by_xpath ( \".//a\" ) However, this will select all links in the page itself. :: myelement . find_elements_by_xpath ( \"//a\" ) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = element.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds elements within the element by xpath. :Args : - xpath - xpath locator string . Note : The base path will be relative to this element ' s location. This will select all links under this element . :: myelement . find_elements_by_xpath ( \" .//a \" ) However , this will select all links in the page itself . :: myelement . find_elements_by_xpath ( \" //a \" ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = element . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/webelement/#get_attribute","text":"def get_attribute ( self , name ) Gets the given attribute or property of the element. This method will first try to return the value of a property with the given name. If a property with that name doesn't exist, it returns the value of the attribute with the same name. If there's no attribute with that name, None is returned. Values which are considered truthy, that is equals \"true\" or \"false\", are returned as booleans. All other non- None values are returned as strings. For attributes or properties which do not exist, None is returned. Args: name (str): Name of the attribute/property to retrieve. Usage: # Check if the \"active\" CSS class is applied to an element. is_active = \"active\" in target_element.get_attribute(\"class\") Returns: str: The given attribute or property of the element View Source def get_attribute ( self , name ) : \"\"\" Gets the given attribute or property of the element. This method will first try to return the value of a property with the given name . If a property with that name doesn ' t exist, it returns the value of the attribute with the same name . If there ' s no attribute with that name , `` None `` is returned . Values which are considered truthy , that is equals \" true \" or \" false \" , are returned as booleans . All other non - `` None `` values are returned as strings . For attributes or properties which do not exist , `` None `` is returned . Args : name ( str ) : Name of the attribute / property to retrieve . Usage : # Check if the \" active \" CSS class is applied to an element . is_active = \" active \" in target_element . get_attribute ( \" class \" ) Returns : str : The given attribute or property of the element \"\"\" resp = self . _execute ( RemoteCommand . GET_ELEMENT_ATTRIBUTE , { ' name ' : name } ) attributeValue = resp . get ( ' value ' ) if attributeValue is None : return None if not isinstance ( attributeValue , str ) : attributeValue = unicode ( attributeValue ) if name != ' value ' and attributeValue . lower () in ( ' true ' , ' false ' ) : return attributeValue . lower () return attributeValue","title":"get_attribute"},{"location":"reference/appium/webdriver/webelement/#get_property","text":"def get_property ( self , name ) Gets the given property of the element. :Args: - name - Name of the property to retrieve. Example:: text_length = target_element . get_property ( \"text_length\" ) View Source def get_property ( self , name ) : \"\"\" Gets the given property of the element . : Args : - name - Name of the property to retrieve . Example :: text_length = target_element . get_property ( \" text_length \" ) \"\"\" try : return self . _execute ( Command . GET_ELEMENT_PROPERTY , { \" name \" : name } ) [ \" value \" ] except WebDriverException : # if we hit an end point that doesnt understand getElementProperty lets fake it return self . parent . execute_script ( ' return arguments[0][arguments[1]] ' , self , name )","title":"get_property"},{"location":"reference/appium/webdriver/webelement/#is_displayed","text":"def is_displayed ( self ) Whether the element is visible to a user. View Source def is_displayed ( self ) : \"\"\" Whether the element is visible to a user. \"\"\" return self . _execute ( RemoteCommand . IS_ELEMENT_DISPLAYED ) [ ' value ' ]","title":"is_displayed"},{"location":"reference/appium/webdriver/webelement/#is_enabled","text":"def is_enabled ( self ) Returns whether the element is enabled. View Source def is_enabled ( self ) : \"\"\" Returns whether the element is enabled. \"\"\" return self . _execute ( Command . IS_ELEMENT_ENABLED ) [ ' value ' ]","title":"is_enabled"},{"location":"reference/appium/webdriver/webelement/#is_selected","text":"def is_selected ( self ) Returns whether the element is selected. Can be used to check if a checkbox or radio button is selected. View Source def is_selected ( self ) : \"\"\" Returns whether the element is selected. Can be used to check if a checkbox or radio button is selected . \"\"\" return self . _execute ( Command . IS_ELEMENT_SELECTED ) [ ' value ' ]","title":"is_selected"},{"location":"reference/appium/webdriver/webelement/#screenshot","text":"def screenshot ( self , filename ) Saves a screenshot of the current element to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: element.screenshot('/Screenshots/foo.png') View Source def screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current element to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : element . screenshot ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . screenshot_as_png try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"screenshot"},{"location":"reference/appium/webdriver/webelement/#send_keys","text":"def send_keys ( self , * value ) Simulates typing into the element. :Args: - value - A string for typing, or setting form fields. For setting file inputs, this could be a local file path. Use this to send simple key events or to fill out form fields:: form_textfield = driver . find_element_by_name ( 'username' ) form_textfield . send_keys ( \"admin\" ) This can also be used to set file inputs. :: file_input = driver . find_element_by_name ( ' profilePic ' ) file_input . send_keys ( \" path/to/profilepic.gif \" ) # Generally it ' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \" path/to/profilepic.gif \" )) View Source def send_keys ( self , * value ) : \"\"\" Simulates typing into the element. :Args : - value - A string for typing , or setting form fields . For setting file inputs , this could be a local file path . Use this to send simple key events or to fill out form fields :: form_textfield = driver . find_element_by_name ( ' username ' ) form_textfield . send_keys ( \" admin \" ) This can also be used to set file inputs . :: file_input = driver . find_element_by_name ( ' profilePic ' ) file_input . send_keys ( \" path/to/profilepic.gif \" ) # Generally it ' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \" path/to/profilepic.gif \" )) \"\"\" # transfer file to another machine only if remote driver is used # the same behaviour as for java binding if self . parent . _is_remote : local_file = self . parent . file_detector . is_local_file ( * value ) if local_file is not None : value = self . _upload ( local_file ) self . _execute ( Command . SEND_KEYS_TO_ELEMENT , { ' text ' : \"\" . join ( keys_to_typing ( value )) , ' value ' : keys_to_typing ( value ) } )","title":"send_keys"},{"location":"reference/appium/webdriver/webelement/#set_text","text":"def set_text ( self , keys = '' ) Sends text to the element. Previous text is removed. Android only. Args: keys (str): the text to be sent to the element. Usage: element.set_text('some text') Returns: appium.webdriver.webelement.WebElement View Source def set_text ( self , keys = '' ) : \"\"\" Sends text to the element. Previous text is removed . Android only . Args : keys ( str ) : the text to be sent to the element . Usage : element . set_text ( ' some text ' ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" data = { ' id ' : self . _id , ' value ' : [ keys ] } self . _execute ( Command . REPLACE_KEYS , data ) return self","title":"set_text"},{"location":"reference/appium/webdriver/webelement/#set_value","text":"def set_value ( self , value ) Set the value on this element in the application Args: value (str): The value to be set Returns: appium.webdriver.webelement.WebElement View Source def set_value ( self , value ) : \"\"\" Set the value on this element in the application Args : value ( str ) : The value to be set Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" data = { ' id ' : self . id , ' value ' : [ value ], } self . _execute ( Command . SET_IMMEDIATE_VALUE , data ) return self","title":"set_value"},{"location":"reference/appium/webdriver/webelement/#submit","text":"def submit ( self ) Submits a form. View Source def submit ( self ) : \"\"\" Submits a form. \"\"\" if self . _w3c : form = self . find_element ( By . XPATH , \" ./ancestor-or-self::form \" ) self . _parent . execute_script ( \" var e = arguments[0].ownerDocument.createEvent('Event'); \" \" e.initEvent('submit', true, true); \" \" if (arguments[0].dispatchEvent(e)) { arguments[0].submit() } \" , form ) else : self . _execute ( Command . SUBMIT_ELEMENT )","title":"submit"},{"location":"reference/appium/webdriver/webelement/#value_of_css_property","text":"def value_of_css_property ( self , property_name ) The value of a CSS property. View Source def value_of_css_property ( self , property_name ) : \"\"\" The value of a CSS property. \"\"\" return self . _execute ( Command . GET_ELEMENT_VALUE_OF_CSS_PROPERTY , { ' propertyName ' : property_name } ) [ ' value ' ]","title":"value_of_css_property"},{"location":"reference/appium/webdriver/common/","text":"Module appium.webdriver.common Appium Python Client: WebDriver common classes View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. \"\"\" Appium Python Client: WebDriver common classes \"\"\" Sub-modules appium.webdriver.common.mobileby appium.webdriver.common.multi_action appium.webdriver.common.touch_action","title":"Index"},{"location":"reference/appium/webdriver/common/#module-appiumwebdrivercommon","text":"Appium Python Client: WebDriver common classes View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. \"\"\" Appium Python Client: WebDriver common classes \"\"\"","title":"Module appium.webdriver.common"},{"location":"reference/appium/webdriver/common/#sub-modules","text":"appium.webdriver.common.mobileby appium.webdriver.common.multi_action appium.webdriver.common.touch_action","title":"Sub-modules"},{"location":"reference/appium/webdriver/common/mobileby/","text":"Module appium.webdriver.common.mobileby View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium.webdriver.common.by import By class MobileBy ( By ): IOS_PREDICATE = '-ios predicate string' IOS_UIAUTOMATION = '-ios uiautomation' IOS_CLASS_CHAIN = '-ios class chain' ANDROID_UIAUTOMATOR = '-android uiautomator' ANDROID_VIEWTAG = '-android viewtag' ANDROID_DATA_MATCHER = '-android datamatcher' ACCESSIBILITY_ID = 'accessibility id' IMAGE = '-image' CUSTOM = '-custom' Classes MobileBy class MobileBy ( / , * args , ** kwargs ) Set of supported locator strategies. View Source class MobileBy ( By ): IOS_PREDICATE = '-ios predicate string' IOS_UIAUTOMATION = '-ios uiautomation' IOS_CLASS_CHAIN = '-ios class chain' ANDROID_UIAUTOMATOR = '-android uiautomator' ANDROID_VIEWTAG = '-android viewtag' ANDROID_DATA_MATCHER = '-android datamatcher' ACCESSIBILITY_ID = 'accessibility id' IMAGE = '-image' CUSTOM = '-custom' Ancestors (in MRO) selenium.webdriver.common.by.By Class variables ACCESSIBILITY_ID ANDROID_DATA_MATCHER ANDROID_UIAUTOMATOR ANDROID_VIEWTAG CLASS_NAME CSS_SELECTOR CUSTOM ID IMAGE IOS_CLASS_CHAIN IOS_PREDICATE IOS_UIAUTOMATION LINK_TEXT NAME PARTIAL_LINK_TEXT TAG_NAME XPATH","title":"Mobileby"},{"location":"reference/appium/webdriver/common/mobileby/#module-appiumwebdrivercommonmobileby","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium.webdriver.common.by import By class MobileBy ( By ): IOS_PREDICATE = '-ios predicate string' IOS_UIAUTOMATION = '-ios uiautomation' IOS_CLASS_CHAIN = '-ios class chain' ANDROID_UIAUTOMATOR = '-android uiautomator' ANDROID_VIEWTAG = '-android viewtag' ANDROID_DATA_MATCHER = '-android datamatcher' ACCESSIBILITY_ID = 'accessibility id' IMAGE = '-image' CUSTOM = '-custom'","title":"Module appium.webdriver.common.mobileby"},{"location":"reference/appium/webdriver/common/mobileby/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/common/mobileby/#mobileby","text":"class MobileBy ( / , * args , ** kwargs ) Set of supported locator strategies. View Source class MobileBy ( By ): IOS_PREDICATE = '-ios predicate string' IOS_UIAUTOMATION = '-ios uiautomation' IOS_CLASS_CHAIN = '-ios class chain' ANDROID_UIAUTOMATOR = '-android uiautomator' ANDROID_VIEWTAG = '-android viewtag' ANDROID_DATA_MATCHER = '-android datamatcher' ACCESSIBILITY_ID = 'accessibility id' IMAGE = '-image' CUSTOM = '-custom'","title":"MobileBy"},{"location":"reference/appium/webdriver/common/mobileby/#ancestors-in-mro","text":"selenium.webdriver.common.by.By","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/common/mobileby/#class-variables","text":"ACCESSIBILITY_ID ANDROID_DATA_MATCHER ANDROID_UIAUTOMATOR ANDROID_VIEWTAG CLASS_NAME CSS_SELECTOR CUSTOM ID IMAGE IOS_CLASS_CHAIN IOS_PREDICATE IOS_UIAUTOMATION LINK_TEXT NAME PARTIAL_LINK_TEXT TAG_NAME XPATH","title":"Class variables"},{"location":"reference/appium/webdriver/common/multi_action/","text":"Module appium.webdriver.common.multi_action View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # The Selenium team implemented something like the Multi Action API in the form of # \"action chains\" (https://code.google.com/p/selenium/source/browse/py/selenium/webdriver/common/action_chains.py). # These do not quite work for this situation, and do not allow for ad hoc action # chaining as the spec requires. import copy from appium.webdriver.mobilecommand import MobileCommand as Command class MultiAction ( object ): def __init__ ( self , driver , element = None ): self . _driver = driver self . _element = element self . _touch_actions = [] def add ( self , * touch_actions ): \"\"\"Add TouchAction objects to the MultiAction, to be performed later. Args: touch_actions (`TouchAction`): one or more TouchAction objects describing a chain of actions to be performed by one finger Usage: a1 = TouchAction(driver) a1.press(el1).move_to(el2).release() a2 = TouchAction(driver) a2.press(el2).move_to(el1).release() MultiAction(driver).add(a1, a2) \"\"\" for touch_action in touch_actions : if self . _touch_actions is None : self . _touch_actions = [] self . _touch_actions . append ( copy . copy ( touch_action )) def perform ( self ): \"\"\"Perform the actions stored in the object. Usage: a1 = TouchAction(driver) a1.press(el1).move_to(el2).release() a2 = TouchAction(driver) a2.press(el2).move_to(el1).release() MultiAction(driver).add(a1, a2).perform() \"\"\" self . _driver . execute ( Command . MULTI_ACTION , self . json_wire_gestures ) # clean up and be ready for the next batch self . _touch_actions = [] return self @property def json_wire_gestures ( self ): actions = [] for action in self . _touch_actions : actions . append ( action . json_wire_gestures ) if self . _element is not None : return { 'actions' : actions , 'elementId' : self . _element . id } return { 'actions' : actions } Classes MultiAction class MultiAction ( driver , element = None ) View Source class MultiAction ( object ) : def __init__ ( self , driver , element = None ) : self . _driver = driver self . _element = element self . _touch_actions = [] def add ( self , * touch_actions ) : \"\"\" Add TouchAction objects to the MultiAction, to be performed later. Args : touch_actions ( ` TouchAction ` ) : one or more TouchAction objects describing a chain of actions to be performed by one finger Usage : a1 = TouchAction ( driver ) a1 . press ( el1 ) . move_to ( el2 ) . release () a2 = TouchAction ( driver ) a2 . press ( el2 ) . move_to ( el1 ) . release () MultiAction ( driver ) . add ( a1 , a2 ) \"\"\" for touch_action in touch_actions : if self . _touch_actions is None : self . _touch_actions = [] self . _touch_actions . append ( copy . copy ( touch_action )) def perform ( self ) : \"\"\" Perform the actions stored in the object. Usage : a1 = TouchAction ( driver ) a1 . press ( el1 ) . move_to ( el2 ) . release () a2 = TouchAction ( driver ) a2 . press ( el2 ) . move_to ( el1 ) . release () MultiAction ( driver ) . add ( a1 , a2 ) . perform () \"\"\" self . _driver . execute ( Command . MULTI_ACTION , self . json_wire_gestures ) # clean up and be ready for the next batch self . _touch_actions = [] return self @ property def json_wire_gestures ( self ) : actions = [] for action in self . _touch_actions : actions . append ( action . json_wire_gestures ) if self . _element is not None : return { ' actions ' : actions , ' elementId ' : self . _element . id } return { ' actions ' : actions } Instance variables json_wire_gestures Methods add def add ( self , * touch_actions ) Add TouchAction objects to the MultiAction, to be performed later. Args: touch_actions ( TouchAction ): one or more TouchAction objects describing a chain of actions to be performed by one finger Usage: a1 = TouchAction(driver) a1.press(el1).move_to(el2).release() a2 = TouchAction(driver) a2.press(el2).move_to(el1).release() MultiAction ( driver ). add ( a1 , a2 ) View Source def add ( self , * touch_actions ) : \"\"\" Add TouchAction objects to the MultiAction, to be performed later. Args : touch_actions ( ` TouchAction ` ) : one or more TouchAction objects describing a chain of actions to be performed by one finger Usage : a1 = TouchAction ( driver ) a1 . press ( el1 ) . move_to ( el2 ) . release () a2 = TouchAction ( driver ) a2 . press ( el2 ) . move_to ( el1 ) . release () MultiAction ( driver ) . add ( a1 , a2 ) \"\"\" for touch_action in touch_actions : if self . _touch_actions is None : self . _touch_actions = [] self . _touch_actions . append ( copy . copy ( touch_action )) perform def perform ( self ) Perform the actions stored in the object. Usage: a1 = TouchAction(driver) a1.press(el1).move_to(el2).release() a2 = TouchAction(driver) a2.press(el2).move_to(el1).release() MultiAction ( driver ). add ( a1 , a2 ). perform () View Source def perform ( self ) : \"\"\" Perform the actions stored in the object. Usage : a1 = TouchAction ( driver ) a1 . press ( el1 ) . move_to ( el2 ) . release () a2 = TouchAction ( driver ) a2 . press ( el2 ) . move_to ( el1 ) . release () MultiAction ( driver ) . add ( a1 , a2 ) . perform () \"\"\" self . _driver . execute ( Command . MULTI_ACTION , self . json_wire_gestures ) # clean up and be ready for the next batch self . _touch_actions = [] return self","title":"Multi Action"},{"location":"reference/appium/webdriver/common/multi_action/#module-appiumwebdrivercommonmulti_action","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # The Selenium team implemented something like the Multi Action API in the form of # \"action chains\" (https://code.google.com/p/selenium/source/browse/py/selenium/webdriver/common/action_chains.py). # These do not quite work for this situation, and do not allow for ad hoc action # chaining as the spec requires. import copy from appium.webdriver.mobilecommand import MobileCommand as Command class MultiAction ( object ): def __init__ ( self , driver , element = None ): self . _driver = driver self . _element = element self . _touch_actions = [] def add ( self , * touch_actions ): \"\"\"Add TouchAction objects to the MultiAction, to be performed later. Args: touch_actions (`TouchAction`): one or more TouchAction objects describing a chain of actions to be performed by one finger Usage: a1 = TouchAction(driver) a1.press(el1).move_to(el2).release() a2 = TouchAction(driver) a2.press(el2).move_to(el1).release() MultiAction(driver).add(a1, a2) \"\"\" for touch_action in touch_actions : if self . _touch_actions is None : self . _touch_actions = [] self . _touch_actions . append ( copy . copy ( touch_action )) def perform ( self ): \"\"\"Perform the actions stored in the object. Usage: a1 = TouchAction(driver) a1.press(el1).move_to(el2).release() a2 = TouchAction(driver) a2.press(el2).move_to(el1).release() MultiAction(driver).add(a1, a2).perform() \"\"\" self . _driver . execute ( Command . MULTI_ACTION , self . json_wire_gestures ) # clean up and be ready for the next batch self . _touch_actions = [] return self @property def json_wire_gestures ( self ): actions = [] for action in self . _touch_actions : actions . append ( action . json_wire_gestures ) if self . _element is not None : return { 'actions' : actions , 'elementId' : self . _element . id } return { 'actions' : actions }","title":"Module appium.webdriver.common.multi_action"},{"location":"reference/appium/webdriver/common/multi_action/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/common/multi_action/#multiaction","text":"class MultiAction ( driver , element = None ) View Source class MultiAction ( object ) : def __init__ ( self , driver , element = None ) : self . _driver = driver self . _element = element self . _touch_actions = [] def add ( self , * touch_actions ) : \"\"\" Add TouchAction objects to the MultiAction, to be performed later. Args : touch_actions ( ` TouchAction ` ) : one or more TouchAction objects describing a chain of actions to be performed by one finger Usage : a1 = TouchAction ( driver ) a1 . press ( el1 ) . move_to ( el2 ) . release () a2 = TouchAction ( driver ) a2 . press ( el2 ) . move_to ( el1 ) . release () MultiAction ( driver ) . add ( a1 , a2 ) \"\"\" for touch_action in touch_actions : if self . _touch_actions is None : self . _touch_actions = [] self . _touch_actions . append ( copy . copy ( touch_action )) def perform ( self ) : \"\"\" Perform the actions stored in the object. Usage : a1 = TouchAction ( driver ) a1 . press ( el1 ) . move_to ( el2 ) . release () a2 = TouchAction ( driver ) a2 . press ( el2 ) . move_to ( el1 ) . release () MultiAction ( driver ) . add ( a1 , a2 ) . perform () \"\"\" self . _driver . execute ( Command . MULTI_ACTION , self . json_wire_gestures ) # clean up and be ready for the next batch self . _touch_actions = [] return self @ property def json_wire_gestures ( self ) : actions = [] for action in self . _touch_actions : actions . append ( action . json_wire_gestures ) if self . _element is not None : return { ' actions ' : actions , ' elementId ' : self . _element . id } return { ' actions ' : actions }","title":"MultiAction"},{"location":"reference/appium/webdriver/common/multi_action/#instance-variables","text":"json_wire_gestures","title":"Instance variables"},{"location":"reference/appium/webdriver/common/multi_action/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/common/multi_action/#add","text":"def add ( self , * touch_actions ) Add TouchAction objects to the MultiAction, to be performed later. Args: touch_actions ( TouchAction ): one or more TouchAction objects describing a chain of actions to be performed by one finger Usage: a1 = TouchAction(driver) a1.press(el1).move_to(el2).release() a2 = TouchAction(driver) a2.press(el2).move_to(el1).release() MultiAction ( driver ). add ( a1 , a2 ) View Source def add ( self , * touch_actions ) : \"\"\" Add TouchAction objects to the MultiAction, to be performed later. Args : touch_actions ( ` TouchAction ` ) : one or more TouchAction objects describing a chain of actions to be performed by one finger Usage : a1 = TouchAction ( driver ) a1 . press ( el1 ) . move_to ( el2 ) . release () a2 = TouchAction ( driver ) a2 . press ( el2 ) . move_to ( el1 ) . release () MultiAction ( driver ) . add ( a1 , a2 ) \"\"\" for touch_action in touch_actions : if self . _touch_actions is None : self . _touch_actions = [] self . _touch_actions . append ( copy . copy ( touch_action ))","title":"add"},{"location":"reference/appium/webdriver/common/multi_action/#perform","text":"def perform ( self ) Perform the actions stored in the object. Usage: a1 = TouchAction(driver) a1.press(el1).move_to(el2).release() a2 = TouchAction(driver) a2.press(el2).move_to(el1).release() MultiAction ( driver ). add ( a1 , a2 ). perform () View Source def perform ( self ) : \"\"\" Perform the actions stored in the object. Usage : a1 = TouchAction ( driver ) a1 . press ( el1 ) . move_to ( el2 ) . release () a2 = TouchAction ( driver ) a2 . press ( el2 ) . move_to ( el1 ) . release () MultiAction ( driver ) . add ( a1 , a2 ) . perform () \"\"\" self . _driver . execute ( Command . MULTI_ACTION , self . json_wire_gestures ) # clean up and be ready for the next batch self . _touch_actions = [] return self","title":"perform"},{"location":"reference/appium/webdriver/common/touch_action/","text":"Module appium.webdriver.common.touch_action View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # The Selenium team implemented a version of the Touch Action API in their code # (https://code.google.com/p/selenium/source/browse/py/selenium/webdriver/common/touch_actions.py) # but it is deficient in many ways, and does not work in such a way as to be # amenable to Appium's use of iOS UIAutomation and Android UIAutomator # So it is reimplemented here. # # Theirs is `TouchActions`. Appium's is `TouchAction`. # pylint: disable=no-self-use import copy from appium.webdriver.mobilecommand import MobileCommand as Command class TouchAction ( object ): def __init__ ( self , driver = None ): self . _driver = driver self . _actions = [] def tap ( self , element = None , x = None , y = None , count = 1 ): \"\"\"Perform a tap action on the element Args: element (`appium.webdriver.webelement.WebElement`): the element to tap x (:obj:`int`, optional): x coordinate to tap, relative to the top left corner of the element. y (:obj:`int`, optional): y coordinate. If y is used, x must also be set, and vice versa Returns: `TouchAction`: self instance \"\"\" opts = self . _get_opts ( element , x , y ) opts [ 'count' ] = count self . _add_action ( 'tap' , opts ) return self def press ( self , el = None , x = None , y = None , pressure = None ): \"\"\"Begin a chain with a press down action at a particular element or point Args: el (:obj:`appium.webdriver.webelement.WebElement`, optional): the element to press x (:obj:`int`, optional): x coordiate to press. If y is used, x must also be set y (:obj:`int`, optional): y coordiate to press. If x is used, y must also be set pressure (:obj:`float`, optional): [iOS Only] press as force touch. Read the description of `force` property on Apple's UITouch class (https://developer.apple.com/documentation/uikit/uitouch?language=objc) for more details on possible value ranges. Returns: `TouchAction`: self instance \"\"\" self . _add_action ( 'press' , self . _get_opts ( el , x , y , pressure = pressure )) return self def long_press ( self , el = None , x = None , y = None , duration = 1000 ): \"\"\"Begin a chain with a press down that lasts `duration` milliseconds Args: el (:obj:`appium.webdriver.webelement.WebElement`, optional): the element to press x (:obj:`int`, optional): x coordiate to press. If y is used, x must also be set y (:obj:`int`, optional): y coordiate to press. If x is used, y must also be set duration (:obj:`int`, optional): Duration to press Returns: `TouchAction`: self instance \"\"\" self . _add_action ( 'longPress' , self . _get_opts ( el , x , y , duration )) return self def wait ( self , ms = 0 ): \"\"\"Pause for `ms` milliseconds. Args: ms (int): The time to pause Returns: `TouchAction`: self instance \"\"\" if ms is None : ms = 0 opts = { 'ms' : ms } self . _add_action ( 'wait' , opts ) return self def move_to ( self , el = None , x = None , y = None ): \"\"\"Move the pointer from the previous point to the element or point specified Args: el (:obj:`appium.webdriver.webelement.WebElement`, optional): the element to be moved to x (:obj:`int`, optional): x coordiate to be moved to. If y is used, x must also be set y (:obj:`int`, optional): y coordiate to be moved to. If x is used, y must also be set Returns: `TouchAction`: self instance \"\"\" self . _add_action ( 'moveTo' , self . _get_opts ( el , x , y )) return self def release ( self ): \"\"\"End the action by lifting the pointer off the screen Returns: `TouchAction`: self instance \"\"\" self . _add_action ( 'release' , {}) return self def perform ( self ): \"\"\"Perform the action by sending the commands to the server to be operated upon Returns: `TouchAction`: self instance \"\"\" params = { 'actions' : self . _actions } self . _driver . execute ( Command . TOUCH_ACTION , params ) # get rid of actions so the object can be reused self . _actions = [] return self @property def json_wire_gestures ( self ): gestures = [] for action in self . _actions : gestures . append ( copy . deepcopy ( action )) return gestures def _add_action ( self , action , options ): gesture = { 'action' : action , 'options' : options , } self . _actions . append ( gesture ) def _get_opts ( self , element , x , y , duration = None , pressure = None ): opts = {} if element is not None : opts [ 'element' ] = element . id # it makes no sense to have x but no y, or vice versa. if x is not None and y is not None : opts [ 'x' ] = x opts [ 'y' ] = y if duration is not None : opts [ 'duration' ] = duration if pressure is not None : opts [ 'pressure' ] = pressure return opts Classes TouchAction class TouchAction ( driver = None ) View Source class TouchAction ( object ) : def __init__ ( self , driver = None ) : self . _driver = driver self . _actions = [] def tap ( self , element = None , x = None , y = None , count = 1 ) : \"\"\"Perform a tap action on the element Args : element ( ` appium . webdriver . webelement . WebElement ` ) : the element to tap x ( : obj : ` int ` , optional ) : x coordinate to tap , relative to the top left corner of the element . y ( : obj : ` int ` , optional ) : y coordinate . If y is used , x must also be set , and vice versa Returns : ` TouchAction ` : self instance \"\"\" opts = self . _get_opts ( element , x , y ) opts [ ' count ' ] = count self . _add_action ( ' tap ' , opts ) return self def press ( self , el = None , x = None , y = None , pressure = None ) : \"\"\"Begin a chain with a press down action at a particular element or point Args : el ( : obj : ` appium . webdriver . webelement . WebElement ` , optional ) : the element to press x ( : obj : ` int ` , optional ) : x coordiate to press . If y is used , x must also be set y ( : obj : ` int ` , optional ) : y coordiate to press . If x is used , y must also be set pressure ( : obj : ` float ` , optional ) : [ iOS Only ] press as force touch . Read the description of ` force ` property on Apple ' s UITouch class ( https : //developer.apple.com/documentation/uikit/uitouch?language=objc) for more details on possible value ranges. Returns : ` TouchAction ` : self instance \"\"\" self . _add_action ( ' press ' , self . _get_opts ( el , x , y , pressure = pressure )) return self def long_press ( self , el = None , x = None , y = None , duration = 1000 ) : \"\"\"Begin a chain with a press down that lasts `duration` milliseconds Args : el ( : obj : ` appium . webdriver . webelement . WebElement ` , optional ) : the element to press x ( : obj : ` int ` , optional ) : x coordiate to press . If y is used , x must also be set y ( : obj : ` int ` , optional ) : y coordiate to press . If x is used , y must also be set duration ( : obj : ` int ` , optional ) : Duration to press Returns : ` TouchAction ` : self instance \"\"\" self . _add_action ( ' longPress ' , self . _get_opts ( el , x , y , duration )) return self def wait ( self , ms = 0 ) : \"\"\"Pause for `ms` milliseconds. Args : ms ( int ) : The time to pause Returns : ` TouchAction ` : self instance \"\"\" if ms is None : ms = 0 opts = { ' ms ' : ms } self . _add_action ( ' wait ' , opts ) return self def move_to ( self , el = None , x = None , y = None ) : \"\"\"Move the pointer from the previous point to the element or point specified Args : el ( : obj : ` appium . webdriver . webelement . WebElement ` , optional ) : the element to be moved to x ( : obj : ` int ` , optional ) : x coordiate to be moved to . If y is used , x must also be set y ( : obj : ` int ` , optional ) : y coordiate to be moved to . If x is used , y must also be set Returns : ` TouchAction ` : self instance \"\"\" self . _add_action ( ' moveTo ' , self . _get_opts ( el , x , y )) return self def release ( self ) : \"\"\"End the action by lifting the pointer off the screen Returns : ` TouchAction ` : self instance \"\"\" self . _add_action ( ' release ' , {}) return self def perform ( self ) : \"\"\"Perform the action by sending the commands to the server to be operated upon Returns : ` TouchAction ` : self instance \"\"\" params = { ' actions ' : self . _actions } self . _driver . execute ( Command . TOUCH_ACTION , params ) # get rid of actions so the object can be reused self . _actions = [] return self @property def json_wire_gestures ( self ) : gestures = [] for action in self . _actions : gestures . append ( copy . deepcopy ( action )) return gestures def _add_action ( self , action , options ) : gesture = { ' action ' : action , ' options ' : options , } self . _actions . append ( gesture ) def _get_opts ( self , element , x , y , duration = None , pressure = None ) : opts = {} if element is not None : opts [ ' element ' ] = element . id # it makes no sense to have x but no y, or vice versa. if x is not None and y is not None : opts [ 'x' ] = x opts [ 'y' ] = y if duration is not None : opts [ ' duration ' ] = duration if pressure is not None : opts [ ' pressure ' ] = pressure return opts Instance variables json_wire_gestures Methods long_press def long_press ( self , el = None , x = None , y = None , duration = 1000 ) Begin a chain with a press down that lasts duration milliseconds Args: el (:obj: appium.webdriver.webelement.WebElement , optional): the element to press x (:obj: int , optional): x coordiate to press. If y is used, x must also be set y (:obj: int , optional): y coordiate to press. If x is used, y must also be set duration (:obj: int , optional): Duration to press Returns: TouchAction : self instance View Source def long_press ( self , el = None , x = None , y = None , duration = 1000 ) : \"\"\" Begin a chain with a press down that lasts `duration` milliseconds Args : el ( : obj :` appium . webdriver . webelement . WebElement `, optional ) : the element to press x ( : obj :` int `, optional ) : x coordiate to press . If y is used , x must also be set y ( : obj :` int `, optional ) : y coordiate to press . If x is used , y must also be set duration ( : obj :` int `, optional ) : Duration to press Returns : ` TouchAction `: self instance \"\"\" self . _add_action ( ' longPress ' , self . _get_opts ( el , x , y , duration )) return self move_to def move_to ( self , el = None , x = None , y = None ) Move the pointer from the previous point to the element or point specified Args: el (:obj: appium.webdriver.webelement.WebElement , optional): the element to be moved to x (:obj: int , optional): x coordiate to be moved to. If y is used, x must also be set y (:obj: int , optional): y coordiate to be moved to. If x is used, y must also be set Returns: TouchAction : self instance View Source def move_to ( self , el = None , x = None , y = None ) : \"\"\" Move the pointer from the previous point to the element or point specified Args : el ( : obj :` appium . webdriver . webelement . WebElement `, optional ) : the element to be moved to x ( : obj :` int `, optional ) : x coordiate to be moved to . If y is used , x must also be set y ( : obj :` int `, optional ) : y coordiate to be moved to . If x is used , y must also be set Returns : ` TouchAction `: self instance \"\"\" self . _add_action ( ' moveTo ' , self . _get_opts ( el , x , y )) return self perform def perform ( self ) Perform the action by sending the commands to the server to be operated upon Returns: TouchAction : self instance View Source def perform ( self ) : \"\"\" Perform the action by sending the commands to the server to be operated upon Returns : ` TouchAction `: self instance \"\"\" params = { ' actions ' : self . _actions } self . _driver . execute ( Command . TOUCH_ACTION , params ) # get rid of actions so the object can be reused self . _actions = [] return self press def press ( self , el = None , x = None , y = None , pressure = None ) Begin a chain with a press down action at a particular element or point Args: el (:obj: appium.webdriver.webelement.WebElement , optional): the element to press x (:obj: int , optional): x coordiate to press. If y is used, x must also be set y (:obj: int , optional): y coordiate to press. If x is used, y must also be set pressure (:obj: float , optional): [iOS Only] press as force touch. Read the description of force property on Apple's UITouch class (https://developer.apple.com/documentation/uikit/uitouch?language=objc) for more details on possible value ranges. Returns: TouchAction : self instance View Source def press ( self , el = None , x = None , y = None , pressure = None ) : \"\"\"Begin a chain with a press down action at a particular element or point Args : el ( : obj : ` appium . webdriver . webelement . WebElement ` , optional ) : the element to press x ( : obj : ` int ` , optional ) : x coordiate to press . If y is used , x must also be set y ( : obj : ` int ` , optional ) : y coordiate to press . If x is used , y must also be set pressure ( : obj : ` float ` , optional ) : [ iOS Only ] press as force touch . Read the description of ` force ` property on Apple ' s UITouch class ( https : //developer.apple.com/documentation/uikit/uitouch?language=objc) for more details on possible value ranges. Returns : ` TouchAction ` : self instance \"\"\" self . _add_action ( ' press ' , self . _get_opts ( el , x , y , pressure = pressure )) return self release def release ( self ) End the action by lifting the pointer off the screen Returns: TouchAction : self instance View Source def release ( self ) : \"\"\" End the action by lifting the pointer off the screen Returns : ` TouchAction `: self instance \"\"\" self . _add_action ( ' release ' , {} ) return self tap def tap ( self , element = None , x = None , y = None , count = 1 ) Perform a tap action on the element Args: element ( appium.webdriver.webelement.WebElement ): the element to tap x (:obj: int , optional): x coordinate to tap, relative to the top left corner of the element. y (:obj: int , optional): y coordinate. If y is used, x must also be set, and vice versa Returns: TouchAction : self instance View Source def tap ( self , element = None , x = None , y = None , count = 1 ) : \"\"\" Perform a tap action on the element Args : element ( ` appium . webdriver . webelement . WebElement ` ) : the element to tap x ( : obj :` int `, optional ) : x coordinate to tap , relative to the top left corner of the element . y ( : obj :` int `, optional ) : y coordinate . If y is used , x must also be set , and vice versa Returns : ` TouchAction `: self instance \"\"\" opts = self . _get_opts ( element , x , y ) opts [ ' count ' ] = count self . _add_action ( ' tap ' , opts ) return self wait def wait ( self , ms = 0 ) Pause for ms milliseconds. Args: ms (int): The time to pause Returns: TouchAction : self instance View Source def wait ( self , ms = 0 ) : \"\"\" Pause for `ms` milliseconds. Args : ms ( int ) : The time to pause Returns : ` TouchAction `: self instance \"\"\" if ms is None : ms = 0 opts = { ' ms ' : ms } self . _add_action ( ' wait ' , opts ) return self","title":"Touch Action"},{"location":"reference/appium/webdriver/common/touch_action/#module-appiumwebdrivercommontouch_action","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # The Selenium team implemented a version of the Touch Action API in their code # (https://code.google.com/p/selenium/source/browse/py/selenium/webdriver/common/touch_actions.py) # but it is deficient in many ways, and does not work in such a way as to be # amenable to Appium's use of iOS UIAutomation and Android UIAutomator # So it is reimplemented here. # # Theirs is `TouchActions`. Appium's is `TouchAction`. # pylint: disable=no-self-use import copy from appium.webdriver.mobilecommand import MobileCommand as Command class TouchAction ( object ): def __init__ ( self , driver = None ): self . _driver = driver self . _actions = [] def tap ( self , element = None , x = None , y = None , count = 1 ): \"\"\"Perform a tap action on the element Args: element (`appium.webdriver.webelement.WebElement`): the element to tap x (:obj:`int`, optional): x coordinate to tap, relative to the top left corner of the element. y (:obj:`int`, optional): y coordinate. If y is used, x must also be set, and vice versa Returns: `TouchAction`: self instance \"\"\" opts = self . _get_opts ( element , x , y ) opts [ 'count' ] = count self . _add_action ( 'tap' , opts ) return self def press ( self , el = None , x = None , y = None , pressure = None ): \"\"\"Begin a chain with a press down action at a particular element or point Args: el (:obj:`appium.webdriver.webelement.WebElement`, optional): the element to press x (:obj:`int`, optional): x coordiate to press. If y is used, x must also be set y (:obj:`int`, optional): y coordiate to press. If x is used, y must also be set pressure (:obj:`float`, optional): [iOS Only] press as force touch. Read the description of `force` property on Apple's UITouch class (https://developer.apple.com/documentation/uikit/uitouch?language=objc) for more details on possible value ranges. Returns: `TouchAction`: self instance \"\"\" self . _add_action ( 'press' , self . _get_opts ( el , x , y , pressure = pressure )) return self def long_press ( self , el = None , x = None , y = None , duration = 1000 ): \"\"\"Begin a chain with a press down that lasts `duration` milliseconds Args: el (:obj:`appium.webdriver.webelement.WebElement`, optional): the element to press x (:obj:`int`, optional): x coordiate to press. If y is used, x must also be set y (:obj:`int`, optional): y coordiate to press. If x is used, y must also be set duration (:obj:`int`, optional): Duration to press Returns: `TouchAction`: self instance \"\"\" self . _add_action ( 'longPress' , self . _get_opts ( el , x , y , duration )) return self def wait ( self , ms = 0 ): \"\"\"Pause for `ms` milliseconds. Args: ms (int): The time to pause Returns: `TouchAction`: self instance \"\"\" if ms is None : ms = 0 opts = { 'ms' : ms } self . _add_action ( 'wait' , opts ) return self def move_to ( self , el = None , x = None , y = None ): \"\"\"Move the pointer from the previous point to the element or point specified Args: el (:obj:`appium.webdriver.webelement.WebElement`, optional): the element to be moved to x (:obj:`int`, optional): x coordiate to be moved to. If y is used, x must also be set y (:obj:`int`, optional): y coordiate to be moved to. If x is used, y must also be set Returns: `TouchAction`: self instance \"\"\" self . _add_action ( 'moveTo' , self . _get_opts ( el , x , y )) return self def release ( self ): \"\"\"End the action by lifting the pointer off the screen Returns: `TouchAction`: self instance \"\"\" self . _add_action ( 'release' , {}) return self def perform ( self ): \"\"\"Perform the action by sending the commands to the server to be operated upon Returns: `TouchAction`: self instance \"\"\" params = { 'actions' : self . _actions } self . _driver . execute ( Command . TOUCH_ACTION , params ) # get rid of actions so the object can be reused self . _actions = [] return self @property def json_wire_gestures ( self ): gestures = [] for action in self . _actions : gestures . append ( copy . deepcopy ( action )) return gestures def _add_action ( self , action , options ): gesture = { 'action' : action , 'options' : options , } self . _actions . append ( gesture ) def _get_opts ( self , element , x , y , duration = None , pressure = None ): opts = {} if element is not None : opts [ 'element' ] = element . id # it makes no sense to have x but no y, or vice versa. if x is not None and y is not None : opts [ 'x' ] = x opts [ 'y' ] = y if duration is not None : opts [ 'duration' ] = duration if pressure is not None : opts [ 'pressure' ] = pressure return opts","title":"Module appium.webdriver.common.touch_action"},{"location":"reference/appium/webdriver/common/touch_action/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/common/touch_action/#touchaction","text":"class TouchAction ( driver = None ) View Source class TouchAction ( object ) : def __init__ ( self , driver = None ) : self . _driver = driver self . _actions = [] def tap ( self , element = None , x = None , y = None , count = 1 ) : \"\"\"Perform a tap action on the element Args : element ( ` appium . webdriver . webelement . WebElement ` ) : the element to tap x ( : obj : ` int ` , optional ) : x coordinate to tap , relative to the top left corner of the element . y ( : obj : ` int ` , optional ) : y coordinate . If y is used , x must also be set , and vice versa Returns : ` TouchAction ` : self instance \"\"\" opts = self . _get_opts ( element , x , y ) opts [ ' count ' ] = count self . _add_action ( ' tap ' , opts ) return self def press ( self , el = None , x = None , y = None , pressure = None ) : \"\"\"Begin a chain with a press down action at a particular element or point Args : el ( : obj : ` appium . webdriver . webelement . WebElement ` , optional ) : the element to press x ( : obj : ` int ` , optional ) : x coordiate to press . If y is used , x must also be set y ( : obj : ` int ` , optional ) : y coordiate to press . If x is used , y must also be set pressure ( : obj : ` float ` , optional ) : [ iOS Only ] press as force touch . Read the description of ` force ` property on Apple ' s UITouch class ( https : //developer.apple.com/documentation/uikit/uitouch?language=objc) for more details on possible value ranges. Returns : ` TouchAction ` : self instance \"\"\" self . _add_action ( ' press ' , self . _get_opts ( el , x , y , pressure = pressure )) return self def long_press ( self , el = None , x = None , y = None , duration = 1000 ) : \"\"\"Begin a chain with a press down that lasts `duration` milliseconds Args : el ( : obj : ` appium . webdriver . webelement . WebElement ` , optional ) : the element to press x ( : obj : ` int ` , optional ) : x coordiate to press . If y is used , x must also be set y ( : obj : ` int ` , optional ) : y coordiate to press . If x is used , y must also be set duration ( : obj : ` int ` , optional ) : Duration to press Returns : ` TouchAction ` : self instance \"\"\" self . _add_action ( ' longPress ' , self . _get_opts ( el , x , y , duration )) return self def wait ( self , ms = 0 ) : \"\"\"Pause for `ms` milliseconds. Args : ms ( int ) : The time to pause Returns : ` TouchAction ` : self instance \"\"\" if ms is None : ms = 0 opts = { ' ms ' : ms } self . _add_action ( ' wait ' , opts ) return self def move_to ( self , el = None , x = None , y = None ) : \"\"\"Move the pointer from the previous point to the element or point specified Args : el ( : obj : ` appium . webdriver . webelement . WebElement ` , optional ) : the element to be moved to x ( : obj : ` int ` , optional ) : x coordiate to be moved to . If y is used , x must also be set y ( : obj : ` int ` , optional ) : y coordiate to be moved to . If x is used , y must also be set Returns : ` TouchAction ` : self instance \"\"\" self . _add_action ( ' moveTo ' , self . _get_opts ( el , x , y )) return self def release ( self ) : \"\"\"End the action by lifting the pointer off the screen Returns : ` TouchAction ` : self instance \"\"\" self . _add_action ( ' release ' , {}) return self def perform ( self ) : \"\"\"Perform the action by sending the commands to the server to be operated upon Returns : ` TouchAction ` : self instance \"\"\" params = { ' actions ' : self . _actions } self . _driver . execute ( Command . TOUCH_ACTION , params ) # get rid of actions so the object can be reused self . _actions = [] return self @property def json_wire_gestures ( self ) : gestures = [] for action in self . _actions : gestures . append ( copy . deepcopy ( action )) return gestures def _add_action ( self , action , options ) : gesture = { ' action ' : action , ' options ' : options , } self . _actions . append ( gesture ) def _get_opts ( self , element , x , y , duration = None , pressure = None ) : opts = {} if element is not None : opts [ ' element ' ] = element . id # it makes no sense to have x but no y, or vice versa. if x is not None and y is not None : opts [ 'x' ] = x opts [ 'y' ] = y if duration is not None : opts [ ' duration ' ] = duration if pressure is not None : opts [ ' pressure ' ] = pressure return opts","title":"TouchAction"},{"location":"reference/appium/webdriver/common/touch_action/#instance-variables","text":"json_wire_gestures","title":"Instance variables"},{"location":"reference/appium/webdriver/common/touch_action/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/common/touch_action/#long_press","text":"def long_press ( self , el = None , x = None , y = None , duration = 1000 ) Begin a chain with a press down that lasts duration milliseconds Args: el (:obj: appium.webdriver.webelement.WebElement , optional): the element to press x (:obj: int , optional): x coordiate to press. If y is used, x must also be set y (:obj: int , optional): y coordiate to press. If x is used, y must also be set duration (:obj: int , optional): Duration to press Returns: TouchAction : self instance View Source def long_press ( self , el = None , x = None , y = None , duration = 1000 ) : \"\"\" Begin a chain with a press down that lasts `duration` milliseconds Args : el ( : obj :` appium . webdriver . webelement . WebElement `, optional ) : the element to press x ( : obj :` int `, optional ) : x coordiate to press . If y is used , x must also be set y ( : obj :` int `, optional ) : y coordiate to press . If x is used , y must also be set duration ( : obj :` int `, optional ) : Duration to press Returns : ` TouchAction `: self instance \"\"\" self . _add_action ( ' longPress ' , self . _get_opts ( el , x , y , duration )) return self","title":"long_press"},{"location":"reference/appium/webdriver/common/touch_action/#move_to","text":"def move_to ( self , el = None , x = None , y = None ) Move the pointer from the previous point to the element or point specified Args: el (:obj: appium.webdriver.webelement.WebElement , optional): the element to be moved to x (:obj: int , optional): x coordiate to be moved to. If y is used, x must also be set y (:obj: int , optional): y coordiate to be moved to. If x is used, y must also be set Returns: TouchAction : self instance View Source def move_to ( self , el = None , x = None , y = None ) : \"\"\" Move the pointer from the previous point to the element or point specified Args : el ( : obj :` appium . webdriver . webelement . WebElement `, optional ) : the element to be moved to x ( : obj :` int `, optional ) : x coordiate to be moved to . If y is used , x must also be set y ( : obj :` int `, optional ) : y coordiate to be moved to . If x is used , y must also be set Returns : ` TouchAction `: self instance \"\"\" self . _add_action ( ' moveTo ' , self . _get_opts ( el , x , y )) return self","title":"move_to"},{"location":"reference/appium/webdriver/common/touch_action/#perform","text":"def perform ( self ) Perform the action by sending the commands to the server to be operated upon Returns: TouchAction : self instance View Source def perform ( self ) : \"\"\" Perform the action by sending the commands to the server to be operated upon Returns : ` TouchAction `: self instance \"\"\" params = { ' actions ' : self . _actions } self . _driver . execute ( Command . TOUCH_ACTION , params ) # get rid of actions so the object can be reused self . _actions = [] return self","title":"perform"},{"location":"reference/appium/webdriver/common/touch_action/#press","text":"def press ( self , el = None , x = None , y = None , pressure = None ) Begin a chain with a press down action at a particular element or point Args: el (:obj: appium.webdriver.webelement.WebElement , optional): the element to press x (:obj: int , optional): x coordiate to press. If y is used, x must also be set y (:obj: int , optional): y coordiate to press. If x is used, y must also be set pressure (:obj: float , optional): [iOS Only] press as force touch. Read the description of force property on Apple's UITouch class (https://developer.apple.com/documentation/uikit/uitouch?language=objc) for more details on possible value ranges. Returns: TouchAction : self instance View Source def press ( self , el = None , x = None , y = None , pressure = None ) : \"\"\"Begin a chain with a press down action at a particular element or point Args : el ( : obj : ` appium . webdriver . webelement . WebElement ` , optional ) : the element to press x ( : obj : ` int ` , optional ) : x coordiate to press . If y is used , x must also be set y ( : obj : ` int ` , optional ) : y coordiate to press . If x is used , y must also be set pressure ( : obj : ` float ` , optional ) : [ iOS Only ] press as force touch . Read the description of ` force ` property on Apple ' s UITouch class ( https : //developer.apple.com/documentation/uikit/uitouch?language=objc) for more details on possible value ranges. Returns : ` TouchAction ` : self instance \"\"\" self . _add_action ( ' press ' , self . _get_opts ( el , x , y , pressure = pressure )) return self","title":"press"},{"location":"reference/appium/webdriver/common/touch_action/#release","text":"def release ( self ) End the action by lifting the pointer off the screen Returns: TouchAction : self instance View Source def release ( self ) : \"\"\" End the action by lifting the pointer off the screen Returns : ` TouchAction `: self instance \"\"\" self . _add_action ( ' release ' , {} ) return self","title":"release"},{"location":"reference/appium/webdriver/common/touch_action/#tap","text":"def tap ( self , element = None , x = None , y = None , count = 1 ) Perform a tap action on the element Args: element ( appium.webdriver.webelement.WebElement ): the element to tap x (:obj: int , optional): x coordinate to tap, relative to the top left corner of the element. y (:obj: int , optional): y coordinate. If y is used, x must also be set, and vice versa Returns: TouchAction : self instance View Source def tap ( self , element = None , x = None , y = None , count = 1 ) : \"\"\" Perform a tap action on the element Args : element ( ` appium . webdriver . webelement . WebElement ` ) : the element to tap x ( : obj :` int `, optional ) : x coordinate to tap , relative to the top left corner of the element . y ( : obj :` int `, optional ) : y coordinate . If y is used , x must also be set , and vice versa Returns : ` TouchAction `: self instance \"\"\" opts = self . _get_opts ( element , x , y ) opts [ ' count ' ] = count self . _add_action ( ' tap ' , opts ) return self","title":"tap"},{"location":"reference/appium/webdriver/common/touch_action/#wait","text":"def wait ( self , ms = 0 ) Pause for ms milliseconds. Args: ms (int): The time to pause Returns: TouchAction : self instance View Source def wait ( self , ms = 0 ) : \"\"\" Pause for `ms` milliseconds. Args : ms ( int ) : The time to pause Returns : ` TouchAction `: self instance \"\"\" if ms is None : ms = 0 opts = { ' ms ' : ms } self . _add_action ( ' wait ' , opts ) return self","title":"wait"},{"location":"reference/appium/webdriver/extensions/","text":"Module appium.webdriver.extensions View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. Sub-modules appium.webdriver.extensions.action_helpers appium.webdriver.extensions.android appium.webdriver.extensions.applications appium.webdriver.extensions.clipboard appium.webdriver.extensions.context appium.webdriver.extensions.device_time appium.webdriver.extensions.execute_driver appium.webdriver.extensions.hw_actions appium.webdriver.extensions.images_comparison appium.webdriver.extensions.ime appium.webdriver.extensions.keyboard appium.webdriver.extensions.location appium.webdriver.extensions.remote_fs appium.webdriver.extensions.screen_record appium.webdriver.extensions.search_context appium.webdriver.extensions.settings","title":"Index"},{"location":"reference/appium/webdriver/extensions/#module-appiumwebdriverextensions","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License.","title":"Module appium.webdriver.extensions"},{"location":"reference/appium/webdriver/extensions/#sub-modules","text":"appium.webdriver.extensions.action_helpers appium.webdriver.extensions.android appium.webdriver.extensions.applications appium.webdriver.extensions.clipboard appium.webdriver.extensions.context appium.webdriver.extensions.device_time appium.webdriver.extensions.execute_driver appium.webdriver.extensions.hw_actions appium.webdriver.extensions.images_comparison appium.webdriver.extensions.ime appium.webdriver.extensions.keyboard appium.webdriver.extensions.location appium.webdriver.extensions.remote_fs appium.webdriver.extensions.screen_record appium.webdriver.extensions.search_context appium.webdriver.extensions.settings","title":"Sub-modules"},{"location":"reference/appium/webdriver/extensions/action_helpers/","text":"Module appium.webdriver.extensions.action_helpers View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from appium.webdriver.common.multi_action import MultiAction from appium.webdriver.common.touch_action import TouchAction class ActionHelpers ( webdriver . Remote ): def scroll ( self , origin_el , destination_el , duration = None ): \"\"\"Scrolls from one element to another Args: originalEl (`appium.webdriver.webelement.WebElement`): the element from which to being scrolling destinationEl (`appium.webdriver.webelement.WebElement`): the element to scroll to duration (int): a duration after pressing originalEl and move the element to destinationEl. Default is 600 ms for W3C spec. Zero for MJSONWP. Usage: driver.scroll(el1, el2) Returns: `appium.webdriver.webelement.WebElement` \"\"\" # XCUITest x W3C spec has no duration by default in server side if self . w3c and duration is None : duration = 600 action = TouchAction ( self ) if duration is None : action . press ( origin_el ) . move_to ( destination_el ) . release () . perform () else : action . press ( origin_el ) . wait ( duration ) . move_to ( destination_el ) . release () . perform () return self def drag_and_drop ( self , origin_el , destination_el ): \"\"\"Drag the origin element to the destination element Args: originEl (`appium.webdriver.webelement.WebElement`): the element to drag destinationEl (`appium.webdriver.webelement.WebElement`): the element to drag to Returns: `appium.webdriver.webelement.WebElement` \"\"\" action = TouchAction ( self ) action . long_press ( origin_el ) . move_to ( destination_el ) . release () . perform () return self def tap ( self , positions , duration = None ): \"\"\"Taps on an particular place with up to five fingers, holding for a certain time Args: positions (:obj:`list` of :obj:`tuple`): an array of tuples representing the x/y coordinates of the fingers to tap. Length can be up to five. duration (:obj:`int`, optional): length of time to tap, in ms Usage: driver.tap([(100, 20), (100, 60), (100, 100)], 500) Returns: `appium.webdriver.webelement.WebElement` \"\"\" if len ( positions ) == 1 : action = TouchAction ( self ) x = positions [ 0 ][ 0 ] y = positions [ 0 ][ 1 ] if duration : action . long_press ( x = x , y = y , duration = duration ) . release () else : action . tap ( x = x , y = y ) action . perform () else : ma = MultiAction ( self ) for position in positions : x = position [ 0 ] y = position [ 1 ] action = TouchAction ( self ) if duration : action . long_press ( x = x , y = y , duration = duration ) . release () else : action . press ( x = x , y = y ) . release () ma . add ( action ) ma . perform () return self def swipe ( self , start_x , start_y , end_x , end_y , duration = None ): \"\"\"Swipe from one point to another point, for an optional duration. Args: start_x (int): x-coordinate at which to start start_y (int): y-coordinate at which to start end_x (int): x-coordinate at which to stop end_y (int): y-coordinate at which to stop duration (:obj:`int`, optional): time to take the swipe, in ms. Usage: driver.swipe(100, 100, 100, 400) Returns: `appium.webdriver.webelement.WebElement` \"\"\" # `swipe` is something like press-wait-move_to-release, which the server # will translate into the correct action action = TouchAction ( self ) action \\ . press ( x = start_x , y = start_y ) \\ . wait ( ms = duration ) \\ . move_to ( x = end_x , y = end_y ) \\ . release () action . perform () return self def flick ( self , start_x , start_y , end_x , end_y ): \"\"\"Flick from one point to another point. Args: start_x (int): x-coordinate at which to start start_y (int): y-coordinate at which to start end_x (int): x-coordinate at which to stop end_y (int): y-coordinate at which to stop Usage: driver.flick(100, 100, 100, 400) Returns: `appium.webdriver.webelement.WebElement` \"\"\" action = TouchAction ( self ) action \\ . press ( x = start_x , y = start_y ) \\ . move_to ( x = end_x , y = end_y ) \\ . release () action . perform () return self Classes ActionHelpers class ActionHelpers ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class ActionHelpers ( webdriver . Remote ) : def scroll ( self , origin_el , destination_el , duration = None ) : \"\"\" Scrolls from one element to another Args : originalEl ( ` appium . webdriver . webelement . WebElement ` ) : the element from which to being scrolling destinationEl ( ` appium . webdriver . webelement . WebElement ` ) : the element to scroll to duration ( int ) : a duration after pressing originalEl and move the element to destinationEl . Default is 600 ms for W3C spec . Zero for MJSONWP . Usage : driver . scroll ( el1 , el2 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" # XCUITest x W3C spec has no duration by default in server side if self . w3c and duration is None : duration = 600 action = TouchAction ( self ) if duration is None : action . press ( origin_el ) . move_to ( destination_el ) . release () . perform () else : action . press ( origin_el ) . wait ( duration ) . move_to ( destination_el ) . release () . perform () return self def drag_and_drop ( self , origin_el , destination_el ) : \"\"\" Drag the origin element to the destination element Args : originEl ( ` appium . webdriver . webelement . WebElement ` ) : the element to drag destinationEl ( ` appium . webdriver . webelement . WebElement ` ) : the element to drag to Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" action = TouchAction ( self ) action . long_press ( origin_el ) . move_to ( destination_el ) . release () . perform () return self def tap ( self , positions , duration = None ) : \"\"\" Taps on an particular place with up to five fingers, holding for a certain time Args : positions ( : obj :` list ` of : obj :` tuple ` ) : an array of tuples representing the x / y coordinates of the fingers to tap . Length can be up to five . duration ( : obj :` int `, optional ) : length of time to tap , in ms Usage : driver . tap ( [ ( 100 , 20 ) , ( 100 , 60 ) , ( 100 , 100 ) ], 500 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" if len ( positions ) == 1 : action = TouchAction ( self ) x = positions [ 0 ][ 0 ] y = positions [ 0 ][ 1 ] if duration : action . long_press ( x = x , y = y , duration = duration ) . release () else : action . tap ( x = x , y = y ) action . perform () else : ma = MultiAction ( self ) for position in positions : x = position [ 0 ] y = position [ 1 ] action = TouchAction ( self ) if duration : action . long_press ( x = x , y = y , duration = duration ) . release () else : action . press ( x = x , y = y ) . release () ma . add ( action ) ma . perform () return self def swipe ( self , start_x , start_y , end_x , end_y , duration = None ) : \"\"\" Swipe from one point to another point, for an optional duration. Args : start_x ( int ) : x - coordinate at which to start start_y ( int ) : y - coordinate at which to start end_x ( int ) : x - coordinate at which to stop end_y ( int ) : y - coordinate at which to stop duration ( : obj :` int `, optional ) : time to take the swipe , in ms . Usage : driver . swipe ( 100 , 100 , 100 , 400 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" # ` swipe ` is something like press - wait - move_to - release , which the server # will translate into the correct action action = TouchAction ( self ) action \\ . press ( x = start_x , y = start_y ) \\ . wait ( ms = duration ) \\ . move_to ( x = end_x , y = end_y ) \\ . release () action . perform () return self def flick ( self , start_x , start_y , end_x , end_y ) : \"\"\" Flick from one point to another point. Args : start_x ( int ) : x - coordinate at which to start start_y ( int ) : y - coordinate at which to start end_x ( int ) : x - coordinate at which to stop end_y ( int ) : y - coordinate at which to stop Usage : driver . flick ( 100 , 100 , 100 , 400 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" action = TouchAction ( self ) action \\ . press ( x = start_x , y = start_y ) \\ . move_to ( x = end_x , y = end_y ) \\ . release () action . perform () return self Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) drag_and_drop def drag_and_drop ( self , origin_el , destination_el ) Drag the origin element to the destination element Args: originEl ( appium.webdriver.webelement.WebElement ): the element to drag destinationEl ( appium.webdriver.webelement.WebElement ): the element to drag to Returns: appium.webdriver.webelement.WebElement View Source def drag_and_drop ( self , origin_el , destination_el ) : \"\"\" Drag the origin element to the destination element Args : originEl ( ` appium . webdriver . webelement . WebElement ` ) : the element to drag destinationEl ( ` appium . webdriver . webelement . WebElement ` ) : the element to drag to Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" action = TouchAction ( self ) action . long_press ( origin_el ) . move_to ( destination_el ) . release () . perform () return self execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) flick def flick ( self , start_x , start_y , end_x , end_y ) Flick from one point to another point. Args: start_x (int): x-coordinate at which to start start_y (int): y-coordinate at which to start end_x (int): x-coordinate at which to stop end_y (int): y-coordinate at which to stop Usage: driver.flick(100, 100, 100, 400) Returns: appium.webdriver.webelement.WebElement View Source def flick ( self , start_x , start_y , end_x , end_y ) : \"\"\" Flick from one point to another point. Args : start_x ( int ) : x - coordinate at which to start start_y ( int ) : y - coordinate at which to start end_x ( int ) : x - coordinate at which to stop end_y ( int ) : y - coordinate at which to stop Usage : driver . flick ( 100 , 100 , 100 , 400 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" action = TouchAction ( self ) action \\ . press ( x = start_x , y = start_y ) \\ . move_to ( x = end_x , y = end_y ) \\ . release () action . perform () return self forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) scroll def scroll ( self , origin_el , destination_el , duration = None ) Scrolls from one element to another Args: originalEl ( appium.webdriver.webelement.WebElement ): the element from which to being scrolling destinationEl ( appium.webdriver.webelement.WebElement ): the element to scroll to duration (int): a duration after pressing originalEl and move the element to destinationEl. Default is 600 ms for W3C spec. Zero for MJSONWP. Usage: driver.scroll(el1, el2) Returns: appium.webdriver.webelement.WebElement View Source def scroll ( self , origin_el , destination_el , duration = None ) : \"\"\" Scrolls from one element to another Args : originalEl ( ` appium . webdriver . webelement . WebElement ` ) : the element from which to being scrolling destinationEl ( ` appium . webdriver . webelement . WebElement ` ) : the element to scroll to duration ( int ) : a duration after pressing originalEl and move the element to destinationEl . Default is 600 ms for W3C spec . Zero for MJSONWP . Usage : driver . scroll ( el1 , el2 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" # XCUITest x W3C spec has no duration by default in server side if self . w3c and duration is None : duration = 600 action = TouchAction ( self ) if duration is None : action . press ( origin_el ) . move_to ( destination_el ) . release () . perform () else : action . press ( origin_el ) . wait ( duration ) . move_to ( destination_el ) . release () . perform () return self set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass swipe def swipe ( self , start_x , start_y , end_x , end_y , duration = None ) Swipe from one point to another point, for an optional duration. Args: start_x (int): x-coordinate at which to start start_y (int): y-coordinate at which to start end_x (int): x-coordinate at which to stop end_y (int): y-coordinate at which to stop duration (:obj: int , optional): time to take the swipe, in ms. Usage: driver.swipe(100, 100, 100, 400) Returns: appium.webdriver.webelement.WebElement View Source def swipe ( self , start_x , start_y , end_x , end_y , duration = None ) : \"\"\" Swipe from one point to another point, for an optional duration. Args : start_x ( int ) : x - coordinate at which to start start_y ( int ) : y - coordinate at which to start end_x ( int ) : x - coordinate at which to stop end_y ( int ) : y - coordinate at which to stop duration ( : obj :` int `, optional ) : time to take the swipe , in ms . Usage : driver . swipe ( 100 , 100 , 100 , 400 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" # ` swipe ` is something like press - wait - move_to - release , which the server # will translate into the correct action action = TouchAction ( self ) action \\ . press ( x = start_x , y = start_y ) \\ . wait ( ms = duration ) \\ . move_to ( x = end_x , y = end_y ) \\ . release () action . perform () return self switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name ) tap def tap ( self , positions , duration = None ) Taps on an particular place with up to five fingers, holding for a certain time Args: positions (:obj: list of :obj: tuple ): an array of tuples representing the x/y coordinates of the fingers to tap. Length can be up to five. duration (:obj: int , optional): length of time to tap, in ms Usage: driver.tap([(100, 20), (100, 60), (100, 100)], 500) Returns: appium.webdriver.webelement.WebElement View Source def tap ( self , positions , duration = None ) : \"\"\" Taps on an particular place with up to five fingers, holding for a certain time Args : positions ( : obj :` list ` of : obj :` tuple ` ) : an array of tuples representing the x / y coordinates of the fingers to tap . Length can be up to five . duration ( : obj :` int `, optional ) : length of time to tap , in ms Usage : driver . tap ( [ ( 100 , 20 ) , ( 100 , 60 ) , ( 100 , 100 ) ], 500 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" if len ( positions ) == 1 : action = TouchAction ( self ) x = positions [ 0 ][ 0 ] y = positions [ 0 ][ 1 ] if duration : action . long_press ( x = x , y = y , duration = duration ) . release () else : action . tap ( x = x , y = y ) action . perform () else : ma = MultiAction ( self ) for position in positions : x = position [ 0 ] y = position [ 1 ] action = TouchAction ( self ) if duration : action . long_press ( x = x , y = y , duration = duration ) . release () else : action . press ( x = x , y = y ) . release () ma . add ( action ) ma . perform () return self","title":"Action Helpers"},{"location":"reference/appium/webdriver/extensions/action_helpers/#module-appiumwebdriverextensionsaction_helpers","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from appium.webdriver.common.multi_action import MultiAction from appium.webdriver.common.touch_action import TouchAction class ActionHelpers ( webdriver . Remote ): def scroll ( self , origin_el , destination_el , duration = None ): \"\"\"Scrolls from one element to another Args: originalEl (`appium.webdriver.webelement.WebElement`): the element from which to being scrolling destinationEl (`appium.webdriver.webelement.WebElement`): the element to scroll to duration (int): a duration after pressing originalEl and move the element to destinationEl. Default is 600 ms for W3C spec. Zero for MJSONWP. Usage: driver.scroll(el1, el2) Returns: `appium.webdriver.webelement.WebElement` \"\"\" # XCUITest x W3C spec has no duration by default in server side if self . w3c and duration is None : duration = 600 action = TouchAction ( self ) if duration is None : action . press ( origin_el ) . move_to ( destination_el ) . release () . perform () else : action . press ( origin_el ) . wait ( duration ) . move_to ( destination_el ) . release () . perform () return self def drag_and_drop ( self , origin_el , destination_el ): \"\"\"Drag the origin element to the destination element Args: originEl (`appium.webdriver.webelement.WebElement`): the element to drag destinationEl (`appium.webdriver.webelement.WebElement`): the element to drag to Returns: `appium.webdriver.webelement.WebElement` \"\"\" action = TouchAction ( self ) action . long_press ( origin_el ) . move_to ( destination_el ) . release () . perform () return self def tap ( self , positions , duration = None ): \"\"\"Taps on an particular place with up to five fingers, holding for a certain time Args: positions (:obj:`list` of :obj:`tuple`): an array of tuples representing the x/y coordinates of the fingers to tap. Length can be up to five. duration (:obj:`int`, optional): length of time to tap, in ms Usage: driver.tap([(100, 20), (100, 60), (100, 100)], 500) Returns: `appium.webdriver.webelement.WebElement` \"\"\" if len ( positions ) == 1 : action = TouchAction ( self ) x = positions [ 0 ][ 0 ] y = positions [ 0 ][ 1 ] if duration : action . long_press ( x = x , y = y , duration = duration ) . release () else : action . tap ( x = x , y = y ) action . perform () else : ma = MultiAction ( self ) for position in positions : x = position [ 0 ] y = position [ 1 ] action = TouchAction ( self ) if duration : action . long_press ( x = x , y = y , duration = duration ) . release () else : action . press ( x = x , y = y ) . release () ma . add ( action ) ma . perform () return self def swipe ( self , start_x , start_y , end_x , end_y , duration = None ): \"\"\"Swipe from one point to another point, for an optional duration. Args: start_x (int): x-coordinate at which to start start_y (int): y-coordinate at which to start end_x (int): x-coordinate at which to stop end_y (int): y-coordinate at which to stop duration (:obj:`int`, optional): time to take the swipe, in ms. Usage: driver.swipe(100, 100, 100, 400) Returns: `appium.webdriver.webelement.WebElement` \"\"\" # `swipe` is something like press-wait-move_to-release, which the server # will translate into the correct action action = TouchAction ( self ) action \\ . press ( x = start_x , y = start_y ) \\ . wait ( ms = duration ) \\ . move_to ( x = end_x , y = end_y ) \\ . release () action . perform () return self def flick ( self , start_x , start_y , end_x , end_y ): \"\"\"Flick from one point to another point. Args: start_x (int): x-coordinate at which to start start_y (int): y-coordinate at which to start end_x (int): x-coordinate at which to stop end_y (int): y-coordinate at which to stop Usage: driver.flick(100, 100, 100, 400) Returns: `appium.webdriver.webelement.WebElement` \"\"\" action = TouchAction ( self ) action \\ . press ( x = start_x , y = start_y ) \\ . move_to ( x = end_x , y = end_y ) \\ . release () action . perform () return self","title":"Module appium.webdriver.extensions.action_helpers"},{"location":"reference/appium/webdriver/extensions/action_helpers/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/action_helpers/#actionhelpers","text":"class ActionHelpers ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class ActionHelpers ( webdriver . Remote ) : def scroll ( self , origin_el , destination_el , duration = None ) : \"\"\" Scrolls from one element to another Args : originalEl ( ` appium . webdriver . webelement . WebElement ` ) : the element from which to being scrolling destinationEl ( ` appium . webdriver . webelement . WebElement ` ) : the element to scroll to duration ( int ) : a duration after pressing originalEl and move the element to destinationEl . Default is 600 ms for W3C spec . Zero for MJSONWP . Usage : driver . scroll ( el1 , el2 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" # XCUITest x W3C spec has no duration by default in server side if self . w3c and duration is None : duration = 600 action = TouchAction ( self ) if duration is None : action . press ( origin_el ) . move_to ( destination_el ) . release () . perform () else : action . press ( origin_el ) . wait ( duration ) . move_to ( destination_el ) . release () . perform () return self def drag_and_drop ( self , origin_el , destination_el ) : \"\"\" Drag the origin element to the destination element Args : originEl ( ` appium . webdriver . webelement . WebElement ` ) : the element to drag destinationEl ( ` appium . webdriver . webelement . WebElement ` ) : the element to drag to Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" action = TouchAction ( self ) action . long_press ( origin_el ) . move_to ( destination_el ) . release () . perform () return self def tap ( self , positions , duration = None ) : \"\"\" Taps on an particular place with up to five fingers, holding for a certain time Args : positions ( : obj :` list ` of : obj :` tuple ` ) : an array of tuples representing the x / y coordinates of the fingers to tap . Length can be up to five . duration ( : obj :` int `, optional ) : length of time to tap , in ms Usage : driver . tap ( [ ( 100 , 20 ) , ( 100 , 60 ) , ( 100 , 100 ) ], 500 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" if len ( positions ) == 1 : action = TouchAction ( self ) x = positions [ 0 ][ 0 ] y = positions [ 0 ][ 1 ] if duration : action . long_press ( x = x , y = y , duration = duration ) . release () else : action . tap ( x = x , y = y ) action . perform () else : ma = MultiAction ( self ) for position in positions : x = position [ 0 ] y = position [ 1 ] action = TouchAction ( self ) if duration : action . long_press ( x = x , y = y , duration = duration ) . release () else : action . press ( x = x , y = y ) . release () ma . add ( action ) ma . perform () return self def swipe ( self , start_x , start_y , end_x , end_y , duration = None ) : \"\"\" Swipe from one point to another point, for an optional duration. Args : start_x ( int ) : x - coordinate at which to start start_y ( int ) : y - coordinate at which to start end_x ( int ) : x - coordinate at which to stop end_y ( int ) : y - coordinate at which to stop duration ( : obj :` int `, optional ) : time to take the swipe , in ms . Usage : driver . swipe ( 100 , 100 , 100 , 400 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" # ` swipe ` is something like press - wait - move_to - release , which the server # will translate into the correct action action = TouchAction ( self ) action \\ . press ( x = start_x , y = start_y ) \\ . wait ( ms = duration ) \\ . move_to ( x = end_x , y = end_y ) \\ . release () action . perform () return self def flick ( self , start_x , start_y , end_x , end_y ) : \"\"\" Flick from one point to another point. Args : start_x ( int ) : x - coordinate at which to start start_y ( int ) : y - coordinate at which to start end_x ( int ) : x - coordinate at which to stop end_y ( int ) : y - coordinate at which to stop Usage : driver . flick ( 100 , 100 , 100 , 400 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" action = TouchAction ( self ) action \\ . press ( x = start_x , y = start_y ) \\ . move_to ( x = end_x , y = end_y ) \\ . release () action . perform () return self","title":"ActionHelpers"},{"location":"reference/appium/webdriver/extensions/action_helpers/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/action_helpers/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/action_helpers/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/action_helpers/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/action_helpers/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/action_helpers/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/action_helpers/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/action_helpers/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/action_helpers/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/action_helpers/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/action_helpers/#drag_and_drop","text":"def drag_and_drop ( self , origin_el , destination_el ) Drag the origin element to the destination element Args: originEl ( appium.webdriver.webelement.WebElement ): the element to drag destinationEl ( appium.webdriver.webelement.WebElement ): the element to drag to Returns: appium.webdriver.webelement.WebElement View Source def drag_and_drop ( self , origin_el , destination_el ) : \"\"\" Drag the origin element to the destination element Args : originEl ( ` appium . webdriver . webelement . WebElement ` ) : the element to drag destinationEl ( ` appium . webdriver . webelement . WebElement ` ) : the element to drag to Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" action = TouchAction ( self ) action . long_press ( origin_el ) . move_to ( destination_el ) . release () . perform () return self","title":"drag_and_drop"},{"location":"reference/appium/webdriver/extensions/action_helpers/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/action_helpers/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/action_helpers/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/action_helpers/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/action_helpers/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/action_helpers/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/action_helpers/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/action_helpers/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/action_helpers/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/action_helpers/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/action_helpers/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/action_helpers/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/action_helpers/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/action_helpers/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/action_helpers/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/action_helpers/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/action_helpers/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/action_helpers/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/action_helpers/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/action_helpers/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/action_helpers/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/action_helpers/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/action_helpers/#flick","text":"def flick ( self , start_x , start_y , end_x , end_y ) Flick from one point to another point. Args: start_x (int): x-coordinate at which to start start_y (int): y-coordinate at which to start end_x (int): x-coordinate at which to stop end_y (int): y-coordinate at which to stop Usage: driver.flick(100, 100, 100, 400) Returns: appium.webdriver.webelement.WebElement View Source def flick ( self , start_x , start_y , end_x , end_y ) : \"\"\" Flick from one point to another point. Args : start_x ( int ) : x - coordinate at which to start start_y ( int ) : y - coordinate at which to start end_x ( int ) : x - coordinate at which to stop end_y ( int ) : y - coordinate at which to stop Usage : driver . flick ( 100 , 100 , 100 , 400 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" action = TouchAction ( self ) action \\ . press ( x = start_x , y = start_y ) \\ . move_to ( x = end_x , y = end_y ) \\ . release () action . perform () return self","title":"flick"},{"location":"reference/appium/webdriver/extensions/action_helpers/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/action_helpers/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/action_helpers/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/action_helpers/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/action_helpers/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/action_helpers/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/action_helpers/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/action_helpers/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/action_helpers/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/action_helpers/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/action_helpers/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/action_helpers/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/action_helpers/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/action_helpers/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/action_helpers/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/action_helpers/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/action_helpers/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/action_helpers/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/action_helpers/#scroll","text":"def scroll ( self , origin_el , destination_el , duration = None ) Scrolls from one element to another Args: originalEl ( appium.webdriver.webelement.WebElement ): the element from which to being scrolling destinationEl ( appium.webdriver.webelement.WebElement ): the element to scroll to duration (int): a duration after pressing originalEl and move the element to destinationEl. Default is 600 ms for W3C spec. Zero for MJSONWP. Usage: driver.scroll(el1, el2) Returns: appium.webdriver.webelement.WebElement View Source def scroll ( self , origin_el , destination_el , duration = None ) : \"\"\" Scrolls from one element to another Args : originalEl ( ` appium . webdriver . webelement . WebElement ` ) : the element from which to being scrolling destinationEl ( ` appium . webdriver . webelement . WebElement ` ) : the element to scroll to duration ( int ) : a duration after pressing originalEl and move the element to destinationEl . Default is 600 ms for W3C spec . Zero for MJSONWP . Usage : driver . scroll ( el1 , el2 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" # XCUITest x W3C spec has no duration by default in server side if self . w3c and duration is None : duration = 600 action = TouchAction ( self ) if duration is None : action . press ( origin_el ) . move_to ( destination_el ) . release () . perform () else : action . press ( origin_el ) . wait ( duration ) . move_to ( destination_el ) . release () . perform () return self","title":"scroll"},{"location":"reference/appium/webdriver/extensions/action_helpers/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/action_helpers/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/action_helpers/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/action_helpers/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/action_helpers/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/action_helpers/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/action_helpers/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/action_helpers/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/action_helpers/#swipe","text":"def swipe ( self , start_x , start_y , end_x , end_y , duration = None ) Swipe from one point to another point, for an optional duration. Args: start_x (int): x-coordinate at which to start start_y (int): y-coordinate at which to start end_x (int): x-coordinate at which to stop end_y (int): y-coordinate at which to stop duration (:obj: int , optional): time to take the swipe, in ms. Usage: driver.swipe(100, 100, 100, 400) Returns: appium.webdriver.webelement.WebElement View Source def swipe ( self , start_x , start_y , end_x , end_y , duration = None ) : \"\"\" Swipe from one point to another point, for an optional duration. Args : start_x ( int ) : x - coordinate at which to start start_y ( int ) : y - coordinate at which to start end_x ( int ) : x - coordinate at which to stop end_y ( int ) : y - coordinate at which to stop duration ( : obj :` int `, optional ) : time to take the swipe , in ms . Usage : driver . swipe ( 100 , 100 , 100 , 400 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" # ` swipe ` is something like press - wait - move_to - release , which the server # will translate into the correct action action = TouchAction ( self ) action \\ . press ( x = start_x , y = start_y ) \\ . wait ( ms = duration ) \\ . move_to ( x = end_x , y = end_y ) \\ . release () action . perform () return self","title":"swipe"},{"location":"reference/appium/webdriver/extensions/action_helpers/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/action_helpers/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/action_helpers/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/action_helpers/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/action_helpers/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/action_helpers/#tap","text":"def tap ( self , positions , duration = None ) Taps on an particular place with up to five fingers, holding for a certain time Args: positions (:obj: list of :obj: tuple ): an array of tuples representing the x/y coordinates of the fingers to tap. Length can be up to five. duration (:obj: int , optional): length of time to tap, in ms Usage: driver.tap([(100, 20), (100, 60), (100, 100)], 500) Returns: appium.webdriver.webelement.WebElement View Source def tap ( self , positions , duration = None ) : \"\"\" Taps on an particular place with up to five fingers, holding for a certain time Args : positions ( : obj :` list ` of : obj :` tuple ` ) : an array of tuples representing the x / y coordinates of the fingers to tap . Length can be up to five . duration ( : obj :` int `, optional ) : length of time to tap , in ms Usage : driver . tap ( [ ( 100 , 20 ) , ( 100 , 60 ) , ( 100 , 100 ) ], 500 ) Returns : ` appium . webdriver . webelement . WebElement ` \"\"\" if len ( positions ) == 1 : action = TouchAction ( self ) x = positions [ 0 ][ 0 ] y = positions [ 0 ][ 1 ] if duration : action . long_press ( x = x , y = y , duration = duration ) . release () else : action . tap ( x = x , y = y ) action . perform () else : ma = MultiAction ( self ) for position in positions : x = position [ 0 ] y = position [ 1 ] action = TouchAction ( self ) if duration : action . long_press ( x = x , y = y , duration = duration ) . release () else : action . press ( x = x , y = y ) . release () ma . add ( action ) ma . perform () return self","title":"tap"},{"location":"reference/appium/webdriver/extensions/applications/","text":"Module appium.webdriver.extensions.applications View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class Applications ( webdriver . Remote ): def background_app ( self , seconds ): \"\"\"Puts the application in the background on the device for a certain duration. Args: seconds (int): the duration for the application to remain in the background Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'seconds' : seconds , } self . execute ( Command . BACKGROUND , data ) return self def is_app_installed ( self , bundle_id ): \"\"\"Checks whether the application specified by `bundle_id` is installed on the device. Args: bundle_id (str): the id of the application to query Returns: bool: `True` if app is installed \"\"\" data = { 'bundleId' : bundle_id , } return self . execute ( Command . IS_APP_INSTALLED , data )[ 'value' ] def install_app ( self , app_path , ** options ): \"\"\"Install the application found at `app_path` on the device. Args: app_path (str): the local or remote path to the application to install Keyword Args: replace (bool): [Android only] whether to reinstall/upgrade the package if it is already present on the device under test. True by default timeout (int): [Android only] how much time to wait for the installation to complete. 60000ms by default. allowTestPackages (bool): [Android only] whether to allow installation of packages marked as test in the manifest. False by default useSdcard (bool): [Android only] whether to use the SD card to install the app. False by default grantPermissions (bool): [Android only] whether to automatically grant application permissions on Android 6+ after the installation completes. False by default Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'appPath' : app_path , } if options : data . update ({ 'options' : options }) self . execute ( Command . INSTALL_APP , data ) return self def remove_app ( self , app_id , ** options ): \"\"\"Remove the specified application from the device. Args: app_id (str): the application id to be removed Keyword Args: keepData (bool): [Android only] whether to keep application data and caches after it is uninstalled. False by default timeout (int): [Android only] how much time to wait for the uninstall to complete. 20000ms by default. Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'appId' : app_id , } if options : data . update ({ 'options' : options }) self . execute ( Command . REMOVE_APP , data ) return self def launch_app ( self ): \"\"\"Start on the device the application specified in the desired capabilities. Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . LAUNCH_APP ) return self def close_app ( self ): \"\"\"Stop the running application, specified in the desired capabilities, on the device. Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . CLOSE_APP ) return self def terminate_app ( self , app_id , ** options ): \"\"\"Terminates the application if it is running. Args: app_id (str): the application id to be terminates Keyword Args: `timeout` (int): [Android only] how much time to wait for the uninstall to complete. 500ms by default. Returns: bool: True if the app has been successfully terminated \"\"\" data = { 'appId' : app_id , } if options : data . update ({ 'options' : options }) return self . execute ( Command . TERMINATE_APP , data )[ 'value' ] def activate_app ( self , app_id ): \"\"\"Activates the application if it is not running or is running in the background. Args: app_id (str): the application id to be activated Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'appId' : app_id , } self . execute ( Command . ACTIVATE_APP , data ) return self def query_app_state ( self , app_id ): \"\"\"Queries the state of the application. Args: app_id (str): the application id to be queried Returns: One of possible application state constants. See ApplicationState class for more details. \"\"\" data = { 'appId' : app_id , } return self . execute ( Command . QUERY_APP_STATE , data )[ 'value' ] def app_strings ( self , language = None , string_file = None ): \"\"\"Returns the application strings from the device for the specified language. Args: language (str): strings language code string_file (str): the name of the string file to query \"\"\" data = {} if language is not None : data [ 'language' ] = language if string_file is not None : data [ 'stringFile' ] = string_file return self . execute ( Command . GET_APP_STRINGS , data )[ 'value' ] def reset ( self ): \"\"\"Resets the current application on the device. \"\"\" self . execute ( Command . RESET ) return self # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . BACKGROUND ] = \\ ( 'POST' , '/session/$sessionId/appium/app/background' ) self . command_executor . _commands [ Command . IS_APP_INSTALLED ] = \\ ( 'POST' , '/session/$sessionId/appium/device/app_installed' ) self . command_executor . _commands [ Command . INSTALL_APP ] = \\ ( 'POST' , '/session/$sessionId/appium/device/install_app' ) self . command_executor . _commands [ Command . REMOVE_APP ] = \\ ( 'POST' , '/session/$sessionId/appium/device/remove_app' ) self . command_executor . _commands [ Command . TERMINATE_APP ] = \\ ( 'POST' , '/session/$sessionId/appium/device/terminate_app' ) self . command_executor . _commands [ Command . ACTIVATE_APP ] = \\ ( 'POST' , '/session/$sessionId/appium/device/activate_app' ) self . command_executor . _commands [ Command . QUERY_APP_STATE ] = \\ ( 'POST' , '/session/$sessionId/appium/device/app_state' ) self . command_executor . _commands [ Command . GET_APP_STRINGS ] = \\ ( 'POST' , '/session/$sessionId/appium/app/strings' ) self . command_executor . _commands [ Command . RESET ] = \\ ( 'POST' , '/session/$sessionId/appium/app/reset' ) Classes Applications class Applications ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Applications ( webdriver . Remote ) : def background_app ( self , seconds ) : \"\"\"Puts the application in the background on the device for a certain duration. Args : seconds ( int ) : the duration for the application to remain in the background Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' seconds ' : seconds , } self . execute ( Command . BACKGROUND , data ) return self def is_app_installed ( self , bundle_id ) : \"\"\"Checks whether the application specified by `bundle_id` is installed on the device. Args : bundle_id ( str ) : the id of the application to query Returns : bool : ` True ` if app is installed \"\"\" data = { ' bundleId ' : bundle_id , } return self . execute ( Command . IS_APP_INSTALLED , data )[ ' value ' ] def install_app ( self , app_path , ** options ) : \"\"\"Install the application found at `app_path` on the device. Args : app_path ( str ) : the local or remote path to the application to install Keyword Args : replace ( bool ) : [ Android only ] whether to reinstall / upgrade the package if it is already present on the device under test . True by default timeout ( int ) : [ Android only ] how much time to wait for the installation to complete . 60000 ms by default . allowTestPackages ( bool ) : [ Android only ] whether to allow installation of packages marked as test in the manifest . False by default useSdcard ( bool ) : [ Android only ] whether to use the SD card to install the app . False by default grantPermissions ( bool ) : [ Android only ] whether to automatically grant application permissions on Android 6 + after the installation completes . False by default Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' appPath ' : app_path , } if options : data . update ({ ' options ' : options }) self . execute ( Command . INSTALL_APP , data ) return self def remove_app ( self , app_id , ** options ) : \"\"\"Remove the specified application from the device. Args : app_id ( str ) : the application id to be removed Keyword Args : keepData ( bool ) : [ Android only ] whether to keep application data and caches after it is uninstalled . False by default timeout ( int ) : [ Android only ] how much time to wait for the uninstall to complete . 20000 ms by default . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' appId ' : app_id , } if options : data . update ({ ' options ' : options }) self . execute ( Command . REMOVE_APP , data ) return self def launch_app ( self ) : \"\"\"Start on the device the application specified in the desired capabilities. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . LAUNCH_APP ) return self def close_app ( self ) : \"\"\"Stop the running application, specified in the desired capabilities, on the device . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . CLOSE_APP ) return self def terminate_app ( self , app_id , ** options ) : \"\"\"Terminates the application if it is running. Args : app_id ( str ) : the application id to be terminates Keyword Args : ` timeout ` ( int ) : [ Android only ] how much time to wait for the uninstall to complete . 500 ms by default . Returns : bool : True if the app has been successfully terminated \"\"\" data = { ' appId ' : app_id , } if options : data . update ({ ' options ' : options }) return self . execute ( Command . TERMINATE_APP , data )[ ' value ' ] def activate_app ( self , app_id ) : \"\"\"Activates the application if it is not running or is running in the background . Args : app_id ( str ) : the application id to be activated Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' appId ' : app_id , } self . execute ( Command . ACTIVATE_APP , data ) return self def query_app_state ( self , app_id ) : \"\"\"Queries the state of the application. Args : app_id ( str ) : the application id to be queried Returns : One of possible application state constants . See ApplicationState class for more details . \"\"\" data = { ' appId ' : app_id , } return self . execute ( Command . QUERY_APP_STATE , data )[ ' value ' ] def app_strings ( self , language = None , string_file = None ) : \"\"\"Returns the application strings from the device for the specified language . Args : language ( str ) : strings language code string_file ( str ) : the name of the string file to query \"\"\" data = {} if language is not None : data [ ' language ' ] = language if string_file is not None : data [ ' stringFile ' ] = string_file return self . execute ( Command . GET_APP_STRINGS , data )[ ' value ' ] def reset ( self ) : \"\"\"Resets the current application on the device. \"\"\" self . execute ( Command . RESET ) return self # pylint: disable=protected-access def _addCommands ( self ) : self . command_executor . _commands [ Command . BACKGROUND ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / app / background ' ) self . command_executor . _commands [ Command . IS_APP_INSTALLED ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / device / app_installed ' ) self . command_executor . _commands [ Command . INSTALL_APP ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / device / install_app ' ) self . command_executor . _commands [ Command . REMOVE_APP ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / device / remove_app ' ) self . command_executor . _commands [ Command . TERMINATE_APP ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / device / terminate_app ' ) self . command_executor . _commands [ Command . ACTIVATE_APP ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / device / activate_app ' ) self . command_executor . _commands [ Command . QUERY_APP_STATE ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / device / app_state ' ) self . command_executor . _commands [ Command . GET_APP_STRINGS ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / app / strings ' ) self . command_executor . _commands [ Command . RESET ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / app / reset ' ) Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods activate_app def activate_app ( self , app_id ) Activates the application if it is not running or is running in the background. Args: app_id (str): the application id to be activated Returns: appium.webdriver.webdriver.WebDriver View Source def activate_app ( self , app_id ) : \"\"\" Activates the application if it is not running or is running in the background . Args : app_id ( str ) : the application id to be activated Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' appId ' : app_id , } self . execute ( Command . ACTIVATE_APP , data ) return self add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) app_strings def app_strings ( self , language = None , string_file = None ) Returns the application strings from the device for the specified language. Args: language (str): strings language code string_file (str): the name of the string file to query View Source def app_strings ( self , language = None , string_file = None ) : \"\"\" Returns the application strings from the device for the specified language . Args : language ( str ) : strings language code string_file ( str ) : the name of the string file to query \"\"\" data = {} if language is not None : data [ ' language ' ] = language if string_file is not None : data [ ' stringFile ' ] = string_file return self . execute ( Command . GET_APP_STRINGS , data ) [ ' value ' ] back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) background_app def background_app ( self , seconds ) Puts the application in the background on the device for a certain duration. Args: seconds (int): the duration for the application to remain in the background Returns: appium.webdriver.webdriver.WebDriver View Source def background_app ( self , seconds ) : \"\"\" Puts the application in the background on the device for a certain duration. Args : seconds ( int ) : the duration for the application to remain in the background Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' seconds ' : seconds , } self . execute ( Command . BACKGROUND , data ) return self close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) close_app def close_app ( self ) Stop the running application, specified in the desired capabilities, on the device. Returns: appium.webdriver.webdriver.WebDriver View Source def close_app ( self ) : \"\"\" Stop the running application, specified in the desired capabilities, on the device . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . CLOSE_APP ) return self create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) install_app def install_app ( self , app_path , ** options ) Install the application found at app_path on the device. Args: app_path (str): the local or remote path to the application to install Keyword Args: replace (bool): [Android only] whether to reinstall/upgrade the package if it is already present on the device under test. True by default timeout (int): [Android only] how much time to wait for the installation to complete. 60000ms by default. allowTestPackages (bool): [Android only] whether to allow installation of packages marked as test in the manifest. False by default useSdcard (bool): [Android only] whether to use the SD card to install the app. False by default grantPermissions (bool): [Android only] whether to automatically grant application permissions on Android 6+ after the installation completes. False by default Returns: appium.webdriver.webdriver.WebDriver View Source def install_app ( self , app_path , ** options ) : \"\"\"Install the application found at `app_path` on the device. Args : app_path ( str ) : the local or remote path to the application to install Keyword Args : replace ( bool ) : [ Android only ] whether to reinstall / upgrade the package if it is already present on the device under test . True by default timeout ( int ) : [ Android only ] how much time to wait for the installation to complete . 60000 ms by default . allowTestPackages ( bool ) : [ Android only ] whether to allow installation of packages marked as test in the manifest . False by default useSdcard ( bool ) : [ Android only ] whether to use the SD card to install the app . False by default grantPermissions ( bool ) : [ Android only ] whether to automatically grant application permissions on Android 6 + after the installation completes . False by default Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' appPath ' : app_path , } if options : data . update ({ ' options ' : options }) self . execute ( Command . INSTALL_APP , data ) return self is_app_installed def is_app_installed ( self , bundle_id ) Checks whether the application specified by bundle_id is installed on the device. Args: bundle_id (str): the id of the application to query Returns: bool: True if app is installed View Source def is_app_installed ( self , bundle_id ) : \"\"\" Checks whether the application specified by `bundle_id` is installed on the device. Args : bundle_id ( str ) : the id of the application to query Returns : bool : ` True ` if app is installed \"\"\" data = { ' bundleId ' : bundle_id , } return self . execute ( Command . IS_APP_INSTALLED , data ) [ ' value ' ] launch_app def launch_app ( self ) Start on the device the application specified in the desired capabilities. Returns: appium.webdriver.webdriver.WebDriver View Source def launch_app ( self ) : \"\"\" Start on the device the application specified in the desired capabilities. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . LAUNCH_APP ) return self maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) query_app_state def query_app_state ( self , app_id ) Queries the state of the application. Args: app_id (str): the application id to be queried Returns: One of possible application state constants. See ApplicationState class for more details. View Source def query_app_state ( self , app_id ) : \"\"\" Queries the state of the application. Args : app_id ( str ) : the application id to be queried Returns : One of possible application state constants . See ApplicationState class for more details . \"\"\" data = { ' appId ' : app_id , } return self . execute ( Command . QUERY_APP_STATE , data ) [ ' value ' ] quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) remove_app def remove_app ( self , app_id , ** options ) Remove the specified application from the device. Args: app_id (str): the application id to be removed Keyword Args: keepData (bool): [Android only] whether to keep application data and caches after it is uninstalled. False by default timeout (int): [Android only] how much time to wait for the uninstall to complete. 20000ms by default. Returns: appium.webdriver.webdriver.WebDriver View Source def remove_app ( self , app_id , ** options ) : \"\"\"Remove the specified application from the device. Args : app_id ( str ) : the application id to be removed Keyword Args : keepData ( bool ) : [ Android only ] whether to keep application data and caches after it is uninstalled . False by default timeout ( int ) : [ Android only ] how much time to wait for the uninstall to complete . 20000 ms by default . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' appId ' : app_id , } if options : data . update ({ ' options ' : options }) self . execute ( Command . REMOVE_APP , data ) return self reset def reset ( self ) Resets the current application on the device. View Source def reset ( self ) : \"\"\" Resets the current application on the device. \"\"\" self . execute ( Command . RESET ) return self save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name ) terminate_app def terminate_app ( self , app_id , ** options ) Terminates the application if it is running. Args: app_id (str): the application id to be terminates Keyword Args: timeout (int): [Android only] how much time to wait for the uninstall to complete. 500ms by default. Returns: bool: True if the app has been successfully terminated View Source def terminate_app ( self , app_id , ** options ) : \"\"\"Terminates the application if it is running. Args : app_id ( str ) : the application id to be terminates Keyword Args : ` timeout ` ( int ) : [ Android only ] how much time to wait for the uninstall to complete . 500 ms by default . Returns : bool : True if the app has been successfully terminated \"\"\" data = { ' appId ' : app_id , } if options : data . update ({ ' options ' : options }) return self . execute ( Command . TERMINATE_APP , data )[ ' value ' ]","title":"Applications"},{"location":"reference/appium/webdriver/extensions/applications/#module-appiumwebdriverextensionsapplications","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class Applications ( webdriver . Remote ): def background_app ( self , seconds ): \"\"\"Puts the application in the background on the device for a certain duration. Args: seconds (int): the duration for the application to remain in the background Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'seconds' : seconds , } self . execute ( Command . BACKGROUND , data ) return self def is_app_installed ( self , bundle_id ): \"\"\"Checks whether the application specified by `bundle_id` is installed on the device. Args: bundle_id (str): the id of the application to query Returns: bool: `True` if app is installed \"\"\" data = { 'bundleId' : bundle_id , } return self . execute ( Command . IS_APP_INSTALLED , data )[ 'value' ] def install_app ( self , app_path , ** options ): \"\"\"Install the application found at `app_path` on the device. Args: app_path (str): the local or remote path to the application to install Keyword Args: replace (bool): [Android only] whether to reinstall/upgrade the package if it is already present on the device under test. True by default timeout (int): [Android only] how much time to wait for the installation to complete. 60000ms by default. allowTestPackages (bool): [Android only] whether to allow installation of packages marked as test in the manifest. False by default useSdcard (bool): [Android only] whether to use the SD card to install the app. False by default grantPermissions (bool): [Android only] whether to automatically grant application permissions on Android 6+ after the installation completes. False by default Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'appPath' : app_path , } if options : data . update ({ 'options' : options }) self . execute ( Command . INSTALL_APP , data ) return self def remove_app ( self , app_id , ** options ): \"\"\"Remove the specified application from the device. Args: app_id (str): the application id to be removed Keyword Args: keepData (bool): [Android only] whether to keep application data and caches after it is uninstalled. False by default timeout (int): [Android only] how much time to wait for the uninstall to complete. 20000ms by default. Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'appId' : app_id , } if options : data . update ({ 'options' : options }) self . execute ( Command . REMOVE_APP , data ) return self def launch_app ( self ): \"\"\"Start on the device the application specified in the desired capabilities. Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . LAUNCH_APP ) return self def close_app ( self ): \"\"\"Stop the running application, specified in the desired capabilities, on the device. Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . CLOSE_APP ) return self def terminate_app ( self , app_id , ** options ): \"\"\"Terminates the application if it is running. Args: app_id (str): the application id to be terminates Keyword Args: `timeout` (int): [Android only] how much time to wait for the uninstall to complete. 500ms by default. Returns: bool: True if the app has been successfully terminated \"\"\" data = { 'appId' : app_id , } if options : data . update ({ 'options' : options }) return self . execute ( Command . TERMINATE_APP , data )[ 'value' ] def activate_app ( self , app_id ): \"\"\"Activates the application if it is not running or is running in the background. Args: app_id (str): the application id to be activated Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'appId' : app_id , } self . execute ( Command . ACTIVATE_APP , data ) return self def query_app_state ( self , app_id ): \"\"\"Queries the state of the application. Args: app_id (str): the application id to be queried Returns: One of possible application state constants. See ApplicationState class for more details. \"\"\" data = { 'appId' : app_id , } return self . execute ( Command . QUERY_APP_STATE , data )[ 'value' ] def app_strings ( self , language = None , string_file = None ): \"\"\"Returns the application strings from the device for the specified language. Args: language (str): strings language code string_file (str): the name of the string file to query \"\"\" data = {} if language is not None : data [ 'language' ] = language if string_file is not None : data [ 'stringFile' ] = string_file return self . execute ( Command . GET_APP_STRINGS , data )[ 'value' ] def reset ( self ): \"\"\"Resets the current application on the device. \"\"\" self . execute ( Command . RESET ) return self # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . BACKGROUND ] = \\ ( 'POST' , '/session/$sessionId/appium/app/background' ) self . command_executor . _commands [ Command . IS_APP_INSTALLED ] = \\ ( 'POST' , '/session/$sessionId/appium/device/app_installed' ) self . command_executor . _commands [ Command . INSTALL_APP ] = \\ ( 'POST' , '/session/$sessionId/appium/device/install_app' ) self . command_executor . _commands [ Command . REMOVE_APP ] = \\ ( 'POST' , '/session/$sessionId/appium/device/remove_app' ) self . command_executor . _commands [ Command . TERMINATE_APP ] = \\ ( 'POST' , '/session/$sessionId/appium/device/terminate_app' ) self . command_executor . _commands [ Command . ACTIVATE_APP ] = \\ ( 'POST' , '/session/$sessionId/appium/device/activate_app' ) self . command_executor . _commands [ Command . QUERY_APP_STATE ] = \\ ( 'POST' , '/session/$sessionId/appium/device/app_state' ) self . command_executor . _commands [ Command . GET_APP_STRINGS ] = \\ ( 'POST' , '/session/$sessionId/appium/app/strings' ) self . command_executor . _commands [ Command . RESET ] = \\ ( 'POST' , '/session/$sessionId/appium/app/reset' )","title":"Module appium.webdriver.extensions.applications"},{"location":"reference/appium/webdriver/extensions/applications/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/applications/#applications","text":"class Applications ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Applications ( webdriver . Remote ) : def background_app ( self , seconds ) : \"\"\"Puts the application in the background on the device for a certain duration. Args : seconds ( int ) : the duration for the application to remain in the background Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' seconds ' : seconds , } self . execute ( Command . BACKGROUND , data ) return self def is_app_installed ( self , bundle_id ) : \"\"\"Checks whether the application specified by `bundle_id` is installed on the device. Args : bundle_id ( str ) : the id of the application to query Returns : bool : ` True ` if app is installed \"\"\" data = { ' bundleId ' : bundle_id , } return self . execute ( Command . IS_APP_INSTALLED , data )[ ' value ' ] def install_app ( self , app_path , ** options ) : \"\"\"Install the application found at `app_path` on the device. Args : app_path ( str ) : the local or remote path to the application to install Keyword Args : replace ( bool ) : [ Android only ] whether to reinstall / upgrade the package if it is already present on the device under test . True by default timeout ( int ) : [ Android only ] how much time to wait for the installation to complete . 60000 ms by default . allowTestPackages ( bool ) : [ Android only ] whether to allow installation of packages marked as test in the manifest . False by default useSdcard ( bool ) : [ Android only ] whether to use the SD card to install the app . False by default grantPermissions ( bool ) : [ Android only ] whether to automatically grant application permissions on Android 6 + after the installation completes . False by default Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' appPath ' : app_path , } if options : data . update ({ ' options ' : options }) self . execute ( Command . INSTALL_APP , data ) return self def remove_app ( self , app_id , ** options ) : \"\"\"Remove the specified application from the device. Args : app_id ( str ) : the application id to be removed Keyword Args : keepData ( bool ) : [ Android only ] whether to keep application data and caches after it is uninstalled . False by default timeout ( int ) : [ Android only ] how much time to wait for the uninstall to complete . 20000 ms by default . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' appId ' : app_id , } if options : data . update ({ ' options ' : options }) self . execute ( Command . REMOVE_APP , data ) return self def launch_app ( self ) : \"\"\"Start on the device the application specified in the desired capabilities. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . LAUNCH_APP ) return self def close_app ( self ) : \"\"\"Stop the running application, specified in the desired capabilities, on the device . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . CLOSE_APP ) return self def terminate_app ( self , app_id , ** options ) : \"\"\"Terminates the application if it is running. Args : app_id ( str ) : the application id to be terminates Keyword Args : ` timeout ` ( int ) : [ Android only ] how much time to wait for the uninstall to complete . 500 ms by default . Returns : bool : True if the app has been successfully terminated \"\"\" data = { ' appId ' : app_id , } if options : data . update ({ ' options ' : options }) return self . execute ( Command . TERMINATE_APP , data )[ ' value ' ] def activate_app ( self , app_id ) : \"\"\"Activates the application if it is not running or is running in the background . Args : app_id ( str ) : the application id to be activated Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' appId ' : app_id , } self . execute ( Command . ACTIVATE_APP , data ) return self def query_app_state ( self , app_id ) : \"\"\"Queries the state of the application. Args : app_id ( str ) : the application id to be queried Returns : One of possible application state constants . See ApplicationState class for more details . \"\"\" data = { ' appId ' : app_id , } return self . execute ( Command . QUERY_APP_STATE , data )[ ' value ' ] def app_strings ( self , language = None , string_file = None ) : \"\"\"Returns the application strings from the device for the specified language . Args : language ( str ) : strings language code string_file ( str ) : the name of the string file to query \"\"\" data = {} if language is not None : data [ ' language ' ] = language if string_file is not None : data [ ' stringFile ' ] = string_file return self . execute ( Command . GET_APP_STRINGS , data )[ ' value ' ] def reset ( self ) : \"\"\"Resets the current application on the device. \"\"\" self . execute ( Command . RESET ) return self # pylint: disable=protected-access def _addCommands ( self ) : self . command_executor . _commands [ Command . BACKGROUND ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / app / background ' ) self . command_executor . _commands [ Command . IS_APP_INSTALLED ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / device / app_installed ' ) self . command_executor . _commands [ Command . INSTALL_APP ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / device / install_app ' ) self . command_executor . _commands [ Command . REMOVE_APP ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / device / remove_app ' ) self . command_executor . _commands [ Command . TERMINATE_APP ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / device / terminate_app ' ) self . command_executor . _commands [ Command . ACTIVATE_APP ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / device / activate_app ' ) self . command_executor . _commands [ Command . QUERY_APP_STATE ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / device / app_state ' ) self . command_executor . _commands [ Command . GET_APP_STRINGS ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / app / strings ' ) self . command_executor . _commands [ Command . RESET ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / app / reset ' )","title":"Applications"},{"location":"reference/appium/webdriver/extensions/applications/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/applications/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/applications/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/applications/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/applications/#activate_app","text":"def activate_app ( self , app_id ) Activates the application if it is not running or is running in the background. Args: app_id (str): the application id to be activated Returns: appium.webdriver.webdriver.WebDriver View Source def activate_app ( self , app_id ) : \"\"\" Activates the application if it is not running or is running in the background . Args : app_id ( str ) : the application id to be activated Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' appId ' : app_id , } self . execute ( Command . ACTIVATE_APP , data ) return self","title":"activate_app"},{"location":"reference/appium/webdriver/extensions/applications/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/applications/#app_strings","text":"def app_strings ( self , language = None , string_file = None ) Returns the application strings from the device for the specified language. Args: language (str): strings language code string_file (str): the name of the string file to query View Source def app_strings ( self , language = None , string_file = None ) : \"\"\" Returns the application strings from the device for the specified language . Args : language ( str ) : strings language code string_file ( str ) : the name of the string file to query \"\"\" data = {} if language is not None : data [ ' language ' ] = language if string_file is not None : data [ ' stringFile ' ] = string_file return self . execute ( Command . GET_APP_STRINGS , data ) [ ' value ' ]","title":"app_strings"},{"location":"reference/appium/webdriver/extensions/applications/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/applications/#background_app","text":"def background_app ( self , seconds ) Puts the application in the background on the device for a certain duration. Args: seconds (int): the duration for the application to remain in the background Returns: appium.webdriver.webdriver.WebDriver View Source def background_app ( self , seconds ) : \"\"\" Puts the application in the background on the device for a certain duration. Args : seconds ( int ) : the duration for the application to remain in the background Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' seconds ' : seconds , } self . execute ( Command . BACKGROUND , data ) return self","title":"background_app"},{"location":"reference/appium/webdriver/extensions/applications/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/applications/#close_app","text":"def close_app ( self ) Stop the running application, specified in the desired capabilities, on the device. Returns: appium.webdriver.webdriver.WebDriver View Source def close_app ( self ) : \"\"\" Stop the running application, specified in the desired capabilities, on the device . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . CLOSE_APP ) return self","title":"close_app"},{"location":"reference/appium/webdriver/extensions/applications/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/applications/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/applications/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/applications/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/applications/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/applications/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/applications/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/applications/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/applications/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/applications/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/applications/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/applications/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/applications/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/applications/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/applications/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/applications/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/applications/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/applications/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/applications/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/applications/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/applications/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/applications/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/applications/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/applications/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/applications/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/applications/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/applications/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/applications/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/applications/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/applications/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/applications/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/applications/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/applications/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/applications/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/applications/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/applications/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/applications/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/applications/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/applications/#install_app","text":"def install_app ( self , app_path , ** options ) Install the application found at app_path on the device. Args: app_path (str): the local or remote path to the application to install Keyword Args: replace (bool): [Android only] whether to reinstall/upgrade the package if it is already present on the device under test. True by default timeout (int): [Android only] how much time to wait for the installation to complete. 60000ms by default. allowTestPackages (bool): [Android only] whether to allow installation of packages marked as test in the manifest. False by default useSdcard (bool): [Android only] whether to use the SD card to install the app. False by default grantPermissions (bool): [Android only] whether to automatically grant application permissions on Android 6+ after the installation completes. False by default Returns: appium.webdriver.webdriver.WebDriver View Source def install_app ( self , app_path , ** options ) : \"\"\"Install the application found at `app_path` on the device. Args : app_path ( str ) : the local or remote path to the application to install Keyword Args : replace ( bool ) : [ Android only ] whether to reinstall / upgrade the package if it is already present on the device under test . True by default timeout ( int ) : [ Android only ] how much time to wait for the installation to complete . 60000 ms by default . allowTestPackages ( bool ) : [ Android only ] whether to allow installation of packages marked as test in the manifest . False by default useSdcard ( bool ) : [ Android only ] whether to use the SD card to install the app . False by default grantPermissions ( bool ) : [ Android only ] whether to automatically grant application permissions on Android 6 + after the installation completes . False by default Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' appPath ' : app_path , } if options : data . update ({ ' options ' : options }) self . execute ( Command . INSTALL_APP , data ) return self","title":"install_app"},{"location":"reference/appium/webdriver/extensions/applications/#is_app_installed","text":"def is_app_installed ( self , bundle_id ) Checks whether the application specified by bundle_id is installed on the device. Args: bundle_id (str): the id of the application to query Returns: bool: True if app is installed View Source def is_app_installed ( self , bundle_id ) : \"\"\" Checks whether the application specified by `bundle_id` is installed on the device. Args : bundle_id ( str ) : the id of the application to query Returns : bool : ` True ` if app is installed \"\"\" data = { ' bundleId ' : bundle_id , } return self . execute ( Command . IS_APP_INSTALLED , data ) [ ' value ' ]","title":"is_app_installed"},{"location":"reference/appium/webdriver/extensions/applications/#launch_app","text":"def launch_app ( self ) Start on the device the application specified in the desired capabilities. Returns: appium.webdriver.webdriver.WebDriver View Source def launch_app ( self ) : \"\"\" Start on the device the application specified in the desired capabilities. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . LAUNCH_APP ) return self","title":"launch_app"},{"location":"reference/appium/webdriver/extensions/applications/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/applications/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/applications/#query_app_state","text":"def query_app_state ( self , app_id ) Queries the state of the application. Args: app_id (str): the application id to be queried Returns: One of possible application state constants. See ApplicationState class for more details. View Source def query_app_state ( self , app_id ) : \"\"\" Queries the state of the application. Args : app_id ( str ) : the application id to be queried Returns : One of possible application state constants . See ApplicationState class for more details . \"\"\" data = { ' appId ' : app_id , } return self . execute ( Command . QUERY_APP_STATE , data ) [ ' value ' ]","title":"query_app_state"},{"location":"reference/appium/webdriver/extensions/applications/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/applications/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/applications/#remove_app","text":"def remove_app ( self , app_id , ** options ) Remove the specified application from the device. Args: app_id (str): the application id to be removed Keyword Args: keepData (bool): [Android only] whether to keep application data and caches after it is uninstalled. False by default timeout (int): [Android only] how much time to wait for the uninstall to complete. 20000ms by default. Returns: appium.webdriver.webdriver.WebDriver View Source def remove_app ( self , app_id , ** options ) : \"\"\"Remove the specified application from the device. Args : app_id ( str ) : the application id to be removed Keyword Args : keepData ( bool ) : [ Android only ] whether to keep application data and caches after it is uninstalled . False by default timeout ( int ) : [ Android only ] how much time to wait for the uninstall to complete . 20000 ms by default . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' appId ' : app_id , } if options : data . update ({ ' options ' : options }) self . execute ( Command . REMOVE_APP , data ) return self","title":"remove_app"},{"location":"reference/appium/webdriver/extensions/applications/#reset","text":"def reset ( self ) Resets the current application on the device. View Source def reset ( self ) : \"\"\" Resets the current application on the device. \"\"\" self . execute ( Command . RESET ) return self","title":"reset"},{"location":"reference/appium/webdriver/extensions/applications/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/applications/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/applications/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/applications/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/applications/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/applications/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/applications/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/applications/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/applications/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/applications/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/applications/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/applications/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/applications/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/applications/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/applications/#terminate_app","text":"def terminate_app ( self , app_id , ** options ) Terminates the application if it is running. Args: app_id (str): the application id to be terminates Keyword Args: timeout (int): [Android only] how much time to wait for the uninstall to complete. 500ms by default. Returns: bool: True if the app has been successfully terminated View Source def terminate_app ( self , app_id , ** options ) : \"\"\"Terminates the application if it is running. Args : app_id ( str ) : the application id to be terminates Keyword Args : ` timeout ` ( int ) : [ Android only ] how much time to wait for the uninstall to complete . 500 ms by default . Returns : bool : True if the app has been successfully terminated \"\"\" data = { ' appId ' : app_id , } if options : data . update ({ ' options ' : options }) return self . execute ( Command . TERMINATE_APP , data )[ ' value ' ]","title":"terminate_app"},{"location":"reference/appium/webdriver/extensions/clipboard/","text":"Module appium.webdriver.extensions.clipboard View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import base64 from selenium import webdriver from appium.common.helper import appium_bytes from appium.webdriver.clipboard_content_type import ClipboardContentType from ..mobilecommand import MobileCommand as Command class Clipboard ( webdriver . Remote ): def set_clipboard ( self , content , content_type = ClipboardContentType . PLAINTEXT , label = None ): \"\"\"Set the content of the system clipboard Args: content (str): The content to be set as bytearray string content_type (str): One of ClipboardContentType items. Only ClipboardContentType.PLAINTEXT is supported on Android label (:obj:`str`, optional): label argument, which only works for Android \"\"\" options = { 'content' : base64 . b64encode ( content ) . decode ( 'UTF-8' ), 'contentType' : content_type , } if label : options [ 'label' ] = label self . execute ( Command . SET_CLIPBOARD , options ) def set_clipboard_text ( self , text , label = None ): \"\"\"Copies the given text to the system clipboard Args: text (str): The text to be set label (:obj:`int`, optional):label argument, which only works for Android \"\"\" self . set_clipboard ( appium_bytes ( str ( text ), 'UTF-8' ), ClipboardContentType . PLAINTEXT , label ) def get_clipboard ( self , content_type = ClipboardContentType . PLAINTEXT ): \"\"\"Receives the content of the system clipboard Args: content_type (str): One of ClipboardContentType items. Only ClipboardContentType.PLAINTEXT is supported on Android Returns: base64-encoded string: Clipboard content. Or return an empty string if the clipboard is empty \"\"\" base64_str = self . execute ( Command . GET_CLIPBOARD , { 'contentType' : content_type })[ 'value' ] return base64 . b64decode ( base64_str ) def get_clipboard_text ( self ): \"\"\"Receives the text of the system clipboard Return: str: The actual clipboard text or an empty string if the clipboard is empty \"\"\" return self . get_clipboard ( ClipboardContentType . PLAINTEXT ) . decode ( 'UTF-8' ) # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . SET_CLIPBOARD ] = \\ ( 'POST' , '/session/$sessionId/appium/device/set_clipboard' ) self . command_executor . _commands [ Command . GET_CLIPBOARD ] = \\ ( 'POST' , '/session/$sessionId/appium/device/get_clipboard' ) Classes Clipboard class Clipboard ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Clipboard ( webdriver . Remote ) : def set_clipboard ( self , content , content_type = ClipboardContentType . PLAINTEXT , label = None ) : \"\"\" Set the content of the system clipboard Args : content ( str ) : The content to be set as bytearray string content_type ( str ) : One of ClipboardContentType items . Only ClipboardContentType . PLAINTEXT is supported on Android label ( : obj :` str `, optional ) : label argument , which only works for Android \"\"\" options = { ' content ' : base64 . b64encode ( content ) . decode ( ' UTF-8 ' ) , ' contentType ' : content_type , } if label : options [ ' label ' ] = label self . execute ( Command . SET_CLIPBOARD , options ) def set_clipboard_text ( self , text , label = None ) : \"\"\" Copies the given text to the system clipboard Args : text ( str ) : The text to be set label ( : obj :` int `, optional ) : label argument , which only works for Android \"\"\" self . set_clipboard ( appium_bytes ( str ( text ) , ' UTF-8 ' ) , ClipboardContentType . PLAINTEXT , label ) def get_clipboard ( self , content_type = ClipboardContentType . PLAINTEXT ) : \"\"\" Receives the content of the system clipboard Args : content_type ( str ) : One of ClipboardContentType items . Only ClipboardContentType . PLAINTEXT is supported on Android Returns : base64 - encoded string : Clipboard content . Or return an empty string if the clipboard is empty \"\"\" base64_str = self . execute ( Command . GET_CLIPBOARD , { ' contentType ' : content_type } ) [ ' value ' ] return base64 . b64decode ( base64_str ) def get_clipboard_text ( self ) : \"\"\" Receives the text of the system clipboard Return : str : The actual clipboard text or an empty string if the clipboard is empty \"\"\" return self . get_clipboard ( ClipboardContentType . PLAINTEXT ) . decode ( ' UTF-8 ' ) # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . SET_CLIPBOARD ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/set_clipboard ' ) self . command_executor . _commands [ Command . GET_CLIPBOARD ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/get_clipboard ' ) Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_clipboard def get_clipboard ( self , content_type = 'plaintext' ) Receives the content of the system clipboard Args: content_type (str): One of ClipboardContentType items. Only ClipboardContentType.PLAINTEXT is supported on Android Returns: base64-encoded string: Clipboard content. Or return an empty string if the clipboard is empty View Source def get_clipboard ( self , content_type = ClipboardContentType . PLAINTEXT ) : \"\"\" Receives the content of the system clipboard Args : content_type ( str ) : One of ClipboardContentType items . Only ClipboardContentType . PLAINTEXT is supported on Android Returns : base64 - encoded string : Clipboard content . Or return an empty string if the clipboard is empty \"\"\" base64_str = self . execute ( Command . GET_CLIPBOARD , { ' contentType ' : content_type } ) [ ' value ' ] return base64 . b64decode ( base64_str ) get_clipboard_text def get_clipboard_text ( self ) Receives the text of the system clipboard Return: str: The actual clipboard text or an empty string if the clipboard is empty View Source def get_clipboard_text ( self ) : \"\"\" Receives the text of the system clipboard Return : str : The actual clipboard text or an empty string if the clipboard is empty \"\"\" return self . get_clipboard ( ClipboardContentType . PLAINTEXT ) . decode ( ' UTF-8 ' ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) set_clipboard def set_clipboard ( self , content , content_type = 'plaintext' , label = None ) Set the content of the system clipboard Args: content (str): The content to be set as bytearray string content_type (str): One of ClipboardContentType items. Only ClipboardContentType.PLAINTEXT is supported on Android label (:obj: str , optional): label argument, which only works for Android View Source def set_clipboard ( self , content , content_type = ClipboardContentType . PLAINTEXT , label = None ) : \"\"\" Set the content of the system clipboard Args : content ( str ) : The content to be set as bytearray string content_type ( str ) : One of ClipboardContentType items . Only ClipboardContentType . PLAINTEXT is supported on Android label ( : obj :` str `, optional ) : label argument , which only works for Android \"\"\" options = { ' content ' : base64 . b64encode ( content ) . decode ( ' UTF-8 ' ) , ' contentType ' : content_type , } if label : options [ ' label ' ] = label self . execute ( Command . SET_CLIPBOARD , options ) set_clipboard_text def set_clipboard_text ( self , text , label = None ) Copies the given text to the system clipboard Args: text (str): The text to be set label (:obj: int , optional):label argument, which only works for Android View Source def set_clipboard_text ( self , text , label = None ) : \"\"\" Copies the given text to the system clipboard Args : text ( str ) : The text to be set label ( : obj :` int `, optional ) : label argument , which only works for Android \"\"\" self . set_clipboard ( appium_bytes ( str ( text ) , ' UTF-8 ' ) , ClipboardContentType . PLAINTEXT , label ) set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"Clipboard"},{"location":"reference/appium/webdriver/extensions/clipboard/#module-appiumwebdriverextensionsclipboard","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import base64 from selenium import webdriver from appium.common.helper import appium_bytes from appium.webdriver.clipboard_content_type import ClipboardContentType from ..mobilecommand import MobileCommand as Command class Clipboard ( webdriver . Remote ): def set_clipboard ( self , content , content_type = ClipboardContentType . PLAINTEXT , label = None ): \"\"\"Set the content of the system clipboard Args: content (str): The content to be set as bytearray string content_type (str): One of ClipboardContentType items. Only ClipboardContentType.PLAINTEXT is supported on Android label (:obj:`str`, optional): label argument, which only works for Android \"\"\" options = { 'content' : base64 . b64encode ( content ) . decode ( 'UTF-8' ), 'contentType' : content_type , } if label : options [ 'label' ] = label self . execute ( Command . SET_CLIPBOARD , options ) def set_clipboard_text ( self , text , label = None ): \"\"\"Copies the given text to the system clipboard Args: text (str): The text to be set label (:obj:`int`, optional):label argument, which only works for Android \"\"\" self . set_clipboard ( appium_bytes ( str ( text ), 'UTF-8' ), ClipboardContentType . PLAINTEXT , label ) def get_clipboard ( self , content_type = ClipboardContentType . PLAINTEXT ): \"\"\"Receives the content of the system clipboard Args: content_type (str): One of ClipboardContentType items. Only ClipboardContentType.PLAINTEXT is supported on Android Returns: base64-encoded string: Clipboard content. Or return an empty string if the clipboard is empty \"\"\" base64_str = self . execute ( Command . GET_CLIPBOARD , { 'contentType' : content_type })[ 'value' ] return base64 . b64decode ( base64_str ) def get_clipboard_text ( self ): \"\"\"Receives the text of the system clipboard Return: str: The actual clipboard text or an empty string if the clipboard is empty \"\"\" return self . get_clipboard ( ClipboardContentType . PLAINTEXT ) . decode ( 'UTF-8' ) # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . SET_CLIPBOARD ] = \\ ( 'POST' , '/session/$sessionId/appium/device/set_clipboard' ) self . command_executor . _commands [ Command . GET_CLIPBOARD ] = \\ ( 'POST' , '/session/$sessionId/appium/device/get_clipboard' )","title":"Module appium.webdriver.extensions.clipboard"},{"location":"reference/appium/webdriver/extensions/clipboard/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/clipboard/#clipboard","text":"class Clipboard ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Clipboard ( webdriver . Remote ) : def set_clipboard ( self , content , content_type = ClipboardContentType . PLAINTEXT , label = None ) : \"\"\" Set the content of the system clipboard Args : content ( str ) : The content to be set as bytearray string content_type ( str ) : One of ClipboardContentType items . Only ClipboardContentType . PLAINTEXT is supported on Android label ( : obj :` str `, optional ) : label argument , which only works for Android \"\"\" options = { ' content ' : base64 . b64encode ( content ) . decode ( ' UTF-8 ' ) , ' contentType ' : content_type , } if label : options [ ' label ' ] = label self . execute ( Command . SET_CLIPBOARD , options ) def set_clipboard_text ( self , text , label = None ) : \"\"\" Copies the given text to the system clipboard Args : text ( str ) : The text to be set label ( : obj :` int `, optional ) : label argument , which only works for Android \"\"\" self . set_clipboard ( appium_bytes ( str ( text ) , ' UTF-8 ' ) , ClipboardContentType . PLAINTEXT , label ) def get_clipboard ( self , content_type = ClipboardContentType . PLAINTEXT ) : \"\"\" Receives the content of the system clipboard Args : content_type ( str ) : One of ClipboardContentType items . Only ClipboardContentType . PLAINTEXT is supported on Android Returns : base64 - encoded string : Clipboard content . Or return an empty string if the clipboard is empty \"\"\" base64_str = self . execute ( Command . GET_CLIPBOARD , { ' contentType ' : content_type } ) [ ' value ' ] return base64 . b64decode ( base64_str ) def get_clipboard_text ( self ) : \"\"\" Receives the text of the system clipboard Return : str : The actual clipboard text or an empty string if the clipboard is empty \"\"\" return self . get_clipboard ( ClipboardContentType . PLAINTEXT ) . decode ( ' UTF-8 ' ) # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . SET_CLIPBOARD ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/set_clipboard ' ) self . command_executor . _commands [ Command . GET_CLIPBOARD ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/get_clipboard ' )","title":"Clipboard"},{"location":"reference/appium/webdriver/extensions/clipboard/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/clipboard/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/clipboard/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/clipboard/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/clipboard/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/clipboard/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/clipboard/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/clipboard/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/clipboard/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/clipboard/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/clipboard/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/clipboard/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/clipboard/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/clipboard/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/clipboard/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/clipboard/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/clipboard/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/clipboard/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/clipboard/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/clipboard/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/clipboard/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/clipboard/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/clipboard/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/clipboard/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/clipboard/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/clipboard/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/clipboard/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/clipboard/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/clipboard/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/clipboard/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/clipboard/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/clipboard/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/clipboard/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/clipboard/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/clipboard/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/clipboard/#get_clipboard","text":"def get_clipboard ( self , content_type = 'plaintext' ) Receives the content of the system clipboard Args: content_type (str): One of ClipboardContentType items. Only ClipboardContentType.PLAINTEXT is supported on Android Returns: base64-encoded string: Clipboard content. Or return an empty string if the clipboard is empty View Source def get_clipboard ( self , content_type = ClipboardContentType . PLAINTEXT ) : \"\"\" Receives the content of the system clipboard Args : content_type ( str ) : One of ClipboardContentType items . Only ClipboardContentType . PLAINTEXT is supported on Android Returns : base64 - encoded string : Clipboard content . Or return an empty string if the clipboard is empty \"\"\" base64_str = self . execute ( Command . GET_CLIPBOARD , { ' contentType ' : content_type } ) [ ' value ' ] return base64 . b64decode ( base64_str )","title":"get_clipboard"},{"location":"reference/appium/webdriver/extensions/clipboard/#get_clipboard_text","text":"def get_clipboard_text ( self ) Receives the text of the system clipboard Return: str: The actual clipboard text or an empty string if the clipboard is empty View Source def get_clipboard_text ( self ) : \"\"\" Receives the text of the system clipboard Return : str : The actual clipboard text or an empty string if the clipboard is empty \"\"\" return self . get_clipboard ( ClipboardContentType . PLAINTEXT ) . decode ( ' UTF-8 ' )","title":"get_clipboard_text"},{"location":"reference/appium/webdriver/extensions/clipboard/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/clipboard/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/clipboard/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/clipboard/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/clipboard/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/clipboard/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/clipboard/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/clipboard/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/clipboard/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/clipboard/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/clipboard/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/clipboard/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/clipboard/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/clipboard/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/clipboard/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/clipboard/#set_clipboard","text":"def set_clipboard ( self , content , content_type = 'plaintext' , label = None ) Set the content of the system clipboard Args: content (str): The content to be set as bytearray string content_type (str): One of ClipboardContentType items. Only ClipboardContentType.PLAINTEXT is supported on Android label (:obj: str , optional): label argument, which only works for Android View Source def set_clipboard ( self , content , content_type = ClipboardContentType . PLAINTEXT , label = None ) : \"\"\" Set the content of the system clipboard Args : content ( str ) : The content to be set as bytearray string content_type ( str ) : One of ClipboardContentType items . Only ClipboardContentType . PLAINTEXT is supported on Android label ( : obj :` str `, optional ) : label argument , which only works for Android \"\"\" options = { ' content ' : base64 . b64encode ( content ) . decode ( ' UTF-8 ' ) , ' contentType ' : content_type , } if label : options [ ' label ' ] = label self . execute ( Command . SET_CLIPBOARD , options )","title":"set_clipboard"},{"location":"reference/appium/webdriver/extensions/clipboard/#set_clipboard_text","text":"def set_clipboard_text ( self , text , label = None ) Copies the given text to the system clipboard Args: text (str): The text to be set label (:obj: int , optional):label argument, which only works for Android View Source def set_clipboard_text ( self , text , label = None ) : \"\"\" Copies the given text to the system clipboard Args : text ( str ) : The text to be set label ( : obj :` int `, optional ) : label argument , which only works for Android \"\"\" self . set_clipboard ( appium_bytes ( str ( text ) , ' UTF-8 ' ) , ClipboardContentType . PLAINTEXT , label )","title":"set_clipboard_text"},{"location":"reference/appium/webdriver/extensions/clipboard/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/clipboard/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/clipboard/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/clipboard/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/clipboard/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/clipboard/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/clipboard/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/clipboard/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/clipboard/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/clipboard/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/clipboard/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/clipboard/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/clipboard/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/context/","text":"Module appium.webdriver.extensions.context View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class Context ( webdriver . Remote ): @property def contexts ( self ): \"\"\"Returns the contexts within the current session. Usage: driver.contexts Return: :obj:`list` of :obj:`str`: The contexts within the current session \"\"\" return self . execute ( Command . CONTEXTS )[ 'value' ] @property def current_context ( self ): \"\"\"Returns the current context of the current session. Usage: driver.current_context Return: str: The context of the current session \"\"\" return self . execute ( Command . GET_CURRENT_CONTEXT )[ 'value' ] @property def context ( self ): \"\"\"Returns the current context of the current session. Usage: driver.context Return: str: The context of the current session \"\"\" return self . current_context # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . CONTEXTS ] = \\ ( 'GET' , '/session/$sessionId/contexts' ) self . command_executor . _commands [ Command . GET_CURRENT_CONTEXT ] = \\ ( 'GET' , '/session/$sessionId/context' ) self . command_executor . _commands [ Command . SWITCH_TO_CONTEXT ] = \\ ( 'POST' , '/session/$sessionId/context' ) Classes Context class Context ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Context ( webdriver . Remote ) : @ property def contexts ( self ) : \"\"\" Returns the contexts within the current session. Usage : driver . contexts Return : : obj :` list ` of : obj :` str `: The contexts within the current session \"\"\" return self . execute ( Command . CONTEXTS ) [ ' value ' ] @ property def current_context ( self ) : \"\"\" Returns the current context of the current session. Usage : driver . current_context Return : str : The context of the current session \"\"\" return self . execute ( Command . GET_CURRENT_CONTEXT ) [ ' value ' ] @ property def context ( self ) : \"\"\" Returns the current context of the current session. Usage : driver . context Return : str : The context of the current session \"\"\" return self . current_context # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . CONTEXTS ] = \\ ( ' GET ' , ' /session/$sessionId/contexts ' ) self . command_executor . _commands [ Command . GET_CURRENT_CONTEXT ] = \\ ( ' GET ' , ' /session/$sessionId/context ' ) self . command_executor . _commands [ Command . SWITCH_TO_CONTEXT ] = \\ ( ' POST ' , ' /session/$sessionId/context ' ) Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache context Returns the current context of the current session. Usage: driver.context Return: str: The context of the current session contexts Returns the contexts within the current session. Usage: driver.contexts Return: :obj: list of :obj: str : The contexts within the current session current_context Returns the current context of the current session. Usage: driver.current_context Return: str: The context of the current session current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"Context"},{"location":"reference/appium/webdriver/extensions/context/#module-appiumwebdriverextensionscontext","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class Context ( webdriver . Remote ): @property def contexts ( self ): \"\"\"Returns the contexts within the current session. Usage: driver.contexts Return: :obj:`list` of :obj:`str`: The contexts within the current session \"\"\" return self . execute ( Command . CONTEXTS )[ 'value' ] @property def current_context ( self ): \"\"\"Returns the current context of the current session. Usage: driver.current_context Return: str: The context of the current session \"\"\" return self . execute ( Command . GET_CURRENT_CONTEXT )[ 'value' ] @property def context ( self ): \"\"\"Returns the current context of the current session. Usage: driver.context Return: str: The context of the current session \"\"\" return self . current_context # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . CONTEXTS ] = \\ ( 'GET' , '/session/$sessionId/contexts' ) self . command_executor . _commands [ Command . GET_CURRENT_CONTEXT ] = \\ ( 'GET' , '/session/$sessionId/context' ) self . command_executor . _commands [ Command . SWITCH_TO_CONTEXT ] = \\ ( 'POST' , '/session/$sessionId/context' )","title":"Module appium.webdriver.extensions.context"},{"location":"reference/appium/webdriver/extensions/context/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/context/#context","text":"class Context ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Context ( webdriver . Remote ) : @ property def contexts ( self ) : \"\"\" Returns the contexts within the current session. Usage : driver . contexts Return : : obj :` list ` of : obj :` str `: The contexts within the current session \"\"\" return self . execute ( Command . CONTEXTS ) [ ' value ' ] @ property def current_context ( self ) : \"\"\" Returns the current context of the current session. Usage : driver . current_context Return : str : The context of the current session \"\"\" return self . execute ( Command . GET_CURRENT_CONTEXT ) [ ' value ' ] @ property def context ( self ) : \"\"\" Returns the current context of the current session. Usage : driver . context Return : str : The context of the current session \"\"\" return self . current_context # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . CONTEXTS ] = \\ ( ' GET ' , ' /session/$sessionId/contexts ' ) self . command_executor . _commands [ Command . GET_CURRENT_CONTEXT ] = \\ ( ' GET ' , ' /session/$sessionId/context ' ) self . command_executor . _commands [ Command . SWITCH_TO_CONTEXT ] = \\ ( ' POST ' , ' /session/$sessionId/context ' )","title":"Context"},{"location":"reference/appium/webdriver/extensions/context/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/context/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/context/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache context Returns the current context of the current session. Usage: driver.context Return: str: The context of the current session contexts Returns the contexts within the current session. Usage: driver.contexts Return: :obj: list of :obj: str : The contexts within the current session current_context Returns the current context of the current session. Usage: driver.current_context Return: str: The context of the current session current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/context/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/context/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/context/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/context/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/context/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/context/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/context/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/context/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/context/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/context/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/context/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/context/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/context/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/context/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/context/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/context/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/context/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/context/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/context/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/context/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/context/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/context/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/context/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/context/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/context/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/context/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/context/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/context/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/context/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/context/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/context/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/context/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/context/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/context/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/context/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/context/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/context/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/context/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/context/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/context/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/context/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/context/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/context/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/context/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/context/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/context/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/context/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/context/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/context/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/context/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/context/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/context/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/context/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/context/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/context/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/context/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/context/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/context/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/context/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/context/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/device_time/","text":"Module appium.webdriver.extensions.device_time View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class DeviceTime ( webdriver . Remote ): @property def device_time ( self ): \"\"\"Returns the date and time from the device. Return: str: The date and time \"\"\" return self . execute ( Command . GET_DEVICE_TIME_GET , {})[ 'value' ] def get_device_time ( self , format = None ): \"\"\"Returns the date and time from the device. Args: format (optional): The set of format specifiers. Read https://momentjs.com/docs/ to get the full list of supported datetime format specifiers. If unset, return :func:`.device_time` as default format is `YYYY-MM-DDTHH:mm:ssZ`, which complies to ISO-8601 Usage: self.driver.get_device_time() self.driver.get_device_time(\"YYYY-MM-DD\") Return: str: The date and time \"\"\" if format is None : return self . device_time return self . execute ( Command . GET_DEVICE_TIME_POST , { 'format' : format })[ 'value' ] # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . GET_DEVICE_TIME_GET ] = \\ ( 'GET' , '/session/$sessionId/appium/device/system_time' ) self . command_executor . _commands [ Command . GET_DEVICE_TIME_POST ] = \\ ( 'POST' , '/session/$sessionId/appium/device/system_time' ) Classes DeviceTime class DeviceTime ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class DeviceTime ( webdriver . Remote ) : @ property def device_time ( self ) : \"\"\" Returns the date and time from the device. Return : str : The date and time \"\"\" return self . execute ( Command . GET_DEVICE_TIME_GET , {} ) [ ' value ' ] def get_device_time ( self , format = None ) : \"\"\" Returns the date and time from the device. Args : format ( optional ) : The set of format specifiers . Read https : // momentjs . com / docs / to get the full list of supported datetime format specifiers . If unset , return : func :`. device_time ` as default format is ` YYYY - MM - DDTHH : mm : ssZ `, which complies to ISO - 8601 Usage : self . driver . get_device_time () self . driver . get_device_time ( \" YYYY-MM-DD \" ) Return : str : The date and time \"\"\" if format is None : return self . device_time return self . execute ( Command . GET_DEVICE_TIME_POST , { ' format ' : format } ) [ ' value ' ] # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . GET_DEVICE_TIME_GET ] = \\ ( ' GET ' , ' /session/$sessionId/appium/device/system_time ' ) self . command_executor . _commands [ Command . GET_DEVICE_TIME_POST ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/system_time ' ) Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used device_time Returns the date and time from the device. Return: str: The date and time file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_device_time def get_device_time ( self , format = None ) Returns the date and time from the device. Args: format (optional): The set of format specifiers. Read https://momentjs.com/docs/ to get the full list of supported datetime format specifiers. If unset, return :func: .device_time as default format is YYYY-MM-DDTHH:mm:ssZ , which complies to ISO-8601 Usage: self.driver.get_device_time() self.driver.get_device_time(\"YYYY-MM-DD\") Return: str: The date and time View Source def get_device_time ( self , format = None ) : \"\"\" Returns the date and time from the device. Args : format ( optional ) : The set of format specifiers . Read https : // momentjs . com / docs / to get the full list of supported datetime format specifiers . If unset , return : func :`. device_time ` as default format is ` YYYY - MM - DDTHH : mm : ssZ `, which complies to ISO - 8601 Usage : self . driver . get_device_time () self . driver . get_device_time ( \" YYYY-MM-DD \" ) Return : str : The date and time \"\"\" if format is None : return self . device_time return self . execute ( Command . GET_DEVICE_TIME_POST , { ' format ' : format } ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"Device Time"},{"location":"reference/appium/webdriver/extensions/device_time/#module-appiumwebdriverextensionsdevice_time","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class DeviceTime ( webdriver . Remote ): @property def device_time ( self ): \"\"\"Returns the date and time from the device. Return: str: The date and time \"\"\" return self . execute ( Command . GET_DEVICE_TIME_GET , {})[ 'value' ] def get_device_time ( self , format = None ): \"\"\"Returns the date and time from the device. Args: format (optional): The set of format specifiers. Read https://momentjs.com/docs/ to get the full list of supported datetime format specifiers. If unset, return :func:`.device_time` as default format is `YYYY-MM-DDTHH:mm:ssZ`, which complies to ISO-8601 Usage: self.driver.get_device_time() self.driver.get_device_time(\"YYYY-MM-DD\") Return: str: The date and time \"\"\" if format is None : return self . device_time return self . execute ( Command . GET_DEVICE_TIME_POST , { 'format' : format })[ 'value' ] # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . GET_DEVICE_TIME_GET ] = \\ ( 'GET' , '/session/$sessionId/appium/device/system_time' ) self . command_executor . _commands [ Command . GET_DEVICE_TIME_POST ] = \\ ( 'POST' , '/session/$sessionId/appium/device/system_time' )","title":"Module appium.webdriver.extensions.device_time"},{"location":"reference/appium/webdriver/extensions/device_time/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/device_time/#devicetime","text":"class DeviceTime ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class DeviceTime ( webdriver . Remote ) : @ property def device_time ( self ) : \"\"\" Returns the date and time from the device. Return : str : The date and time \"\"\" return self . execute ( Command . GET_DEVICE_TIME_GET , {} ) [ ' value ' ] def get_device_time ( self , format = None ) : \"\"\" Returns the date and time from the device. Args : format ( optional ) : The set of format specifiers . Read https : // momentjs . com / docs / to get the full list of supported datetime format specifiers . If unset , return : func :`. device_time ` as default format is ` YYYY - MM - DDTHH : mm : ssZ `, which complies to ISO - 8601 Usage : self . driver . get_device_time () self . driver . get_device_time ( \" YYYY-MM-DD \" ) Return : str : The date and time \"\"\" if format is None : return self . device_time return self . execute ( Command . GET_DEVICE_TIME_POST , { ' format ' : format } ) [ ' value ' ] # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . GET_DEVICE_TIME_GET ] = \\ ( ' GET ' , ' /session/$sessionId/appium/device/system_time ' ) self . command_executor . _commands [ Command . GET_DEVICE_TIME_POST ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/system_time ' )","title":"DeviceTime"},{"location":"reference/appium/webdriver/extensions/device_time/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/device_time/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/device_time/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used device_time Returns the date and time from the device. Return: str: The date and time file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/device_time/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/device_time/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/device_time/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/device_time/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/device_time/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/device_time/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/device_time/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/device_time/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/device_time/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/device_time/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/device_time/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/device_time/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/device_time/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/device_time/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/device_time/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/device_time/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/device_time/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/device_time/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/device_time/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/device_time/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/device_time/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/device_time/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/device_time/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/device_time/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/device_time/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/device_time/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/device_time/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/device_time/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/device_time/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/device_time/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/device_time/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/device_time/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/device_time/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/device_time/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/device_time/#get_device_time","text":"def get_device_time ( self , format = None ) Returns the date and time from the device. Args: format (optional): The set of format specifiers. Read https://momentjs.com/docs/ to get the full list of supported datetime format specifiers. If unset, return :func: .device_time as default format is YYYY-MM-DDTHH:mm:ssZ , which complies to ISO-8601 Usage: self.driver.get_device_time() self.driver.get_device_time(\"YYYY-MM-DD\") Return: str: The date and time View Source def get_device_time ( self , format = None ) : \"\"\" Returns the date and time from the device. Args : format ( optional ) : The set of format specifiers . Read https : // momentjs . com / docs / to get the full list of supported datetime format specifiers . If unset , return : func :`. device_time ` as default format is ` YYYY - MM - DDTHH : mm : ssZ `, which complies to ISO - 8601 Usage : self . driver . get_device_time () self . driver . get_device_time ( \" YYYY-MM-DD \" ) Return : str : The date and time \"\"\" if format is None : return self . device_time return self . execute ( Command . GET_DEVICE_TIME_POST , { ' format ' : format } ) [ ' value ' ]","title":"get_device_time"},{"location":"reference/appium/webdriver/extensions/device_time/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/device_time/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/device_time/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/device_time/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/device_time/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/device_time/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/device_time/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/device_time/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/device_time/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/device_time/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/device_time/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/device_time/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/device_time/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/device_time/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/device_time/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/device_time/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/device_time/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/device_time/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/device_time/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/device_time/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/device_time/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/device_time/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/device_time/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/device_time/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/device_time/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/device_time/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/execute_driver/","text":"Module appium.webdriver.extensions.execute_driver View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class ExecuteDriver ( webdriver . Remote ): def execute_driver ( self , script , script_type = 'webdriverio' , timeout_ms = None ): \"\"\"Run a set of script against the current session, allowing execution of many commands in one Appium request. Please read http://appium.io/docs/en/commands/session/execute-driver for more details about the acceptable scripts and the output format. Args: script (string): The string consisting of the script itself script_type (string): The name of the script type. Defaults to 'webdriverio'. timeout_ms (optional): The number of `ms` Appium should wait for the script to finish before killing it due to timeout_ms. Usage: self.driver.execute_driver(script='return [];') self.driver.execute_driver(script='return [];', script_type='webdriverio') self.driver.execute_driver(script='return [];', script_type='webdriverio', timeout_ms=10000) Returns: ExecuteDriver.Result: The result of the script. It has 'result' and 'logs' keys. Raises: WebDriverException: If something error happenes in the script. The message has the original error message. \"\"\" class Result ( object ): def __init__ ( self , response ): self . result = response [ 'result' ] self . logs = response [ 'logs' ] option = { 'script' : script , 'type' : script_type } if timeout_ms is not None : option [ 'timeout' ] = timeout_ms response = self . execute ( Command . EXECUTE_DRIVER , option )[ 'value' ] return Result ( response ) # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . EXECUTE_DRIVER ] = \\ ( 'POST' , '/session/$sessionId/appium/execute_driver' ) Classes ExecuteDriver class ExecuteDriver ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class ExecuteDriver ( webdriver . Remote ) : def execute_driver ( self , script , script_type = ' webdriverio ' , timeout_ms = None ) : \"\"\" Run a set of script against the current session, allowing execution of many commands in one Appium request. Please read http : // appium . io / docs / en / commands / session / execute - driver for more details about the acceptable scripts and the output format . Args : script ( string ) : The string consisting of the script itself script_type ( string ) : The name of the script type . Defaults to ' webdriverio ' . timeout_ms ( optional ) : The number of ` ms ` Appium should wait for the script to finish before killing it due to timeout_ms . Usage : self . driver . execute_driver ( script = ' return []; ' ) self . driver . execute_driver ( script = ' return []; ' , script_type = ' webdriverio ' ) self . driver . execute_driver ( script = ' return []; ' , script_type = ' webdriverio ' , timeout_ms = 10000 ) Returns : ExecuteDriver . Result : The result of the script . It has ' result ' and ' logs ' keys . Raises : WebDriverException : If something error happenes in the script . The message has the original error message . \"\"\" class Result ( object ) : def __init__ ( self , response ) : self . result = response [ ' result ' ] self . logs = response [ ' logs ' ] option = { ' script ' : script , ' type ' : script_type } if timeout_ms is not None : option [ ' timeout ' ] = timeout_ms response = self . execute ( Command . EXECUTE_DRIVER , option ) [ ' value ' ] return Result ( response ) # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . EXECUTE_DRIVER ] = \\ ( ' POST ' , ' /session/$sessionId/appium/execute_driver ' ) Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_driver def execute_driver ( self , script , script_type = 'webdriverio' , timeout_ms = None ) Run a set of script against the current session, allowing execution of many commands in one Appium request. Please read http://appium.io/docs/en/commands/session/execute-driver for more details about the acceptable scripts and the output format. Args: script (string): The string consisting of the script itself script_type (string): The name of the script type. Defaults to 'webdriverio'. timeout_ms (optional): The number of ms Appium should wait for the script to finish before killing it due to timeout_ms. Usage: self.driver.execute_driver(script='return [];') self.driver.execute_driver(script='return [];', script_type='webdriverio') self.driver.execute_driver(script='return [];', script_type='webdriverio', timeout_ms=10000) Returns: ExecuteDriver.Result: The result of the script. It has 'result' and 'logs' keys. Raises: WebDriverException: If something error happenes in the script. The message has the original error message. View Source def execute_driver ( self , script , script_type = ' webdriverio ' , timeout_ms = None ) : \"\"\" Run a set of script against the current session, allowing execution of many commands in one Appium request. Please read http : // appium . io / docs / en / commands / session / execute - driver for more details about the acceptable scripts and the output format . Args : script ( string ) : The string consisting of the script itself script_type ( string ) : The name of the script type . Defaults to ' webdriverio ' . timeout_ms ( optional ) : The number of ` ms ` Appium should wait for the script to finish before killing it due to timeout_ms . Usage : self . driver . execute_driver ( script = ' return []; ' ) self . driver . execute_driver ( script = ' return []; ' , script_type = ' webdriverio ' ) self . driver . execute_driver ( script = ' return []; ' , script_type = ' webdriverio ' , timeout_ms = 10000 ) Returns : ExecuteDriver . Result : The result of the script . It has ' result ' and ' logs ' keys . Raises : WebDriverException : If something error happenes in the script . The message has the original error message . \"\"\" class Result ( object ) : def __init__ ( self , response ) : self . result = response [ ' result ' ] self . logs = response [ ' logs ' ] option = { ' script ' : script , ' type ' : script_type } if timeout_ms is not None : option [ ' timeout ' ] = timeout_ms response = self . execute ( Command . EXECUTE_DRIVER , option ) [ ' value ' ] return Result ( response ) execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"Execute Driver"},{"location":"reference/appium/webdriver/extensions/execute_driver/#module-appiumwebdriverextensionsexecute_driver","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class ExecuteDriver ( webdriver . Remote ): def execute_driver ( self , script , script_type = 'webdriverio' , timeout_ms = None ): \"\"\"Run a set of script against the current session, allowing execution of many commands in one Appium request. Please read http://appium.io/docs/en/commands/session/execute-driver for more details about the acceptable scripts and the output format. Args: script (string): The string consisting of the script itself script_type (string): The name of the script type. Defaults to 'webdriverio'. timeout_ms (optional): The number of `ms` Appium should wait for the script to finish before killing it due to timeout_ms. Usage: self.driver.execute_driver(script='return [];') self.driver.execute_driver(script='return [];', script_type='webdriverio') self.driver.execute_driver(script='return [];', script_type='webdriverio', timeout_ms=10000) Returns: ExecuteDriver.Result: The result of the script. It has 'result' and 'logs' keys. Raises: WebDriverException: If something error happenes in the script. The message has the original error message. \"\"\" class Result ( object ): def __init__ ( self , response ): self . result = response [ 'result' ] self . logs = response [ 'logs' ] option = { 'script' : script , 'type' : script_type } if timeout_ms is not None : option [ 'timeout' ] = timeout_ms response = self . execute ( Command . EXECUTE_DRIVER , option )[ 'value' ] return Result ( response ) # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . EXECUTE_DRIVER ] = \\ ( 'POST' , '/session/$sessionId/appium/execute_driver' )","title":"Module appium.webdriver.extensions.execute_driver"},{"location":"reference/appium/webdriver/extensions/execute_driver/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/execute_driver/#executedriver","text":"class ExecuteDriver ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class ExecuteDriver ( webdriver . Remote ) : def execute_driver ( self , script , script_type = ' webdriverio ' , timeout_ms = None ) : \"\"\" Run a set of script against the current session, allowing execution of many commands in one Appium request. Please read http : // appium . io / docs / en / commands / session / execute - driver for more details about the acceptable scripts and the output format . Args : script ( string ) : The string consisting of the script itself script_type ( string ) : The name of the script type . Defaults to ' webdriverio ' . timeout_ms ( optional ) : The number of ` ms ` Appium should wait for the script to finish before killing it due to timeout_ms . Usage : self . driver . execute_driver ( script = ' return []; ' ) self . driver . execute_driver ( script = ' return []; ' , script_type = ' webdriverio ' ) self . driver . execute_driver ( script = ' return []; ' , script_type = ' webdriverio ' , timeout_ms = 10000 ) Returns : ExecuteDriver . Result : The result of the script . It has ' result ' and ' logs ' keys . Raises : WebDriverException : If something error happenes in the script . The message has the original error message . \"\"\" class Result ( object ) : def __init__ ( self , response ) : self . result = response [ ' result ' ] self . logs = response [ ' logs ' ] option = { ' script ' : script , ' type ' : script_type } if timeout_ms is not None : option [ ' timeout ' ] = timeout_ms response = self . execute ( Command . EXECUTE_DRIVER , option ) [ ' value ' ] return Result ( response ) # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . EXECUTE_DRIVER ] = \\ ( ' POST ' , ' /session/$sessionId/appium/execute_driver ' )","title":"ExecuteDriver"},{"location":"reference/appium/webdriver/extensions/execute_driver/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/execute_driver/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/execute_driver/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/execute_driver/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/execute_driver/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/execute_driver/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/execute_driver/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/execute_driver/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/execute_driver/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/execute_driver/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/execute_driver/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/execute_driver/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/execute_driver/#execute_driver","text":"def execute_driver ( self , script , script_type = 'webdriverio' , timeout_ms = None ) Run a set of script against the current session, allowing execution of many commands in one Appium request. Please read http://appium.io/docs/en/commands/session/execute-driver for more details about the acceptable scripts and the output format. Args: script (string): The string consisting of the script itself script_type (string): The name of the script type. Defaults to 'webdriverio'. timeout_ms (optional): The number of ms Appium should wait for the script to finish before killing it due to timeout_ms. Usage: self.driver.execute_driver(script='return [];') self.driver.execute_driver(script='return [];', script_type='webdriverio') self.driver.execute_driver(script='return [];', script_type='webdriverio', timeout_ms=10000) Returns: ExecuteDriver.Result: The result of the script. It has 'result' and 'logs' keys. Raises: WebDriverException: If something error happenes in the script. The message has the original error message. View Source def execute_driver ( self , script , script_type = ' webdriverio ' , timeout_ms = None ) : \"\"\" Run a set of script against the current session, allowing execution of many commands in one Appium request. Please read http : // appium . io / docs / en / commands / session / execute - driver for more details about the acceptable scripts and the output format . Args : script ( string ) : The string consisting of the script itself script_type ( string ) : The name of the script type . Defaults to ' webdriverio ' . timeout_ms ( optional ) : The number of ` ms ` Appium should wait for the script to finish before killing it due to timeout_ms . Usage : self . driver . execute_driver ( script = ' return []; ' ) self . driver . execute_driver ( script = ' return []; ' , script_type = ' webdriverio ' ) self . driver . execute_driver ( script = ' return []; ' , script_type = ' webdriverio ' , timeout_ms = 10000 ) Returns : ExecuteDriver . Result : The result of the script . It has ' result ' and ' logs ' keys . Raises : WebDriverException : If something error happenes in the script . The message has the original error message . \"\"\" class Result ( object ) : def __init__ ( self , response ) : self . result = response [ ' result ' ] self . logs = response [ ' logs ' ] option = { ' script ' : script , ' type ' : script_type } if timeout_ms is not None : option [ ' timeout ' ] = timeout_ms response = self . execute ( Command . EXECUTE_DRIVER , option ) [ ' value ' ] return Result ( response )","title":"execute_driver"},{"location":"reference/appium/webdriver/extensions/execute_driver/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/execute_driver/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/execute_driver/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/execute_driver/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/execute_driver/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/execute_driver/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/execute_driver/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/execute_driver/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/execute_driver/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/execute_driver/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/execute_driver/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/execute_driver/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/execute_driver/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/execute_driver/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/execute_driver/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/execute_driver/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/execute_driver/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/execute_driver/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/execute_driver/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/execute_driver/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/execute_driver/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/execute_driver/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/execute_driver/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/execute_driver/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/execute_driver/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/execute_driver/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/execute_driver/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/execute_driver/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/execute_driver/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/execute_driver/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/execute_driver/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/execute_driver/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/execute_driver/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/execute_driver/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/execute_driver/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/execute_driver/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/execute_driver/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/execute_driver/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/execute_driver/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/execute_driver/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/execute_driver/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/execute_driver/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/execute_driver/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/execute_driver/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/execute_driver/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/execute_driver/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/execute_driver/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/execute_driver/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/execute_driver/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/execute_driver/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/execute_driver/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/hw_actions/","text":"Module appium.webdriver.extensions.hw_actions View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class HardwareActions ( webdriver . Remote ): def lock ( self , seconds = None ): \"\"\"Lock the device. No changes are made if the device is already unlocked. Args: seconds (optional): The duration to lock the device, in seconds. The device is going to be locked forever until `unlock` is called if it equals or is less than zero, otherwise this call blocks until the timeout expires and unlocks the screen automatically. Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" if seconds is None : self . execute ( Command . LOCK ) else : self . execute ( Command . LOCK , { 'seconds' : seconds }) return self def unlock ( self ): \"\"\"Unlock the device. No changes are made if the device is already locked. Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . UNLOCK ) return self def is_locked ( self ): \"\"\"Checks whether the device is locked. Returns: bool: `True` if the device is locked \"\"\" return self . execute ( Command . IS_LOCKED )[ 'value' ] def shake ( self ): \"\"\"Shake the device. Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . SHAKE ) return self def touch_id ( self , match ): \"\"\"Simulate touchId on iOS Simulator Args: match (bool): Simulates a successful touch (`True`) or a failed touch (`False`) Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'match' : match } self . execute ( Command . TOUCH_ID , data ) return self def toggle_touch_id_enrollment ( self ): \"\"\"Toggle enroll touchId on iOS Simulator Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . TOGGLE_TOUCH_ID_ENROLLMENT ) return self def finger_print ( self , finger_id ): \"\"\"Authenticate users by using their finger print scans on supported Android emulators. Args: finger_id (int): Finger prints stored in Android Keystore system (from 1 to 10) Returns: TODO \"\"\" return self . execute ( Command . FINGER_PRINT , { 'fingerprintId' : finger_id })[ 'value' ] # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . LOCK ] = \\ ( 'POST' , '/session/$sessionId/appium/device/lock' ) self . command_executor . _commands [ Command . UNLOCK ] = \\ ( 'POST' , '/session/$sessionId/appium/device/unlock' ) self . command_executor . _commands [ Command . IS_LOCKED ] = \\ ( 'POST' , '/session/$sessionId/appium/device/is_locked' ) self . command_executor . _commands [ Command . SHAKE ] = \\ ( 'POST' , '/session/$sessionId/appium/device/shake' ) self . command_executor . _commands [ Command . TOUCH_ID ] = \\ ( 'POST' , '/session/$sessionId/appium/simulator/touch_id' ) self . command_executor . _commands [ Command . TOGGLE_TOUCH_ID_ENROLLMENT ] = \\ ( 'POST' , '/session/$sessionId/appium/simulator/toggle_touch_id_enrollment' ) self . command_executor . _commands [ Command . FINGER_PRINT ] = \\ ( 'POST' , '/session/$sessionId/appium/device/finger_print' ) Classes HardwareActions class HardwareActions ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class HardwareActions ( webdriver . Remote ) : def lock ( self , seconds = None ) : \"\"\" Lock the device. No changes are made if the device is already unlocked. Args : seconds ( optional ) : The duration to lock the device , in seconds . The device is going to be locked forever until ` unlock ` is called if it equals or is less than zero , otherwise this call blocks until the timeout expires and unlocks the screen automatically . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" if seconds is None : self . execute ( Command . LOCK ) else : self . execute ( Command . LOCK , { ' seconds ' : seconds } ) return self def unlock ( self ) : \"\"\" Unlock the device. No changes are made if the device is already locked. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . UNLOCK ) return self def is_locked ( self ) : \"\"\" Checks whether the device is locked. Returns : bool : ` True ` if the device is locked \"\"\" return self . execute ( Command . IS_LOCKED ) [ ' value ' ] def shake ( self ) : \"\"\" Shake the device. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SHAKE ) return self def touch_id ( self , match ) : \"\"\" Simulate touchId on iOS Simulator Args : match ( bool ) : Simulates a successful touch ( ` True ` ) or a failed touch ( ` False ` ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' match ' : match } self . execute ( Command . TOUCH_ID , data ) return self def toggle_touch_id_enrollment ( self ) : \"\"\" Toggle enroll touchId on iOS Simulator Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . TOGGLE_TOUCH_ID_ENROLLMENT ) return self def finger_print ( self , finger_id ) : \"\"\" Authenticate users by using their finger print scans on supported Android emulators. Args : finger_id ( int ) : Finger prints stored in Android Keystore system ( from 1 to 10 ) Returns : TODO \"\"\" return self . execute ( Command . FINGER_PRINT , { ' fingerprintId ' : finger_id } ) [ ' value ' ] # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . LOCK ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/lock ' ) self . command_executor . _commands [ Command . UNLOCK ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/unlock ' ) self . command_executor . _commands [ Command . IS_LOCKED ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/is_locked ' ) self . command_executor . _commands [ Command . SHAKE ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/shake ' ) self . command_executor . _commands [ Command . TOUCH_ID ] = \\ ( ' POST ' , ' /session/$sessionId/appium/simulator/touch_id ' ) self . command_executor . _commands [ Command . TOGGLE_TOUCH_ID_ENROLLMENT ] = \\ ( ' POST ' , ' /session/$sessionId/appium/simulator/toggle_touch_id_enrollment ' ) self . command_executor . _commands [ Command . FINGER_PRINT ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/finger_print ' ) Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) finger_print def finger_print ( self , finger_id ) Authenticate users by using their finger print scans on supported Android emulators. Args: finger_id (int): Finger prints stored in Android Keystore system (from 1 to 10) Returns: TODO View Source def finger_print ( self , finger_id ) : \"\"\" Authenticate users by using their finger print scans on supported Android emulators. Args : finger_id ( int ) : Finger prints stored in Android Keystore system ( from 1 to 10 ) Returns : TODO \"\"\" return self . execute ( Command . FINGER_PRINT , { ' fingerprintId ' : finger_id } ) [ ' value ' ] forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) is_locked def is_locked ( self ) Checks whether the device is locked. Returns: bool: True if the device is locked View Source def is_locked ( self ) : \"\"\" Checks whether the device is locked. Returns : bool : ` True ` if the device is locked \"\"\" return self . execute ( Command . IS_LOCKED ) [ ' value ' ] lock def lock ( self , seconds = None ) Lock the device. No changes are made if the device is already unlocked. Args: seconds (optional): The duration to lock the device, in seconds. The device is going to be locked forever until unlock is called if it equals or is less than zero, otherwise this call blocks until the timeout expires and unlocks the screen automatically. Returns: appium.webdriver.webdriver.WebDriver View Source def lock ( self , seconds = None ) : \"\"\" Lock the device. No changes are made if the device is already unlocked. Args : seconds ( optional ) : The duration to lock the device , in seconds . The device is going to be locked forever until ` unlock ` is called if it equals or is less than zero , otherwise this call blocks until the timeout expires and unlocks the screen automatically . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" if seconds is None : self . execute ( Command . LOCK ) else : self . execute ( Command . LOCK , { ' seconds ' : seconds } ) return self maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) shake def shake ( self ) Shake the device. Returns: appium.webdriver.webdriver.WebDriver View Source def shake ( self ) : \"\"\" Shake the device. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SHAKE ) return self start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name ) toggle_touch_id_enrollment def toggle_touch_id_enrollment ( self ) Toggle enroll touchId on iOS Simulator Returns: appium.webdriver.webdriver.WebDriver View Source def toggle_touch_id_enrollment ( self ) : \"\"\" Toggle enroll touchId on iOS Simulator Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . TOGGLE_TOUCH_ID_ENROLLMENT ) return self touch_id def touch_id ( self , match ) Simulate touchId on iOS Simulator Args: match (bool): Simulates a successful touch ( True ) or a failed touch ( False ) Returns: appium.webdriver.webdriver.WebDriver View Source def touch_id ( self , match ) : \"\"\" Simulate touchId on iOS Simulator Args : match ( bool ) : Simulates a successful touch ( ` True ` ) or a failed touch ( ` False ` ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' match ' : match } self . execute ( Command . TOUCH_ID , data ) return self unlock def unlock ( self ) Unlock the device. No changes are made if the device is already locked. Returns: appium.webdriver.webdriver.WebDriver View Source def unlock ( self ) : \"\"\" Unlock the device. No changes are made if the device is already locked. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . UNLOCK ) return self","title":"Hw Actions"},{"location":"reference/appium/webdriver/extensions/hw_actions/#module-appiumwebdriverextensionshw_actions","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class HardwareActions ( webdriver . Remote ): def lock ( self , seconds = None ): \"\"\"Lock the device. No changes are made if the device is already unlocked. Args: seconds (optional): The duration to lock the device, in seconds. The device is going to be locked forever until `unlock` is called if it equals or is less than zero, otherwise this call blocks until the timeout expires and unlocks the screen automatically. Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" if seconds is None : self . execute ( Command . LOCK ) else : self . execute ( Command . LOCK , { 'seconds' : seconds }) return self def unlock ( self ): \"\"\"Unlock the device. No changes are made if the device is already locked. Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . UNLOCK ) return self def is_locked ( self ): \"\"\"Checks whether the device is locked. Returns: bool: `True` if the device is locked \"\"\" return self . execute ( Command . IS_LOCKED )[ 'value' ] def shake ( self ): \"\"\"Shake the device. Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . SHAKE ) return self def touch_id ( self , match ): \"\"\"Simulate touchId on iOS Simulator Args: match (bool): Simulates a successful touch (`True`) or a failed touch (`False`) Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'match' : match } self . execute ( Command . TOUCH_ID , data ) return self def toggle_touch_id_enrollment ( self ): \"\"\"Toggle enroll touchId on iOS Simulator Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . TOGGLE_TOUCH_ID_ENROLLMENT ) return self def finger_print ( self , finger_id ): \"\"\"Authenticate users by using their finger print scans on supported Android emulators. Args: finger_id (int): Finger prints stored in Android Keystore system (from 1 to 10) Returns: TODO \"\"\" return self . execute ( Command . FINGER_PRINT , { 'fingerprintId' : finger_id })[ 'value' ] # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . LOCK ] = \\ ( 'POST' , '/session/$sessionId/appium/device/lock' ) self . command_executor . _commands [ Command . UNLOCK ] = \\ ( 'POST' , '/session/$sessionId/appium/device/unlock' ) self . command_executor . _commands [ Command . IS_LOCKED ] = \\ ( 'POST' , '/session/$sessionId/appium/device/is_locked' ) self . command_executor . _commands [ Command . SHAKE ] = \\ ( 'POST' , '/session/$sessionId/appium/device/shake' ) self . command_executor . _commands [ Command . TOUCH_ID ] = \\ ( 'POST' , '/session/$sessionId/appium/simulator/touch_id' ) self . command_executor . _commands [ Command . TOGGLE_TOUCH_ID_ENROLLMENT ] = \\ ( 'POST' , '/session/$sessionId/appium/simulator/toggle_touch_id_enrollment' ) self . command_executor . _commands [ Command . FINGER_PRINT ] = \\ ( 'POST' , '/session/$sessionId/appium/device/finger_print' )","title":"Module appium.webdriver.extensions.hw_actions"},{"location":"reference/appium/webdriver/extensions/hw_actions/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/hw_actions/#hardwareactions","text":"class HardwareActions ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class HardwareActions ( webdriver . Remote ) : def lock ( self , seconds = None ) : \"\"\" Lock the device. No changes are made if the device is already unlocked. Args : seconds ( optional ) : The duration to lock the device , in seconds . The device is going to be locked forever until ` unlock ` is called if it equals or is less than zero , otherwise this call blocks until the timeout expires and unlocks the screen automatically . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" if seconds is None : self . execute ( Command . LOCK ) else : self . execute ( Command . LOCK , { ' seconds ' : seconds } ) return self def unlock ( self ) : \"\"\" Unlock the device. No changes are made if the device is already locked. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . UNLOCK ) return self def is_locked ( self ) : \"\"\" Checks whether the device is locked. Returns : bool : ` True ` if the device is locked \"\"\" return self . execute ( Command . IS_LOCKED ) [ ' value ' ] def shake ( self ) : \"\"\" Shake the device. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SHAKE ) return self def touch_id ( self , match ) : \"\"\" Simulate touchId on iOS Simulator Args : match ( bool ) : Simulates a successful touch ( ` True ` ) or a failed touch ( ` False ` ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' match ' : match } self . execute ( Command . TOUCH_ID , data ) return self def toggle_touch_id_enrollment ( self ) : \"\"\" Toggle enroll touchId on iOS Simulator Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . TOGGLE_TOUCH_ID_ENROLLMENT ) return self def finger_print ( self , finger_id ) : \"\"\" Authenticate users by using their finger print scans on supported Android emulators. Args : finger_id ( int ) : Finger prints stored in Android Keystore system ( from 1 to 10 ) Returns : TODO \"\"\" return self . execute ( Command . FINGER_PRINT , { ' fingerprintId ' : finger_id } ) [ ' value ' ] # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . LOCK ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/lock ' ) self . command_executor . _commands [ Command . UNLOCK ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/unlock ' ) self . command_executor . _commands [ Command . IS_LOCKED ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/is_locked ' ) self . command_executor . _commands [ Command . SHAKE ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/shake ' ) self . command_executor . _commands [ Command . TOUCH_ID ] = \\ ( ' POST ' , ' /session/$sessionId/appium/simulator/touch_id ' ) self . command_executor . _commands [ Command . TOGGLE_TOUCH_ID_ENROLLMENT ] = \\ ( ' POST ' , ' /session/$sessionId/appium/simulator/toggle_touch_id_enrollment ' ) self . command_executor . _commands [ Command . FINGER_PRINT ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/finger_print ' )","title":"HardwareActions"},{"location":"reference/appium/webdriver/extensions/hw_actions/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/hw_actions/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/hw_actions/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/hw_actions/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/hw_actions/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/hw_actions/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/hw_actions/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/hw_actions/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/hw_actions/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/hw_actions/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/hw_actions/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/hw_actions/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/hw_actions/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/hw_actions/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/hw_actions/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/hw_actions/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/hw_actions/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/hw_actions/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/hw_actions/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/hw_actions/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/hw_actions/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/hw_actions/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/hw_actions/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/hw_actions/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/hw_actions/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/hw_actions/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/hw_actions/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/hw_actions/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/hw_actions/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/hw_actions/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/hw_actions/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/hw_actions/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/hw_actions/#finger_print","text":"def finger_print ( self , finger_id ) Authenticate users by using their finger print scans on supported Android emulators. Args: finger_id (int): Finger prints stored in Android Keystore system (from 1 to 10) Returns: TODO View Source def finger_print ( self , finger_id ) : \"\"\" Authenticate users by using their finger print scans on supported Android emulators. Args : finger_id ( int ) : Finger prints stored in Android Keystore system ( from 1 to 10 ) Returns : TODO \"\"\" return self . execute ( Command . FINGER_PRINT , { ' fingerprintId ' : finger_id } ) [ ' value ' ]","title":"finger_print"},{"location":"reference/appium/webdriver/extensions/hw_actions/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/hw_actions/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/hw_actions/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/hw_actions/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/hw_actions/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/hw_actions/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/hw_actions/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/hw_actions/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/hw_actions/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/hw_actions/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/hw_actions/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/hw_actions/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/hw_actions/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/hw_actions/#is_locked","text":"def is_locked ( self ) Checks whether the device is locked. Returns: bool: True if the device is locked View Source def is_locked ( self ) : \"\"\" Checks whether the device is locked. Returns : bool : ` True ` if the device is locked \"\"\" return self . execute ( Command . IS_LOCKED ) [ ' value ' ]","title":"is_locked"},{"location":"reference/appium/webdriver/extensions/hw_actions/#lock","text":"def lock ( self , seconds = None ) Lock the device. No changes are made if the device is already unlocked. Args: seconds (optional): The duration to lock the device, in seconds. The device is going to be locked forever until unlock is called if it equals or is less than zero, otherwise this call blocks until the timeout expires and unlocks the screen automatically. Returns: appium.webdriver.webdriver.WebDriver View Source def lock ( self , seconds = None ) : \"\"\" Lock the device. No changes are made if the device is already unlocked. Args : seconds ( optional ) : The duration to lock the device , in seconds . The device is going to be locked forever until ` unlock ` is called if it equals or is less than zero , otherwise this call blocks until the timeout expires and unlocks the screen automatically . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" if seconds is None : self . execute ( Command . LOCK ) else : self . execute ( Command . LOCK , { ' seconds ' : seconds } ) return self","title":"lock"},{"location":"reference/appium/webdriver/extensions/hw_actions/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/hw_actions/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/hw_actions/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/hw_actions/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/hw_actions/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/hw_actions/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/hw_actions/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/hw_actions/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/hw_actions/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/hw_actions/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/hw_actions/#shake","text":"def shake ( self ) Shake the device. Returns: appium.webdriver.webdriver.WebDriver View Source def shake ( self ) : \"\"\" Shake the device. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SHAKE ) return self","title":"shake"},{"location":"reference/appium/webdriver/extensions/hw_actions/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/hw_actions/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/hw_actions/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/hw_actions/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/hw_actions/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/hw_actions/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/hw_actions/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/hw_actions/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/hw_actions/#toggle_touch_id_enrollment","text":"def toggle_touch_id_enrollment ( self ) Toggle enroll touchId on iOS Simulator Returns: appium.webdriver.webdriver.WebDriver View Source def toggle_touch_id_enrollment ( self ) : \"\"\" Toggle enroll touchId on iOS Simulator Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . TOGGLE_TOUCH_ID_ENROLLMENT ) return self","title":"toggle_touch_id_enrollment"},{"location":"reference/appium/webdriver/extensions/hw_actions/#touch_id","text":"def touch_id ( self , match ) Simulate touchId on iOS Simulator Args: match (bool): Simulates a successful touch ( True ) or a failed touch ( False ) Returns: appium.webdriver.webdriver.WebDriver View Source def touch_id ( self , match ) : \"\"\" Simulate touchId on iOS Simulator Args : match ( bool ) : Simulates a successful touch ( ` True ` ) or a failed touch ( ` False ` ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' match ' : match } self . execute ( Command . TOUCH_ID , data ) return self","title":"touch_id"},{"location":"reference/appium/webdriver/extensions/hw_actions/#unlock","text":"def unlock ( self ) Unlock the device. No changes are made if the device is already locked. Returns: appium.webdriver.webdriver.WebDriver View Source def unlock ( self ) : \"\"\" Unlock the device. No changes are made if the device is already locked. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . UNLOCK ) return self","title":"unlock"},{"location":"reference/appium/webdriver/extensions/images_comparison/","text":"Module appium.webdriver.extensions.images_comparison View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class ImagesComparison ( webdriver . Remote ): def match_images_features ( self , base64_image1 , base64_image2 , ** opts ): \"\"\"Performs images matching by features. Read https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_feature2d/py_matcher/py_matcher.html for more details on this topic. The method supports all image formats, which are supported by OpenCV itself. Args: base64_image1 (bytes): base64-encoded content of the first image base64_image2 (bytes): base64-encoded content of the second image Keyword Args: visualize (bool): Set it to True in order to return the visualization of the matching operation. matching visualization. False by default detectorName (str): One of possible feature detector names: 'AKAZE', 'AGAST', 'BRISK', 'FAST', 'GFTT', 'KAZE', 'MSER', 'SIFT', 'ORB' Some of these detectors are not enabled in the default OpenCV deployment. 'ORB' By default. matchFunc (str): One of supported matching functions names: 'FlannBased', 'BruteForce', 'BruteForceL1', 'BruteForceHamming', 'BruteForceHammingLut', 'BruteForceSL2' 'BruteForce' by default goodMatchesFactor (int): The maximum count of \"good\" matches (e. g. with minimal distances). This count is unlimited by default. Returns: The dictionary containing the following entries: visualization (bytes): base64-encoded content of PNG visualization of the current comparison operation. This entry is only present if `visualize` option is enabled count (int): The count of matched edges on both images. The more matching edges there are no both images the more similar they are. totalCount (int): The total count of matched edges on both images. It is equal to `count` if `goodMatchesFactor` does not limit the matches, otherwise it contains the total count of matches before `goodMatchesFactor` is applied. points1 (dict)): The array of matching points on the first image. Each point is a dictionary with 'x' and 'y' keys rect1 (dict): The bounding rect for the `points1` array or a zero rect if not enough matching points were found. The rect is represented by a dictionary with 'x', 'y', 'width' and 'height' keys points2 (dict): The array of matching points on the second image. Each point is a dictionary with 'x' and 'y' keys rect2 (dict): The bounding rect for the `points2` array or a zero rect if not enough matching points were found. The rect is represented by a dictionary with 'x', 'y', 'width' and 'height' keys \"\"\" options = { 'mode' : 'matchFeatures' , 'firstImage' : base64_image1 , 'secondImage' : base64_image2 , 'options' : opts } return self . execute ( Command . COMPARE_IMAGES , options )[ 'value' ] def find_image_occurrence ( self , base64_full_image , base64_partial_image , ** opts ): \"\"\"Performs images matching by template to find possible occurrence of the partial image in the full image. Read https://docs.opencv.org/2.4/doc/tutorials/imgproc/histograms/template_matching/template_matching.html for more details on this topic. The method supports all image formats, which are supported by OpenCV itself. Args: base64_full_image (bytes): base64-encoded content of the full image base64_partial_image (bytes): base64-encoded content of the partial image Keyword Args: visualize (bool): Set it to True in order to return the visualization of the matching operation. False by default Returns: visualization (bytes): base64-encoded content of PNG visualization of the current comparison operation. This entry is only present if `visualize` option is enabled rect (dict): The region of the partial image occurrence on the full image. The rect is represented by a dictionary with 'x', 'y', 'width' and 'height' keys \"\"\" options = { 'mode' : 'matchTemplate' , 'firstImage' : base64_full_image , 'secondImage' : base64_partial_image , 'options' : opts } return self . execute ( Command . COMPARE_IMAGES , options )[ 'value' ] def get_images_similarity ( self , base64_image1 , base64_image2 , ** opts ): \"\"\"Performs images matching to calculate the similarity score between them. The flow there is similar to the one used in `find_image_occurrence`, but it is mandatory that both images are of equal resolution. The method supports all image formats, which are supported by OpenCV itself. Args: base64_image1 (bytes): base64-encoded content of the first image base64_image2 (bytes): base64-encoded content of the second image Keyword Args: visualize (bool): Set it to True in order to return the visualization of the matching operation. False by default Returns: visualization (bytes): base64-encoded content of PNG visualization of the current comparison operation. This entry is only present if `visualize` option is enabled score (float): The similarity score as a float number in range [0.0, 1.0]. 1.0 is the highest score (means both images are totally equal). \"\"\" options = { 'mode' : 'getSimilarity' , 'firstImage' : base64_image1 , 'secondImage' : base64_image2 , 'options' : opts } return self . execute ( Command . COMPARE_IMAGES , options )[ 'value' ] # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . COMPARE_IMAGES ] = \\ ( 'POST' , '/session/$sessionId/appium/compare_images' ) Classes ImagesComparison class ImagesComparison ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class ImagesComparison ( webdriver . Remote ) : def match_images_features ( self , base64_image1 , base64_image2 , ** opts ) : \"\"\" Performs images matching by features. Read https : // docs . opencv . org / 3 . 0 - beta / doc / py_tutorials / py_feature2d / py_matcher / py_matcher . html for more details on this topic . The method supports all image formats , which are supported by OpenCV itself . Args : base64_image1 ( bytes ) : base64 - encoded content of the first image base64_image2 ( bytes ) : base64 - encoded content of the second image Keyword Args : visualize ( bool ) : Set it to True in order to return the visualization of the matching operation . matching visualization . False by default detectorName ( str ) : One of possible feature detector names : ' AKAZE ' , ' AGAST ' , ' BRISK ' , ' FAST ' , ' GFTT ' , ' KAZE ' , ' MSER ' , ' SIFT ' , ' ORB ' Some of these detectors are not enabled in the default OpenCV deployment . ' ORB ' By default . matchFunc ( str ) : One of supported matching functions names : ' FlannBased ' , ' BruteForce ' , ' BruteForceL1 ' , ' BruteForceHamming ' , ' BruteForceHammingLut ' , ' BruteForceSL2 ' ' BruteForce ' by default goodMatchesFactor ( int ) : The maximum count of \" good \" matches ( e . g . with minimal distances ) . This count is unlimited by default . Returns : The dictionary containing the following entries : visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled count ( int ) : The count of matched edges on both images . The more matching edges there are no both images the more similar they are . totalCount ( int ) : The total count of matched edges on both images . It is equal to ` count ` if ` goodMatchesFactor ` does not limit the matches , otherwise it contains the total count of matches before ` goodMatchesFactor ` is applied . points1 ( dict )) : The array of matching points on the first image . Each point is a dictionary with ' x ' and ' y ' keys rect1 ( dict ) : The bounding rect for the ` points1 ` array or a zero rect if not enough matching points were found . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys points2 ( dict ) : The array of matching points on the second image . Each point is a dictionary with ' x ' and ' y ' keys rect2 ( dict ) : The bounding rect for the ` points2 ` array or a zero rect if not enough matching points were found . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys \"\"\" options = { ' mode ' : ' matchFeatures ' , ' firstImage ' : base64_image1 , ' secondImage ' : base64_image2 , ' options ' : opts } return self . execute ( Command . COMPARE_IMAGES , options ) [ ' value ' ] def find_image_occurrence ( self , base64_full_image , base64_partial_image , ** opts ) : \"\"\" Performs images matching by template to find possible occurrence of the partial image in the full image . Read https : // docs . opencv . org / 2 . 4 / doc / tutorials / imgproc / histograms / template_matching / template_matching . html for more details on this topic . The method supports all image formats , which are supported by OpenCV itself . Args : base64_full_image ( bytes ) : base64 - encoded content of the full image base64_partial_image ( bytes ) : base64 - encoded content of the partial image Keyword Args : visualize ( bool ) : Set it to True in order to return the visualization of the matching operation . False by default Returns : visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled rect ( dict ) : The region of the partial image occurrence on the full image . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys \"\"\" options = { ' mode ' : ' matchTemplate ' , ' firstImage ' : base64_full_image , ' secondImage ' : base64_partial_image , ' options ' : opts } return self . execute ( Command . COMPARE_IMAGES , options ) [ ' value ' ] def get_images_similarity ( self , base64_image1 , base64_image2 , ** opts ) : \"\"\" Performs images matching to calculate the similarity score between them. The flow there is similar to the one used in ` find_image_occurrence `, but it is mandatory that both images are of equal resolution . The method supports all image formats , which are supported by OpenCV itself . Args : base64_image1 ( bytes ) : base64 - encoded content of the first image base64_image2 ( bytes ) : base64 - encoded content of the second image Keyword Args : visualize ( bool ) : Set it to True in order to return the visualization of the matching operation . False by default Returns : visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled score ( float ) : The similarity score as a float number in range [ 0 . 0 , 1 . 0 ]. 1 . 0 is the highest score ( means both images are totally equal ) . \"\"\" options = { ' mode ' : ' getSimilarity ' , ' firstImage ' : base64_image1 , ' secondImage ' : base64_image2 , ' options ' : opts } return self . execute ( Command . COMPARE_IMAGES , options ) [ ' value ' ] # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . COMPARE_IMAGES ] = \\ ( ' POST ' , ' /session/$sessionId/appium/compare_images ' ) Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) find_image_occurrence def find_image_occurrence ( self , base64_full_image , base64_partial_image , ** opts ) Performs images matching by template to find possible occurrence of the partial image in the full image. Read https://docs.opencv.org/2.4/doc/tutorials/imgproc/histograms/template_matching/template_matching.html for more details on this topic. The method supports all image formats, which are supported by OpenCV itself. Args: base64_full_image (bytes): base64-encoded content of the full image base64_partial_image (bytes): base64-encoded content of the partial image Keyword Args: visualize (bool): Set it to True in order to return the visualization of the matching operation. False by default Returns: visualization (bytes): base64-encoded content of PNG visualization of the current comparison operation. This entry is only present if visualize option is enabled rect (dict): The region of the partial image occurrence on the full image. The rect is represented by a dictionary with 'x', 'y', 'width' and 'height' keys View Source def find_image_occurrence ( self , base64_full_image , base64_partial_image , ** opts ) : \"\"\" Performs images matching by template to find possible occurrence of the partial image in the full image . Read https : // docs . opencv . org / 2 . 4 / doc / tutorials / imgproc / histograms / template_matching / template_matching . html for more details on this topic . The method supports all image formats , which are supported by OpenCV itself . Args : base64_full_image ( bytes ) : base64 - encoded content of the full image base64_partial_image ( bytes ) : base64 - encoded content of the partial image Keyword Args : visualize ( bool ) : Set it to True in order to return the visualization of the matching operation . False by default Returns : visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled rect ( dict ) : The region of the partial image occurrence on the full image . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys \"\"\" options = { ' mode ' : ' matchTemplate ' , ' firstImage ' : base64_full_image , ' secondImage ' : base64_partial_image , ' options ' : opts } return self . execute ( Command . COMPARE_IMAGES , options ) [ ' value ' ] forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_images_similarity def get_images_similarity ( self , base64_image1 , base64_image2 , ** opts ) Performs images matching to calculate the similarity score between them. The flow there is similar to the one used in find_image_occurrence , but it is mandatory that both images are of equal resolution. The method supports all image formats, which are supported by OpenCV itself. Args: base64_image1 (bytes): base64-encoded content of the first image base64_image2 (bytes): base64-encoded content of the second image Keyword Args: visualize (bool): Set it to True in order to return the visualization of the matching operation. False by default Returns: visualization (bytes): base64-encoded content of PNG visualization of the current comparison operation. This entry is only present if visualize option is enabled score (float): The similarity score as a float number in range [0.0, 1.0]. 1.0 is the highest score (means both images are totally equal). View Source def get_images_similarity ( self , base64_image1 , base64_image2 , ** opts ) : \"\"\" Performs images matching to calculate the similarity score between them. The flow there is similar to the one used in ` find_image_occurrence `, but it is mandatory that both images are of equal resolution . The method supports all image formats , which are supported by OpenCV itself . Args : base64_image1 ( bytes ) : base64 - encoded content of the first image base64_image2 ( bytes ) : base64 - encoded content of the second image Keyword Args : visualize ( bool ) : Set it to True in order to return the visualization of the matching operation . False by default Returns : visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled score ( float ) : The similarity score as a float number in range [ 0 . 0 , 1 . 0 ]. 1 . 0 is the highest score ( means both images are totally equal ) . \"\"\" options = { ' mode ' : ' getSimilarity ' , ' firstImage ' : base64_image1 , ' secondImage ' : base64_image2 , ' options ' : opts } return self . execute ( Command . COMPARE_IMAGES , options ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) match_images_features def match_images_features ( self , base64_image1 , base64_image2 , ** opts ) Performs images matching by features. Read https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_feature2d/py_matcher/py_matcher.html for more details on this topic. The method supports all image formats, which are supported by OpenCV itself. Args: base64_image1 (bytes): base64-encoded content of the first image base64_image2 (bytes): base64-encoded content of the second image Keyword Args: visualize (bool): Set it to True in order to return the visualization of the matching operation. matching visualization. False by default detectorName (str): One of possible feature detector names: 'AKAZE', 'AGAST', 'BRISK', 'FAST', 'GFTT', 'KAZE', 'MSER', 'SIFT', 'ORB' Some of these detectors are not enabled in the default OpenCV deployment. 'ORB' By default. matchFunc (str): One of supported matching functions names: 'FlannBased', 'BruteForce', 'BruteForceL1', 'BruteForceHamming', 'BruteForceHammingLut', 'BruteForceSL2' 'BruteForce' by default goodMatchesFactor (int): The maximum count of \"good\" matches (e. g. with minimal distances). This count is unlimited by default. Returns: The dictionary containing the following entries: visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled count ( int ) : The count of matched edges on both images . The more matching edges there are no both images the more similar they are . totalCount ( int ) : The total count of matched edges on both images . It is equal to ` count ` if ` goodMatchesFactor ` does not limit the matches , otherwise it contains the total count of matches before ` goodMatchesFactor ` is applied . points1 ( dict )) : The array of matching points on the first image . Each point is a dictionary with ' x ' and ' y ' keys rect1 ( dict ) : The bounding rect for the ` points1 ` array or a zero rect if not enough matching points were found . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys points2 ( dict ) : The array of matching points on the second image . Each point is a dictionary with ' x ' and ' y ' keys rect2 ( dict ) : The bounding rect for the ` points2 ` array or a zero rect if not enough matching points were found . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys View Source def match_images_features ( self , base64_image1 , base64_image2 , ** opts ) : \"\"\" Performs images matching by features. Read https : // docs . opencv . org / 3 . 0 - beta / doc / py_tutorials / py_feature2d / py_matcher / py_matcher . html for more details on this topic . The method supports all image formats , which are supported by OpenCV itself . Args : base64_image1 ( bytes ) : base64 - encoded content of the first image base64_image2 ( bytes ) : base64 - encoded content of the second image Keyword Args : visualize ( bool ) : Set it to True in order to return the visualization of the matching operation . matching visualization . False by default detectorName ( str ) : One of possible feature detector names : ' AKAZE ' , ' AGAST ' , ' BRISK ' , ' FAST ' , ' GFTT ' , ' KAZE ' , ' MSER ' , ' SIFT ' , ' ORB ' Some of these detectors are not enabled in the default OpenCV deployment . ' ORB ' By default . matchFunc ( str ) : One of supported matching functions names : ' FlannBased ' , ' BruteForce ' , ' BruteForceL1 ' , ' BruteForceHamming ' , ' BruteForceHammingLut ' , ' BruteForceSL2 ' ' BruteForce ' by default goodMatchesFactor ( int ) : The maximum count of \" good \" matches ( e . g . with minimal distances ) . This count is unlimited by default . Returns : The dictionary containing the following entries : visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled count ( int ) : The count of matched edges on both images . The more matching edges there are no both images the more similar they are . totalCount ( int ) : The total count of matched edges on both images . It is equal to ` count ` if ` goodMatchesFactor ` does not limit the matches , otherwise it contains the total count of matches before ` goodMatchesFactor ` is applied . points1 ( dict )) : The array of matching points on the first image . Each point is a dictionary with ' x ' and ' y ' keys rect1 ( dict ) : The bounding rect for the ` points1 ` array or a zero rect if not enough matching points were found . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys points2 ( dict ) : The array of matching points on the second image . Each point is a dictionary with ' x ' and ' y ' keys rect2 ( dict ) : The bounding rect for the ` points2 ` array or a zero rect if not enough matching points were found . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys \"\"\" options = { ' mode ' : ' matchFeatures ' , ' firstImage ' : base64_image1 , ' secondImage ' : base64_image2 , ' options ' : opts } return self . execute ( Command . COMPARE_IMAGES , options ) [ ' value ' ] maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"Images Comparison"},{"location":"reference/appium/webdriver/extensions/images_comparison/#module-appiumwebdriverextensionsimages_comparison","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class ImagesComparison ( webdriver . Remote ): def match_images_features ( self , base64_image1 , base64_image2 , ** opts ): \"\"\"Performs images matching by features. Read https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_feature2d/py_matcher/py_matcher.html for more details on this topic. The method supports all image formats, which are supported by OpenCV itself. Args: base64_image1 (bytes): base64-encoded content of the first image base64_image2 (bytes): base64-encoded content of the second image Keyword Args: visualize (bool): Set it to True in order to return the visualization of the matching operation. matching visualization. False by default detectorName (str): One of possible feature detector names: 'AKAZE', 'AGAST', 'BRISK', 'FAST', 'GFTT', 'KAZE', 'MSER', 'SIFT', 'ORB' Some of these detectors are not enabled in the default OpenCV deployment. 'ORB' By default. matchFunc (str): One of supported matching functions names: 'FlannBased', 'BruteForce', 'BruteForceL1', 'BruteForceHamming', 'BruteForceHammingLut', 'BruteForceSL2' 'BruteForce' by default goodMatchesFactor (int): The maximum count of \"good\" matches (e. g. with minimal distances). This count is unlimited by default. Returns: The dictionary containing the following entries: visualization (bytes): base64-encoded content of PNG visualization of the current comparison operation. This entry is only present if `visualize` option is enabled count (int): The count of matched edges on both images. The more matching edges there are no both images the more similar they are. totalCount (int): The total count of matched edges on both images. It is equal to `count` if `goodMatchesFactor` does not limit the matches, otherwise it contains the total count of matches before `goodMatchesFactor` is applied. points1 (dict)): The array of matching points on the first image. Each point is a dictionary with 'x' and 'y' keys rect1 (dict): The bounding rect for the `points1` array or a zero rect if not enough matching points were found. The rect is represented by a dictionary with 'x', 'y', 'width' and 'height' keys points2 (dict): The array of matching points on the second image. Each point is a dictionary with 'x' and 'y' keys rect2 (dict): The bounding rect for the `points2` array or a zero rect if not enough matching points were found. The rect is represented by a dictionary with 'x', 'y', 'width' and 'height' keys \"\"\" options = { 'mode' : 'matchFeatures' , 'firstImage' : base64_image1 , 'secondImage' : base64_image2 , 'options' : opts } return self . execute ( Command . COMPARE_IMAGES , options )[ 'value' ] def find_image_occurrence ( self , base64_full_image , base64_partial_image , ** opts ): \"\"\"Performs images matching by template to find possible occurrence of the partial image in the full image. Read https://docs.opencv.org/2.4/doc/tutorials/imgproc/histograms/template_matching/template_matching.html for more details on this topic. The method supports all image formats, which are supported by OpenCV itself. Args: base64_full_image (bytes): base64-encoded content of the full image base64_partial_image (bytes): base64-encoded content of the partial image Keyword Args: visualize (bool): Set it to True in order to return the visualization of the matching operation. False by default Returns: visualization (bytes): base64-encoded content of PNG visualization of the current comparison operation. This entry is only present if `visualize` option is enabled rect (dict): The region of the partial image occurrence on the full image. The rect is represented by a dictionary with 'x', 'y', 'width' and 'height' keys \"\"\" options = { 'mode' : 'matchTemplate' , 'firstImage' : base64_full_image , 'secondImage' : base64_partial_image , 'options' : opts } return self . execute ( Command . COMPARE_IMAGES , options )[ 'value' ] def get_images_similarity ( self , base64_image1 , base64_image2 , ** opts ): \"\"\"Performs images matching to calculate the similarity score between them. The flow there is similar to the one used in `find_image_occurrence`, but it is mandatory that both images are of equal resolution. The method supports all image formats, which are supported by OpenCV itself. Args: base64_image1 (bytes): base64-encoded content of the first image base64_image2 (bytes): base64-encoded content of the second image Keyword Args: visualize (bool): Set it to True in order to return the visualization of the matching operation. False by default Returns: visualization (bytes): base64-encoded content of PNG visualization of the current comparison operation. This entry is only present if `visualize` option is enabled score (float): The similarity score as a float number in range [0.0, 1.0]. 1.0 is the highest score (means both images are totally equal). \"\"\" options = { 'mode' : 'getSimilarity' , 'firstImage' : base64_image1 , 'secondImage' : base64_image2 , 'options' : opts } return self . execute ( Command . COMPARE_IMAGES , options )[ 'value' ] # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . COMPARE_IMAGES ] = \\ ( 'POST' , '/session/$sessionId/appium/compare_images' )","title":"Module appium.webdriver.extensions.images_comparison"},{"location":"reference/appium/webdriver/extensions/images_comparison/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/images_comparison/#imagescomparison","text":"class ImagesComparison ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class ImagesComparison ( webdriver . Remote ) : def match_images_features ( self , base64_image1 , base64_image2 , ** opts ) : \"\"\" Performs images matching by features. Read https : // docs . opencv . org / 3 . 0 - beta / doc / py_tutorials / py_feature2d / py_matcher / py_matcher . html for more details on this topic . The method supports all image formats , which are supported by OpenCV itself . Args : base64_image1 ( bytes ) : base64 - encoded content of the first image base64_image2 ( bytes ) : base64 - encoded content of the second image Keyword Args : visualize ( bool ) : Set it to True in order to return the visualization of the matching operation . matching visualization . False by default detectorName ( str ) : One of possible feature detector names : ' AKAZE ' , ' AGAST ' , ' BRISK ' , ' FAST ' , ' GFTT ' , ' KAZE ' , ' MSER ' , ' SIFT ' , ' ORB ' Some of these detectors are not enabled in the default OpenCV deployment . ' ORB ' By default . matchFunc ( str ) : One of supported matching functions names : ' FlannBased ' , ' BruteForce ' , ' BruteForceL1 ' , ' BruteForceHamming ' , ' BruteForceHammingLut ' , ' BruteForceSL2 ' ' BruteForce ' by default goodMatchesFactor ( int ) : The maximum count of \" good \" matches ( e . g . with minimal distances ) . This count is unlimited by default . Returns : The dictionary containing the following entries : visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled count ( int ) : The count of matched edges on both images . The more matching edges there are no both images the more similar they are . totalCount ( int ) : The total count of matched edges on both images . It is equal to ` count ` if ` goodMatchesFactor ` does not limit the matches , otherwise it contains the total count of matches before ` goodMatchesFactor ` is applied . points1 ( dict )) : The array of matching points on the first image . Each point is a dictionary with ' x ' and ' y ' keys rect1 ( dict ) : The bounding rect for the ` points1 ` array or a zero rect if not enough matching points were found . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys points2 ( dict ) : The array of matching points on the second image . Each point is a dictionary with ' x ' and ' y ' keys rect2 ( dict ) : The bounding rect for the ` points2 ` array or a zero rect if not enough matching points were found . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys \"\"\" options = { ' mode ' : ' matchFeatures ' , ' firstImage ' : base64_image1 , ' secondImage ' : base64_image2 , ' options ' : opts } return self . execute ( Command . COMPARE_IMAGES , options ) [ ' value ' ] def find_image_occurrence ( self , base64_full_image , base64_partial_image , ** opts ) : \"\"\" Performs images matching by template to find possible occurrence of the partial image in the full image . Read https : // docs . opencv . org / 2 . 4 / doc / tutorials / imgproc / histograms / template_matching / template_matching . html for more details on this topic . The method supports all image formats , which are supported by OpenCV itself . Args : base64_full_image ( bytes ) : base64 - encoded content of the full image base64_partial_image ( bytes ) : base64 - encoded content of the partial image Keyword Args : visualize ( bool ) : Set it to True in order to return the visualization of the matching operation . False by default Returns : visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled rect ( dict ) : The region of the partial image occurrence on the full image . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys \"\"\" options = { ' mode ' : ' matchTemplate ' , ' firstImage ' : base64_full_image , ' secondImage ' : base64_partial_image , ' options ' : opts } return self . execute ( Command . COMPARE_IMAGES , options ) [ ' value ' ] def get_images_similarity ( self , base64_image1 , base64_image2 , ** opts ) : \"\"\" Performs images matching to calculate the similarity score between them. The flow there is similar to the one used in ` find_image_occurrence `, but it is mandatory that both images are of equal resolution . The method supports all image formats , which are supported by OpenCV itself . Args : base64_image1 ( bytes ) : base64 - encoded content of the first image base64_image2 ( bytes ) : base64 - encoded content of the second image Keyword Args : visualize ( bool ) : Set it to True in order to return the visualization of the matching operation . False by default Returns : visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled score ( float ) : The similarity score as a float number in range [ 0 . 0 , 1 . 0 ]. 1 . 0 is the highest score ( means both images are totally equal ) . \"\"\" options = { ' mode ' : ' getSimilarity ' , ' firstImage ' : base64_image1 , ' secondImage ' : base64_image2 , ' options ' : opts } return self . execute ( Command . COMPARE_IMAGES , options ) [ ' value ' ] # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . COMPARE_IMAGES ] = \\ ( ' POST ' , ' /session/$sessionId/appium/compare_images ' )","title":"ImagesComparison"},{"location":"reference/appium/webdriver/extensions/images_comparison/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/images_comparison/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/images_comparison/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/images_comparison/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/images_comparison/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/images_comparison/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/images_comparison/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/images_comparison/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/images_comparison/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/images_comparison/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/images_comparison/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/images_comparison/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/images_comparison/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/images_comparison/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/images_comparison/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/images_comparison/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/images_comparison/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/images_comparison/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/images_comparison/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/images_comparison/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/images_comparison/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/images_comparison/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/images_comparison/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/images_comparison/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/images_comparison/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/images_comparison/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/images_comparison/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/images_comparison/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/images_comparison/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/images_comparison/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/images_comparison/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/images_comparison/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/images_comparison/#find_image_occurrence","text":"def find_image_occurrence ( self , base64_full_image , base64_partial_image , ** opts ) Performs images matching by template to find possible occurrence of the partial image in the full image. Read https://docs.opencv.org/2.4/doc/tutorials/imgproc/histograms/template_matching/template_matching.html for more details on this topic. The method supports all image formats, which are supported by OpenCV itself. Args: base64_full_image (bytes): base64-encoded content of the full image base64_partial_image (bytes): base64-encoded content of the partial image Keyword Args: visualize (bool): Set it to True in order to return the visualization of the matching operation. False by default Returns: visualization (bytes): base64-encoded content of PNG visualization of the current comparison operation. This entry is only present if visualize option is enabled rect (dict): The region of the partial image occurrence on the full image. The rect is represented by a dictionary with 'x', 'y', 'width' and 'height' keys View Source def find_image_occurrence ( self , base64_full_image , base64_partial_image , ** opts ) : \"\"\" Performs images matching by template to find possible occurrence of the partial image in the full image . Read https : // docs . opencv . org / 2 . 4 / doc / tutorials / imgproc / histograms / template_matching / template_matching . html for more details on this topic . The method supports all image formats , which are supported by OpenCV itself . Args : base64_full_image ( bytes ) : base64 - encoded content of the full image base64_partial_image ( bytes ) : base64 - encoded content of the partial image Keyword Args : visualize ( bool ) : Set it to True in order to return the visualization of the matching operation . False by default Returns : visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled rect ( dict ) : The region of the partial image occurrence on the full image . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys \"\"\" options = { ' mode ' : ' matchTemplate ' , ' firstImage ' : base64_full_image , ' secondImage ' : base64_partial_image , ' options ' : opts } return self . execute ( Command . COMPARE_IMAGES , options ) [ ' value ' ]","title":"find_image_occurrence"},{"location":"reference/appium/webdriver/extensions/images_comparison/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/images_comparison/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/images_comparison/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/images_comparison/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/images_comparison/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/images_comparison/#get_images_similarity","text":"def get_images_similarity ( self , base64_image1 , base64_image2 , ** opts ) Performs images matching to calculate the similarity score between them. The flow there is similar to the one used in find_image_occurrence , but it is mandatory that both images are of equal resolution. The method supports all image formats, which are supported by OpenCV itself. Args: base64_image1 (bytes): base64-encoded content of the first image base64_image2 (bytes): base64-encoded content of the second image Keyword Args: visualize (bool): Set it to True in order to return the visualization of the matching operation. False by default Returns: visualization (bytes): base64-encoded content of PNG visualization of the current comparison operation. This entry is only present if visualize option is enabled score (float): The similarity score as a float number in range [0.0, 1.0]. 1.0 is the highest score (means both images are totally equal). View Source def get_images_similarity ( self , base64_image1 , base64_image2 , ** opts ) : \"\"\" Performs images matching to calculate the similarity score between them. The flow there is similar to the one used in ` find_image_occurrence `, but it is mandatory that both images are of equal resolution . The method supports all image formats , which are supported by OpenCV itself . Args : base64_image1 ( bytes ) : base64 - encoded content of the first image base64_image2 ( bytes ) : base64 - encoded content of the second image Keyword Args : visualize ( bool ) : Set it to True in order to return the visualization of the matching operation . False by default Returns : visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled score ( float ) : The similarity score as a float number in range [ 0 . 0 , 1 . 0 ]. 1 . 0 is the highest score ( means both images are totally equal ) . \"\"\" options = { ' mode ' : ' getSimilarity ' , ' firstImage ' : base64_image1 , ' secondImage ' : base64_image2 , ' options ' : opts } return self . execute ( Command . COMPARE_IMAGES , options ) [ ' value ' ]","title":"get_images_similarity"},{"location":"reference/appium/webdriver/extensions/images_comparison/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/images_comparison/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/images_comparison/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/images_comparison/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/images_comparison/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/images_comparison/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/images_comparison/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/images_comparison/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/images_comparison/#match_images_features","text":"def match_images_features ( self , base64_image1 , base64_image2 , ** opts ) Performs images matching by features. Read https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_feature2d/py_matcher/py_matcher.html for more details on this topic. The method supports all image formats, which are supported by OpenCV itself. Args: base64_image1 (bytes): base64-encoded content of the first image base64_image2 (bytes): base64-encoded content of the second image Keyword Args: visualize (bool): Set it to True in order to return the visualization of the matching operation. matching visualization. False by default detectorName (str): One of possible feature detector names: 'AKAZE', 'AGAST', 'BRISK', 'FAST', 'GFTT', 'KAZE', 'MSER', 'SIFT', 'ORB' Some of these detectors are not enabled in the default OpenCV deployment. 'ORB' By default. matchFunc (str): One of supported matching functions names: 'FlannBased', 'BruteForce', 'BruteForceL1', 'BruteForceHamming', 'BruteForceHammingLut', 'BruteForceSL2' 'BruteForce' by default goodMatchesFactor (int): The maximum count of \"good\" matches (e. g. with minimal distances). This count is unlimited by default. Returns: The dictionary containing the following entries: visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled count ( int ) : The count of matched edges on both images . The more matching edges there are no both images the more similar they are . totalCount ( int ) : The total count of matched edges on both images . It is equal to ` count ` if ` goodMatchesFactor ` does not limit the matches , otherwise it contains the total count of matches before ` goodMatchesFactor ` is applied . points1 ( dict )) : The array of matching points on the first image . Each point is a dictionary with ' x ' and ' y ' keys rect1 ( dict ) : The bounding rect for the ` points1 ` array or a zero rect if not enough matching points were found . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys points2 ( dict ) : The array of matching points on the second image . Each point is a dictionary with ' x ' and ' y ' keys rect2 ( dict ) : The bounding rect for the ` points2 ` array or a zero rect if not enough matching points were found . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys View Source def match_images_features ( self , base64_image1 , base64_image2 , ** opts ) : \"\"\" Performs images matching by features. Read https : // docs . opencv . org / 3 . 0 - beta / doc / py_tutorials / py_feature2d / py_matcher / py_matcher . html for more details on this topic . The method supports all image formats , which are supported by OpenCV itself . Args : base64_image1 ( bytes ) : base64 - encoded content of the first image base64_image2 ( bytes ) : base64 - encoded content of the second image Keyword Args : visualize ( bool ) : Set it to True in order to return the visualization of the matching operation . matching visualization . False by default detectorName ( str ) : One of possible feature detector names : ' AKAZE ' , ' AGAST ' , ' BRISK ' , ' FAST ' , ' GFTT ' , ' KAZE ' , ' MSER ' , ' SIFT ' , ' ORB ' Some of these detectors are not enabled in the default OpenCV deployment . ' ORB ' By default . matchFunc ( str ) : One of supported matching functions names : ' FlannBased ' , ' BruteForce ' , ' BruteForceL1 ' , ' BruteForceHamming ' , ' BruteForceHammingLut ' , ' BruteForceSL2 ' ' BruteForce ' by default goodMatchesFactor ( int ) : The maximum count of \" good \" matches ( e . g . with minimal distances ) . This count is unlimited by default . Returns : The dictionary containing the following entries : visualization ( bytes ) : base64 - encoded content of PNG visualization of the current comparison operation . This entry is only present if ` visualize ` option is enabled count ( int ) : The count of matched edges on both images . The more matching edges there are no both images the more similar they are . totalCount ( int ) : The total count of matched edges on both images . It is equal to ` count ` if ` goodMatchesFactor ` does not limit the matches , otherwise it contains the total count of matches before ` goodMatchesFactor ` is applied . points1 ( dict )) : The array of matching points on the first image . Each point is a dictionary with ' x ' and ' y ' keys rect1 ( dict ) : The bounding rect for the ` points1 ` array or a zero rect if not enough matching points were found . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys points2 ( dict ) : The array of matching points on the second image . Each point is a dictionary with ' x ' and ' y ' keys rect2 ( dict ) : The bounding rect for the ` points2 ` array or a zero rect if not enough matching points were found . The rect is represented by a dictionary with ' x ' , ' y ' , ' width ' and ' height ' keys \"\"\" options = { ' mode ' : ' matchFeatures ' , ' firstImage ' : base64_image1 , ' secondImage ' : base64_image2 , ' options ' : opts } return self . execute ( Command . COMPARE_IMAGES , options ) [ ' value ' ]","title":"match_images_features"},{"location":"reference/appium/webdriver/extensions/images_comparison/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/images_comparison/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/images_comparison/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/images_comparison/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/images_comparison/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/images_comparison/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/images_comparison/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/images_comparison/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/images_comparison/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/images_comparison/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/images_comparison/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/images_comparison/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/images_comparison/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/images_comparison/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/images_comparison/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/images_comparison/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/images_comparison/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/images_comparison/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/ime/","text":"Module appium.webdriver.extensions.ime View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class IME ( webdriver . Remote ): @property def available_ime_engines ( self ): \"\"\"Get the available input methods for an Android device. Package and activity are returned (e.g., ['com.android.inputmethod.latin/.LatinIME']) Android only. Returns: :obj:`list` of :obj:`str`: The available input methods for an Android device \"\"\" return self . execute ( Command . GET_AVAILABLE_IME_ENGINES , {})[ 'value' ] def is_ime_active ( self ): \"\"\"Checks whether the device has IME service active. Android only. Returns: bool: `True` if IME service is active \"\"\" return self . execute ( Command . IS_IME_ACTIVE , {})[ 'value' ] def activate_ime_engine ( self , engine ): \"\"\"Activates the given IME engine on the device. Android only. Args: engine (str): the package and activity of the IME engine to activate (e.g., 'com.android.inputmethod.latin/.LatinIME') Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'engine' : engine } self . execute ( Command . ACTIVATE_IME_ENGINE , data ) return self def deactivate_ime_engine ( self ): \"\"\"Deactivates the currently active IME engine on the device. Android only. Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . DEACTIVATE_IME_ENGINE , {}) return self @property def active_ime_engine ( self ): \"\"\"Returns the activity and package of the currently active IME engine(e.g., 'com.android.inputmethod.latin/.LatinIME'). Android only. Returns: str: The activity and package of the currently active IME engine \"\"\" return self . execute ( Command . GET_ACTIVE_IME_ENGINE , {})[ 'value' ] # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . GET_AVAILABLE_IME_ENGINES ] = \\ ( 'GET' , '/session/$sessionId/ime/available_engines' ) self . command_executor . _commands [ Command . IS_IME_ACTIVE ] = \\ ( 'GET' , '/session/$sessionId/ime/activated' ) self . command_executor . _commands [ Command . ACTIVATE_IME_ENGINE ] = \\ ( 'POST' , '/session/$sessionId/ime/activate' ) self . command_executor . _commands [ Command . DEACTIVATE_IME_ENGINE ] = \\ ( 'POST' , '/session/$sessionId/ime/deactivate' ) self . command_executor . _commands [ Command . GET_ACTIVE_IME_ENGINE ] = \\ ( 'GET' , '/session/$sessionId/ime/active_engine' ) Classes IME class IME ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class IME ( webdriver . Remote ) : @ property def available_ime_engines ( self ) : \"\"\" Get the available input methods for an Android device. Package and activity are returned ( e . g ., [ ' com.android.inputmethod.latin/.LatinIME ' ] ) Android only . Returns : : obj :` list ` of : obj :` str `: The available input methods for an Android device \"\"\" return self . execute ( Command . GET_AVAILABLE_IME_ENGINES , {} ) [ ' value ' ] def is_ime_active ( self ) : \"\"\" Checks whether the device has IME service active. Android only . Returns : bool : ` True ` if IME service is active \"\"\" return self . execute ( Command . IS_IME_ACTIVE , {} ) [ ' value ' ] def activate_ime_engine ( self , engine ) : \"\"\" Activates the given IME engine on the device. Android only . Args : engine ( str ) : the package and activity of the IME engine to activate ( e . g ., ' com.android.inputmethod.latin/.LatinIME ' ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' engine ' : engine } self . execute ( Command . ACTIVATE_IME_ENGINE , data ) return self def deactivate_ime_engine ( self ) : \"\"\" Deactivates the currently active IME engine on the device. Android only . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . DEACTIVATE_IME_ENGINE , {} ) return self @ property def active_ime_engine ( self ) : \"\"\" Returns the activity and package of the currently active IME engine(e.g., 'com.android.inputmethod.latin/.LatinIME'). Android only . Returns : str : The activity and package of the currently active IME engine \"\"\" return self . execute ( Command . GET_ACTIVE_IME_ENGINE , {} ) [ ' value ' ] # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . GET_AVAILABLE_IME_ENGINES ] = \\ ( ' GET ' , ' /session/$sessionId/ime/available_engines ' ) self . command_executor . _commands [ Command . IS_IME_ACTIVE ] = \\ ( ' GET ' , ' /session/$sessionId/ime/activated ' ) self . command_executor . _commands [ Command . ACTIVATE_IME_ENGINE ] = \\ ( ' POST ' , ' /session/$sessionId/ime/activate ' ) self . command_executor . _commands [ Command . DEACTIVATE_IME_ENGINE ] = \\ ( ' POST ' , ' /session/$sessionId/ime/deactivate ' ) self . command_executor . _commands [ Command . GET_ACTIVE_IME_ENGINE ] = \\ ( ' GET ' , ' /session/$sessionId/ime/active_engine ' ) Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Instance variables active_ime_engine Returns the activity and package of the currently active IME engine(e.g., 'com.android.inputmethod.latin/.LatinIME'). Android only. Returns: str: The activity and package of the currently active IME engine application_cache Returns a ApplicationCache Object to interact with the browser app cache available_ime_engines Get the available input methods for an Android device. Package and activity are returned (e.g., ['com.android.inputmethod.latin/.LatinIME']) Android only. Returns: :obj: list of :obj: str : The available input methods for an Android device current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods activate_ime_engine def activate_ime_engine ( self , engine ) Activates the given IME engine on the device. Android only. Args: engine (str): the package and activity of the IME engine to activate (e.g., 'com.android.inputmethod.latin/.LatinIME') Returns: appium.webdriver.webdriver.WebDriver View Source def activate_ime_engine ( self , engine ) : \"\"\" Activates the given IME engine on the device. Android only . Args : engine ( str ) : the package and activity of the IME engine to activate ( e . g ., ' com.android.inputmethod.latin/.LatinIME ' ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' engine ' : engine } self . execute ( Command . ACTIVATE_IME_ENGINE , data ) return self add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) deactivate_ime_engine def deactivate_ime_engine ( self ) Deactivates the currently active IME engine on the device. Android only. Returns: appium.webdriver.webdriver.WebDriver View Source def deactivate_ime_engine ( self ) : \"\"\" Deactivates the currently active IME engine on the device. Android only . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . DEACTIVATE_IME_ENGINE , {} ) return self delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) is_ime_active def is_ime_active ( self ) Checks whether the device has IME service active. Android only. Returns: bool: True if IME service is active View Source def is_ime_active ( self ) : \"\"\" Checks whether the device has IME service active. Android only . Returns : bool : ` True ` if IME service is active \"\"\" return self . execute ( Command . IS_IME_ACTIVE , {} ) [ ' value ' ] maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"Ime"},{"location":"reference/appium/webdriver/extensions/ime/#module-appiumwebdriverextensionsime","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class IME ( webdriver . Remote ): @property def available_ime_engines ( self ): \"\"\"Get the available input methods for an Android device. Package and activity are returned (e.g., ['com.android.inputmethod.latin/.LatinIME']) Android only. Returns: :obj:`list` of :obj:`str`: The available input methods for an Android device \"\"\" return self . execute ( Command . GET_AVAILABLE_IME_ENGINES , {})[ 'value' ] def is_ime_active ( self ): \"\"\"Checks whether the device has IME service active. Android only. Returns: bool: `True` if IME service is active \"\"\" return self . execute ( Command . IS_IME_ACTIVE , {})[ 'value' ] def activate_ime_engine ( self , engine ): \"\"\"Activates the given IME engine on the device. Android only. Args: engine (str): the package and activity of the IME engine to activate (e.g., 'com.android.inputmethod.latin/.LatinIME') Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'engine' : engine } self . execute ( Command . ACTIVATE_IME_ENGINE , data ) return self def deactivate_ime_engine ( self ): \"\"\"Deactivates the currently active IME engine on the device. Android only. Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . DEACTIVATE_IME_ENGINE , {}) return self @property def active_ime_engine ( self ): \"\"\"Returns the activity and package of the currently active IME engine(e.g., 'com.android.inputmethod.latin/.LatinIME'). Android only. Returns: str: The activity and package of the currently active IME engine \"\"\" return self . execute ( Command . GET_ACTIVE_IME_ENGINE , {})[ 'value' ] # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . GET_AVAILABLE_IME_ENGINES ] = \\ ( 'GET' , '/session/$sessionId/ime/available_engines' ) self . command_executor . _commands [ Command . IS_IME_ACTIVE ] = \\ ( 'GET' , '/session/$sessionId/ime/activated' ) self . command_executor . _commands [ Command . ACTIVATE_IME_ENGINE ] = \\ ( 'POST' , '/session/$sessionId/ime/activate' ) self . command_executor . _commands [ Command . DEACTIVATE_IME_ENGINE ] = \\ ( 'POST' , '/session/$sessionId/ime/deactivate' ) self . command_executor . _commands [ Command . GET_ACTIVE_IME_ENGINE ] = \\ ( 'GET' , '/session/$sessionId/ime/active_engine' )","title":"Module appium.webdriver.extensions.ime"},{"location":"reference/appium/webdriver/extensions/ime/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/ime/#ime","text":"class IME ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class IME ( webdriver . Remote ) : @ property def available_ime_engines ( self ) : \"\"\" Get the available input methods for an Android device. Package and activity are returned ( e . g ., [ ' com.android.inputmethod.latin/.LatinIME ' ] ) Android only . Returns : : obj :` list ` of : obj :` str `: The available input methods for an Android device \"\"\" return self . execute ( Command . GET_AVAILABLE_IME_ENGINES , {} ) [ ' value ' ] def is_ime_active ( self ) : \"\"\" Checks whether the device has IME service active. Android only . Returns : bool : ` True ` if IME service is active \"\"\" return self . execute ( Command . IS_IME_ACTIVE , {} ) [ ' value ' ] def activate_ime_engine ( self , engine ) : \"\"\" Activates the given IME engine on the device. Android only . Args : engine ( str ) : the package and activity of the IME engine to activate ( e . g ., ' com.android.inputmethod.latin/.LatinIME ' ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' engine ' : engine } self . execute ( Command . ACTIVATE_IME_ENGINE , data ) return self def deactivate_ime_engine ( self ) : \"\"\" Deactivates the currently active IME engine on the device. Android only . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . DEACTIVATE_IME_ENGINE , {} ) return self @ property def active_ime_engine ( self ) : \"\"\" Returns the activity and package of the currently active IME engine(e.g., 'com.android.inputmethod.latin/.LatinIME'). Android only . Returns : str : The activity and package of the currently active IME engine \"\"\" return self . execute ( Command . GET_ACTIVE_IME_ENGINE , {} ) [ ' value ' ] # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . GET_AVAILABLE_IME_ENGINES ] = \\ ( ' GET ' , ' /session/$sessionId/ime/available_engines ' ) self . command_executor . _commands [ Command . IS_IME_ACTIVE ] = \\ ( ' GET ' , ' /session/$sessionId/ime/activated ' ) self . command_executor . _commands [ Command . ACTIVATE_IME_ENGINE ] = \\ ( ' POST ' , ' /session/$sessionId/ime/activate ' ) self . command_executor . _commands [ Command . DEACTIVATE_IME_ENGINE ] = \\ ( ' POST ' , ' /session/$sessionId/ime/deactivate ' ) self . command_executor . _commands [ Command . GET_ACTIVE_IME_ENGINE ] = \\ ( ' GET ' , ' /session/$sessionId/ime/active_engine ' )","title":"IME"},{"location":"reference/appium/webdriver/extensions/ime/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/ime/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/ime/#instance-variables","text":"active_ime_engine Returns the activity and package of the currently active IME engine(e.g., 'com.android.inputmethod.latin/.LatinIME'). Android only. Returns: str: The activity and package of the currently active IME engine application_cache Returns a ApplicationCache Object to interact with the browser app cache available_ime_engines Get the available input methods for an Android device. Package and activity are returned (e.g., ['com.android.inputmethod.latin/.LatinIME']) Android only. Returns: :obj: list of :obj: str : The available input methods for an Android device current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/ime/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/ime/#activate_ime_engine","text":"def activate_ime_engine ( self , engine ) Activates the given IME engine on the device. Android only. Args: engine (str): the package and activity of the IME engine to activate (e.g., 'com.android.inputmethod.latin/.LatinIME') Returns: appium.webdriver.webdriver.WebDriver View Source def activate_ime_engine ( self , engine ) : \"\"\" Activates the given IME engine on the device. Android only . Args : engine ( str ) : the package and activity of the IME engine to activate ( e . g ., ' com.android.inputmethod.latin/.LatinIME ' ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' engine ' : engine } self . execute ( Command . ACTIVATE_IME_ENGINE , data ) return self","title":"activate_ime_engine"},{"location":"reference/appium/webdriver/extensions/ime/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/ime/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/ime/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/ime/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/ime/#deactivate_ime_engine","text":"def deactivate_ime_engine ( self ) Deactivates the currently active IME engine on the device. Android only. Returns: appium.webdriver.webdriver.WebDriver View Source def deactivate_ime_engine ( self ) : \"\"\" Deactivates the currently active IME engine on the device. Android only . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . DEACTIVATE_IME_ENGINE , {} ) return self","title":"deactivate_ime_engine"},{"location":"reference/appium/webdriver/extensions/ime/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/ime/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/ime/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/ime/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/ime/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/ime/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/ime/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/ime/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/ime/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/ime/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/ime/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/ime/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/ime/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/ime/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/ime/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/ime/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/ime/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/ime/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/ime/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/ime/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/ime/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/ime/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/ime/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/ime/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/ime/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/ime/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/ime/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/ime/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/ime/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/ime/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/ime/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/ime/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/ime/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/ime/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/ime/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/ime/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/ime/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/ime/#is_ime_active","text":"def is_ime_active ( self ) Checks whether the device has IME service active. Android only. Returns: bool: True if IME service is active View Source def is_ime_active ( self ) : \"\"\" Checks whether the device has IME service active. Android only . Returns : bool : ` True ` if IME service is active \"\"\" return self . execute ( Command . IS_IME_ACTIVE , {} ) [ ' value ' ]","title":"is_ime_active"},{"location":"reference/appium/webdriver/extensions/ime/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/ime/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/ime/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/ime/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/ime/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/ime/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/ime/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/ime/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/ime/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/ime/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/ime/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/ime/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/ime/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/ime/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/ime/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/ime/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/ime/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/ime/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/keyboard/","text":"Module appium.webdriver.extensions.keyboard View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class Keyboard ( webdriver . Remote ): def hide_keyboard ( self , key_name = None , key = None , strategy = None ): \"\"\"Hides the software keyboard on the device. In iOS, use `key_name` to press a particular key, or `strategy`. In Android, no parameters are used. Args: key_name (:obj:`str`, optional): key to press key (:obj:`str`, optional): strategy (:obj:`str`, optional): strategy for closing the keyboard (e.g., `tapOutside`) \"\"\" data = {} if key_name is not None : data [ 'keyName' ] = key_name elif key is not None : data [ 'key' ] = key elif strategy is None : strategy = 'tapOutside' data [ 'strategy' ] = strategy self . execute ( Command . HIDE_KEYBOARD , data ) return self def is_keyboard_shown ( self ): \"\"\"Attempts to detect whether a software keyboard is present Returns: bool: `True` if keyboard is shown \"\"\" return self . execute ( Command . IS_KEYBOARD_SHOWN )[ 'value' ] def keyevent ( self , keycode , metastate = None ): \"\"\"Sends a keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html. Args: keycode (int): the keycode to be sent to the device metastate (:obj:`int`, optional): meta information about the keycode being sent Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'keycode' : keycode , } if metastate is not None : data [ 'metastate' ] = metastate self . execute ( Command . KEY_EVENT , data ) return self def press_keycode ( self , keycode , metastate = None , flags = None ): \"\"\"Sends a keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html. Args: keycode (int): the keycode to be sent to the device metastate (:obj:`int`, optional): meta information about the keycode being sent flags (:obj:`int`, optional): the set of key event flags Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'keycode' : keycode , } if metastate is not None : data [ 'metastate' ] = metastate if flags is not None : data [ 'flags' ] = flags self . execute ( Command . PRESS_KEYCODE , data ) return self def long_press_keycode ( self , keycode , metastate = None , flags = None ): \"\"\"Sends a long press of keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html. Args: keycode (int): the keycode to be sent to the device metastate (:obj:`int`, optional): meta information about the keycode being sent flags (:obj:`int`, optional): the set of key event flags Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'keycode' : keycode } if metastate is not None : data [ 'metastate' ] = metastate if flags is not None : data [ 'flags' ] = flags self . execute ( Command . LONG_PRESS_KEYCODE , data ) return self # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . HIDE_KEYBOARD ] = \\ ( 'POST' , '/session/$sessionId/appium/device/hide_keyboard' ) self . command_executor . _commands [ Command . IS_KEYBOARD_SHOWN ] = \\ ( 'GET' , '/session/$sessionId/appium/device/is_keyboard_shown' ) self . command_executor . _commands [ Command . KEY_EVENT ] = \\ ( 'POST' , '/session/$sessionId/appium/device/keyevent' ) self . command_executor . _commands [ Command . PRESS_KEYCODE ] = \\ ( 'POST' , '/session/$sessionId/appium/device/press_keycode' ) self . command_executor . _commands [ Command . LONG_PRESS_KEYCODE ] = \\ ( 'POST' , '/session/$sessionId/appium/device/long_press_keycode' ) Classes Keyboard class Keyboard ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Keyboard ( webdriver . Remote ) : def hide_keyboard ( self , key_name = None , key = None , strategy = None ) : \"\"\" Hides the software keyboard on the device. In iOS , use ` key_name ` to press a particular key , or ` strategy `. In Android , no parameters are used . Args : key_name ( : obj :` str `, optional ) : key to press key ( : obj :` str `, optional ) : strategy ( : obj :` str `, optional ) : strategy for closing the keyboard ( e . g ., ` tapOutside ` ) \"\"\" data = {} if key_name is not None : data [ ' keyName ' ] = key_name elif key is not None : data [ ' key ' ] = key elif strategy is None : strategy = ' tapOutside ' data [ ' strategy ' ] = strategy self . execute ( Command . HIDE_KEYBOARD , data ) return self def is_keyboard_shown ( self ) : \"\"\" Attempts to detect whether a software keyboard is present Returns : bool : ` True ` if keyboard is shown \"\"\" return self . execute ( Command . IS_KEYBOARD_SHOWN ) [ ' value ' ] def keyevent ( self , keycode , metastate = None ) : \"\"\" Sends a keycode to the device. Android only . Possible keycodes can be found in http : // developer . android . com / reference / android / view / KeyEvent . html . Args : keycode ( int ) : the keycode to be sent to the device metastate ( : obj :` int `, optional ) : meta information about the keycode being sent Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' keycode ' : keycode , } if metastate is not None : data [ ' metastate ' ] = metastate self . execute ( Command . KEY_EVENT , data ) return self def press_keycode ( self , keycode , metastate = None , flags = None ) : \"\"\" Sends a keycode to the device. Android only . Possible keycodes can be found in http : // developer . android . com / reference / android / view / KeyEvent . html . Args : keycode ( int ) : the keycode to be sent to the device metastate ( : obj :` int `, optional ) : meta information about the keycode being sent flags ( : obj :` int `, optional ) : the set of key event flags Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' keycode ' : keycode , } if metastate is not None : data [ ' metastate ' ] = metastate if flags is not None : data [ ' flags ' ] = flags self . execute ( Command . PRESS_KEYCODE , data ) return self def long_press_keycode ( self , keycode , metastate = None , flags = None ) : \"\"\" Sends a long press of keycode to the device. Android only . Possible keycodes can be found in http : // developer . android . com / reference / android / view / KeyEvent . html . Args : keycode ( int ) : the keycode to be sent to the device metastate ( : obj :` int `, optional ) : meta information about the keycode being sent flags ( : obj :` int `, optional ) : the set of key event flags Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' keycode ' : keycode } if metastate is not None : data [ ' metastate ' ] = metastate if flags is not None : data [ ' flags ' ] = flags self . execute ( Command . LONG_PRESS_KEYCODE , data ) return self # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . HIDE_KEYBOARD ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/hide_keyboard ' ) self . command_executor . _commands [ Command . IS_KEYBOARD_SHOWN ] = \\ ( ' GET ' , ' /session/$sessionId/appium/device/is_keyboard_shown ' ) self . command_executor . _commands [ Command . KEY_EVENT ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/keyevent ' ) self . command_executor . _commands [ Command . PRESS_KEYCODE ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/press_keycode ' ) self . command_executor . _commands [ Command . LONG_PRESS_KEYCODE ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/long_press_keycode ' ) Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } hide_keyboard def hide_keyboard ( self , key_name = None , key = None , strategy = None ) Hides the software keyboard on the device. In iOS, use key_name to press a particular key, or strategy . In Android, no parameters are used. Args: key_name (:obj: str , optional): key to press key (:obj: str , optional): strategy (:obj: str , optional): strategy for closing the keyboard (e.g., tapOutside ) View Source def hide_keyboard ( self , key_name = None , key = None , strategy = None ) : \"\"\" Hides the software keyboard on the device. In iOS , use ` key_name ` to press a particular key , or ` strategy `. In Android , no parameters are used . Args : key_name ( : obj :` str `, optional ) : key to press key ( : obj :` str `, optional ) : strategy ( : obj :` str `, optional ) : strategy for closing the keyboard ( e . g ., ` tapOutside ` ) \"\"\" data = {} if key_name is not None : data [ ' keyName ' ] = key_name elif key is not None : data [ ' key ' ] = key elif strategy is None : strategy = ' tapOutside ' data [ ' strategy ' ] = strategy self . execute ( Command . HIDE_KEYBOARD , data ) return self implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) is_keyboard_shown def is_keyboard_shown ( self ) Attempts to detect whether a software keyboard is present Returns: bool: True if keyboard is shown View Source def is_keyboard_shown ( self ) : \"\"\" Attempts to detect whether a software keyboard is present Returns : bool : ` True ` if keyboard is shown \"\"\" return self . execute ( Command . IS_KEYBOARD_SHOWN ) [ ' value ' ] keyevent def keyevent ( self , keycode , metastate = None ) Sends a keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html. Args: keycode (int): the keycode to be sent to the device metastate (:obj: int , optional): meta information about the keycode being sent Returns: appium.webdriver.webdriver.WebDriver View Source def keyevent ( self , keycode , metastate = None ) : \"\"\" Sends a keycode to the device. Android only . Possible keycodes can be found in http : // developer . android . com / reference / android / view / KeyEvent . html . Args : keycode ( int ) : the keycode to be sent to the device metastate ( : obj :` int `, optional ) : meta information about the keycode being sent Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' keycode ' : keycode , } if metastate is not None : data [ ' metastate ' ] = metastate self . execute ( Command . KEY_EVENT , data ) return self long_press_keycode def long_press_keycode ( self , keycode , metastate = None , flags = None ) Sends a long press of keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html. Args: keycode (int): the keycode to be sent to the device metastate (:obj: int , optional): meta information about the keycode being sent flags (:obj: int , optional): the set of key event flags Returns: appium.webdriver.webdriver.WebDriver View Source def long_press_keycode ( self , keycode , metastate = None , flags = None ) : \"\"\" Sends a long press of keycode to the device. Android only . Possible keycodes can be found in http : // developer . android . com / reference / android / view / KeyEvent . html . Args : keycode ( int ) : the keycode to be sent to the device metastate ( : obj :` int `, optional ) : meta information about the keycode being sent flags ( : obj :` int `, optional ) : the set of key event flags Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' keycode ' : keycode } if metastate is not None : data [ ' metastate ' ] = metastate if flags is not None : data [ ' flags ' ] = flags self . execute ( Command . LONG_PRESS_KEYCODE , data ) return self maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) press_keycode def press_keycode ( self , keycode , metastate = None , flags = None ) Sends a keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html. Args: keycode (int): the keycode to be sent to the device metastate (:obj: int , optional): meta information about the keycode being sent flags (:obj: int , optional): the set of key event flags Returns: appium.webdriver.webdriver.WebDriver View Source def press_keycode ( self , keycode , metastate = None , flags = None ) : \"\"\" Sends a keycode to the device. Android only . Possible keycodes can be found in http : // developer . android . com / reference / android / view / KeyEvent . html . Args : keycode ( int ) : the keycode to be sent to the device metastate ( : obj :` int `, optional ) : meta information about the keycode being sent flags ( : obj :` int `, optional ) : the set of key event flags Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' keycode ' : keycode , } if metastate is not None : data [ ' metastate ' ] = metastate if flags is not None : data [ ' flags ' ] = flags self . execute ( Command . PRESS_KEYCODE , data ) return self quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"Keyboard"},{"location":"reference/appium/webdriver/extensions/keyboard/#module-appiumwebdriverextensionskeyboard","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class Keyboard ( webdriver . Remote ): def hide_keyboard ( self , key_name = None , key = None , strategy = None ): \"\"\"Hides the software keyboard on the device. In iOS, use `key_name` to press a particular key, or `strategy`. In Android, no parameters are used. Args: key_name (:obj:`str`, optional): key to press key (:obj:`str`, optional): strategy (:obj:`str`, optional): strategy for closing the keyboard (e.g., `tapOutside`) \"\"\" data = {} if key_name is not None : data [ 'keyName' ] = key_name elif key is not None : data [ 'key' ] = key elif strategy is None : strategy = 'tapOutside' data [ 'strategy' ] = strategy self . execute ( Command . HIDE_KEYBOARD , data ) return self def is_keyboard_shown ( self ): \"\"\"Attempts to detect whether a software keyboard is present Returns: bool: `True` if keyboard is shown \"\"\" return self . execute ( Command . IS_KEYBOARD_SHOWN )[ 'value' ] def keyevent ( self , keycode , metastate = None ): \"\"\"Sends a keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html. Args: keycode (int): the keycode to be sent to the device metastate (:obj:`int`, optional): meta information about the keycode being sent Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'keycode' : keycode , } if metastate is not None : data [ 'metastate' ] = metastate self . execute ( Command . KEY_EVENT , data ) return self def press_keycode ( self , keycode , metastate = None , flags = None ): \"\"\"Sends a keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html. Args: keycode (int): the keycode to be sent to the device metastate (:obj:`int`, optional): meta information about the keycode being sent flags (:obj:`int`, optional): the set of key event flags Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'keycode' : keycode , } if metastate is not None : data [ 'metastate' ] = metastate if flags is not None : data [ 'flags' ] = flags self . execute ( Command . PRESS_KEYCODE , data ) return self def long_press_keycode ( self , keycode , metastate = None , flags = None ): \"\"\"Sends a long press of keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html. Args: keycode (int): the keycode to be sent to the device metastate (:obj:`int`, optional): meta information about the keycode being sent flags (:obj:`int`, optional): the set of key event flags Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'keycode' : keycode } if metastate is not None : data [ 'metastate' ] = metastate if flags is not None : data [ 'flags' ] = flags self . execute ( Command . LONG_PRESS_KEYCODE , data ) return self # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . HIDE_KEYBOARD ] = \\ ( 'POST' , '/session/$sessionId/appium/device/hide_keyboard' ) self . command_executor . _commands [ Command . IS_KEYBOARD_SHOWN ] = \\ ( 'GET' , '/session/$sessionId/appium/device/is_keyboard_shown' ) self . command_executor . _commands [ Command . KEY_EVENT ] = \\ ( 'POST' , '/session/$sessionId/appium/device/keyevent' ) self . command_executor . _commands [ Command . PRESS_KEYCODE ] = \\ ( 'POST' , '/session/$sessionId/appium/device/press_keycode' ) self . command_executor . _commands [ Command . LONG_PRESS_KEYCODE ] = \\ ( 'POST' , '/session/$sessionId/appium/device/long_press_keycode' )","title":"Module appium.webdriver.extensions.keyboard"},{"location":"reference/appium/webdriver/extensions/keyboard/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/keyboard/#keyboard","text":"class Keyboard ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Keyboard ( webdriver . Remote ) : def hide_keyboard ( self , key_name = None , key = None , strategy = None ) : \"\"\" Hides the software keyboard on the device. In iOS , use ` key_name ` to press a particular key , or ` strategy `. In Android , no parameters are used . Args : key_name ( : obj :` str `, optional ) : key to press key ( : obj :` str `, optional ) : strategy ( : obj :` str `, optional ) : strategy for closing the keyboard ( e . g ., ` tapOutside ` ) \"\"\" data = {} if key_name is not None : data [ ' keyName ' ] = key_name elif key is not None : data [ ' key ' ] = key elif strategy is None : strategy = ' tapOutside ' data [ ' strategy ' ] = strategy self . execute ( Command . HIDE_KEYBOARD , data ) return self def is_keyboard_shown ( self ) : \"\"\" Attempts to detect whether a software keyboard is present Returns : bool : ` True ` if keyboard is shown \"\"\" return self . execute ( Command . IS_KEYBOARD_SHOWN ) [ ' value ' ] def keyevent ( self , keycode , metastate = None ) : \"\"\" Sends a keycode to the device. Android only . Possible keycodes can be found in http : // developer . android . com / reference / android / view / KeyEvent . html . Args : keycode ( int ) : the keycode to be sent to the device metastate ( : obj :` int `, optional ) : meta information about the keycode being sent Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' keycode ' : keycode , } if metastate is not None : data [ ' metastate ' ] = metastate self . execute ( Command . KEY_EVENT , data ) return self def press_keycode ( self , keycode , metastate = None , flags = None ) : \"\"\" Sends a keycode to the device. Android only . Possible keycodes can be found in http : // developer . android . com / reference / android / view / KeyEvent . html . Args : keycode ( int ) : the keycode to be sent to the device metastate ( : obj :` int `, optional ) : meta information about the keycode being sent flags ( : obj :` int `, optional ) : the set of key event flags Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' keycode ' : keycode , } if metastate is not None : data [ ' metastate ' ] = metastate if flags is not None : data [ ' flags ' ] = flags self . execute ( Command . PRESS_KEYCODE , data ) return self def long_press_keycode ( self , keycode , metastate = None , flags = None ) : \"\"\" Sends a long press of keycode to the device. Android only . Possible keycodes can be found in http : // developer . android . com / reference / android / view / KeyEvent . html . Args : keycode ( int ) : the keycode to be sent to the device metastate ( : obj :` int `, optional ) : meta information about the keycode being sent flags ( : obj :` int `, optional ) : the set of key event flags Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' keycode ' : keycode } if metastate is not None : data [ ' metastate ' ] = metastate if flags is not None : data [ ' flags ' ] = flags self . execute ( Command . LONG_PRESS_KEYCODE , data ) return self # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . HIDE_KEYBOARD ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/hide_keyboard ' ) self . command_executor . _commands [ Command . IS_KEYBOARD_SHOWN ] = \\ ( ' GET ' , ' /session/$sessionId/appium/device/is_keyboard_shown ' ) self . command_executor . _commands [ Command . KEY_EVENT ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/keyevent ' ) self . command_executor . _commands [ Command . PRESS_KEYCODE ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/press_keycode ' ) self . command_executor . _commands [ Command . LONG_PRESS_KEYCODE ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/long_press_keycode ' )","title":"Keyboard"},{"location":"reference/appium/webdriver/extensions/keyboard/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/keyboard/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/keyboard/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/keyboard/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/keyboard/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/keyboard/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/keyboard/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/keyboard/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/keyboard/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/keyboard/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/keyboard/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/keyboard/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/keyboard/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/keyboard/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/keyboard/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/keyboard/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/keyboard/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/keyboard/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/keyboard/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/keyboard/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/keyboard/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/keyboard/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/keyboard/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/keyboard/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/keyboard/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/keyboard/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/keyboard/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/keyboard/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/keyboard/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/keyboard/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/keyboard/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/keyboard/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/keyboard/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/keyboard/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/keyboard/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/keyboard/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/keyboard/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/keyboard/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/keyboard/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/keyboard/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/keyboard/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/keyboard/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/keyboard/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/keyboard/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/keyboard/#hide_keyboard","text":"def hide_keyboard ( self , key_name = None , key = None , strategy = None ) Hides the software keyboard on the device. In iOS, use key_name to press a particular key, or strategy . In Android, no parameters are used. Args: key_name (:obj: str , optional): key to press key (:obj: str , optional): strategy (:obj: str , optional): strategy for closing the keyboard (e.g., tapOutside ) View Source def hide_keyboard ( self , key_name = None , key = None , strategy = None ) : \"\"\" Hides the software keyboard on the device. In iOS , use ` key_name ` to press a particular key , or ` strategy `. In Android , no parameters are used . Args : key_name ( : obj :` str `, optional ) : key to press key ( : obj :` str `, optional ) : strategy ( : obj :` str `, optional ) : strategy for closing the keyboard ( e . g ., ` tapOutside ` ) \"\"\" data = {} if key_name is not None : data [ ' keyName ' ] = key_name elif key is not None : data [ ' key ' ] = key elif strategy is None : strategy = ' tapOutside ' data [ ' strategy ' ] = strategy self . execute ( Command . HIDE_KEYBOARD , data ) return self","title":"hide_keyboard"},{"location":"reference/appium/webdriver/extensions/keyboard/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/keyboard/#is_keyboard_shown","text":"def is_keyboard_shown ( self ) Attempts to detect whether a software keyboard is present Returns: bool: True if keyboard is shown View Source def is_keyboard_shown ( self ) : \"\"\" Attempts to detect whether a software keyboard is present Returns : bool : ` True ` if keyboard is shown \"\"\" return self . execute ( Command . IS_KEYBOARD_SHOWN ) [ ' value ' ]","title":"is_keyboard_shown"},{"location":"reference/appium/webdriver/extensions/keyboard/#keyevent","text":"def keyevent ( self , keycode , metastate = None ) Sends a keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html. Args: keycode (int): the keycode to be sent to the device metastate (:obj: int , optional): meta information about the keycode being sent Returns: appium.webdriver.webdriver.WebDriver View Source def keyevent ( self , keycode , metastate = None ) : \"\"\" Sends a keycode to the device. Android only . Possible keycodes can be found in http : // developer . android . com / reference / android / view / KeyEvent . html . Args : keycode ( int ) : the keycode to be sent to the device metastate ( : obj :` int `, optional ) : meta information about the keycode being sent Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' keycode ' : keycode , } if metastate is not None : data [ ' metastate ' ] = metastate self . execute ( Command . KEY_EVENT , data ) return self","title":"keyevent"},{"location":"reference/appium/webdriver/extensions/keyboard/#long_press_keycode","text":"def long_press_keycode ( self , keycode , metastate = None , flags = None ) Sends a long press of keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html. Args: keycode (int): the keycode to be sent to the device metastate (:obj: int , optional): meta information about the keycode being sent flags (:obj: int , optional): the set of key event flags Returns: appium.webdriver.webdriver.WebDriver View Source def long_press_keycode ( self , keycode , metastate = None , flags = None ) : \"\"\" Sends a long press of keycode to the device. Android only . Possible keycodes can be found in http : // developer . android . com / reference / android / view / KeyEvent . html . Args : keycode ( int ) : the keycode to be sent to the device metastate ( : obj :` int `, optional ) : meta information about the keycode being sent flags ( : obj :` int `, optional ) : the set of key event flags Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' keycode ' : keycode } if metastate is not None : data [ ' metastate ' ] = metastate if flags is not None : data [ ' flags ' ] = flags self . execute ( Command . LONG_PRESS_KEYCODE , data ) return self","title":"long_press_keycode"},{"location":"reference/appium/webdriver/extensions/keyboard/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/keyboard/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/keyboard/#press_keycode","text":"def press_keycode ( self , keycode , metastate = None , flags = None ) Sends a keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html. Args: keycode (int): the keycode to be sent to the device metastate (:obj: int , optional): meta information about the keycode being sent flags (:obj: int , optional): the set of key event flags Returns: appium.webdriver.webdriver.WebDriver View Source def press_keycode ( self , keycode , metastate = None , flags = None ) : \"\"\" Sends a keycode to the device. Android only . Possible keycodes can be found in http : // developer . android . com / reference / android / view / KeyEvent . html . Args : keycode ( int ) : the keycode to be sent to the device metastate ( : obj :` int `, optional ) : meta information about the keycode being sent flags ( : obj :` int `, optional ) : the set of key event flags Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' keycode ' : keycode , } if metastate is not None : data [ ' metastate ' ] = metastate if flags is not None : data [ ' flags ' ] = flags self . execute ( Command . PRESS_KEYCODE , data ) return self","title":"press_keycode"},{"location":"reference/appium/webdriver/extensions/keyboard/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/keyboard/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/keyboard/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/keyboard/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/keyboard/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/keyboard/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/keyboard/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/keyboard/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/keyboard/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/keyboard/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/keyboard/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/keyboard/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/keyboard/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/keyboard/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/keyboard/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/keyboard/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/location/","text":"Module appium.webdriver.extensions.location View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class Location ( webdriver . Remote ): def toggle_location_services ( self ): \"\"\"Toggle the location services on the device. Android only. Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . TOGGLE_LOCATION_SERVICES , {}) return self def set_location ( self , latitude , longitude , altitude = None ): \"\"\"Set the location of the device Args: latitude (Union[float, str]): String or numeric value between -90.0 and 90.00 longitude (Union[float, str]): String or numeric value between -180.0 and 180.0 altitude (Union[float, str], optional): String or numeric value (Android real device only) Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { \"location\" : { \"latitude\" : latitude , \"longitude\" : longitude , } } if altitude is not None : data [ 'location' ][ 'altitude' ] = altitude self . execute ( Command . SET_LOCATION , data ) return self @property def location ( self ): \"\"\"Retrieves the current location Returns: A dictionary whose keys are - latitude (float) - longitude (float) - altitude (float) \"\"\" return self . execute ( Command . GET_LOCATION )[ 'value' ] # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . TOGGLE_LOCATION_SERVICES ] = \\ ( 'POST' , '/session/$sessionId/appium/device/toggle_location_services' ) self . command_executor . _commands [ Command . GET_LOCATION ] = \\ ( 'GET' , '/session/$sessionId/location' ) self . command_executor . _commands [ Command . SET_LOCATION ] = \\ ( 'POST' , '/session/$sessionId/location' ) Classes Location class Location ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Location ( webdriver . Remote ) : def toggle_location_services ( self ) : \"\"\" Toggle the location services on the device. Android only . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . TOGGLE_LOCATION_SERVICES , {} ) return self def set_location ( self , latitude , longitude , altitude = None ) : \"\"\" Set the location of the device Args : latitude ( Union [ float , str ] ) : String or numeric value between - 90 . 0 and 90 . 00 longitude ( Union [ float , str ] ) : String or numeric value between - 180 . 0 and 180 . 0 altitude ( Union [ float , str ], optional ) : String or numeric value ( Android real device only ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { \" location \" : { \" latitude \" : latitude , \" longitude \" : longitude , } } if altitude is not None : data [ ' location ' ][ ' altitude ' ] = altitude self . execute ( Command . SET_LOCATION , data ) return self @ property def location ( self ) : \"\"\" Retrieves the current location Returns : A dictionary whose keys are - latitude ( float ) - longitude ( float ) - altitude ( float ) \"\"\" return self . execute ( Command . GET_LOCATION ) [ ' value ' ] # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . TOGGLE_LOCATION_SERVICES ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/toggle_location_services ' ) self . command_executor . _commands [ Command . GET_LOCATION ] = \\ ( ' GET ' , ' /session/$sessionId/location ' ) self . command_executor . _commands [ Command . SET_LOCATION ] = \\ ( ' POST ' , ' /session/$sessionId/location ' ) Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector location Retrieves the current location Returns: A dictionary whose keys are - latitude (float) - longitude (float) - altitude (float) log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) set_location def set_location ( self , latitude , longitude , altitude = None ) Set the location of the device Args: latitude (Union[float, str]): String or numeric value between -90.0 and 90.00 longitude (Union[float, str]): String or numeric value between -180.0 and 180.0 altitude (Union[float, str], optional): String or numeric value (Android real device only) Returns: appium.webdriver.webdriver.WebDriver View Source def set_location ( self , latitude , longitude , altitude = None ) : \"\"\" Set the location of the device Args : latitude ( Union [ float , str ] ) : String or numeric value between - 90 . 0 and 90 . 00 longitude ( Union [ float , str ] ) : String or numeric value between - 180 . 0 and 180 . 0 altitude ( Union [ float , str ], optional ) : String or numeric value ( Android real device only ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { \" location \" : { \" latitude \" : latitude , \" longitude \" : longitude , } } if altitude is not None : data [ ' location ' ][ ' altitude ' ] = altitude self . execute ( Command . SET_LOCATION , data ) return self set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name ) toggle_location_services def toggle_location_services ( self ) Toggle the location services on the device. Android only. Returns: appium.webdriver.webdriver.WebDriver View Source def toggle_location_services ( self ) : \"\"\" Toggle the location services on the device. Android only . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . TOGGLE_LOCATION_SERVICES , {} ) return self","title":"Location"},{"location":"reference/appium/webdriver/extensions/location/#module-appiumwebdriverextensionslocation","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class Location ( webdriver . Remote ): def toggle_location_services ( self ): \"\"\"Toggle the location services on the device. Android only. Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . TOGGLE_LOCATION_SERVICES , {}) return self def set_location ( self , latitude , longitude , altitude = None ): \"\"\"Set the location of the device Args: latitude (Union[float, str]): String or numeric value between -90.0 and 90.00 longitude (Union[float, str]): String or numeric value between -180.0 and 180.0 altitude (Union[float, str], optional): String or numeric value (Android real device only) Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { \"location\" : { \"latitude\" : latitude , \"longitude\" : longitude , } } if altitude is not None : data [ 'location' ][ 'altitude' ] = altitude self . execute ( Command . SET_LOCATION , data ) return self @property def location ( self ): \"\"\"Retrieves the current location Returns: A dictionary whose keys are - latitude (float) - longitude (float) - altitude (float) \"\"\" return self . execute ( Command . GET_LOCATION )[ 'value' ] # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . TOGGLE_LOCATION_SERVICES ] = \\ ( 'POST' , '/session/$sessionId/appium/device/toggle_location_services' ) self . command_executor . _commands [ Command . GET_LOCATION ] = \\ ( 'GET' , '/session/$sessionId/location' ) self . command_executor . _commands [ Command . SET_LOCATION ] = \\ ( 'POST' , '/session/$sessionId/location' )","title":"Module appium.webdriver.extensions.location"},{"location":"reference/appium/webdriver/extensions/location/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/location/#location","text":"class Location ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Location ( webdriver . Remote ) : def toggle_location_services ( self ) : \"\"\" Toggle the location services on the device. Android only . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . TOGGLE_LOCATION_SERVICES , {} ) return self def set_location ( self , latitude , longitude , altitude = None ) : \"\"\" Set the location of the device Args : latitude ( Union [ float , str ] ) : String or numeric value between - 90 . 0 and 90 . 00 longitude ( Union [ float , str ] ) : String or numeric value between - 180 . 0 and 180 . 0 altitude ( Union [ float , str ], optional ) : String or numeric value ( Android real device only ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { \" location \" : { \" latitude \" : latitude , \" longitude \" : longitude , } } if altitude is not None : data [ ' location ' ][ ' altitude ' ] = altitude self . execute ( Command . SET_LOCATION , data ) return self @ property def location ( self ) : \"\"\" Retrieves the current location Returns : A dictionary whose keys are - latitude ( float ) - longitude ( float ) - altitude ( float ) \"\"\" return self . execute ( Command . GET_LOCATION ) [ ' value ' ] # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . TOGGLE_LOCATION_SERVICES ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/toggle_location_services ' ) self . command_executor . _commands [ Command . GET_LOCATION ] = \\ ( ' GET ' , ' /session/$sessionId/location ' ) self . command_executor . _commands [ Command . SET_LOCATION ] = \\ ( ' POST ' , ' /session/$sessionId/location ' )","title":"Location"},{"location":"reference/appium/webdriver/extensions/location/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/location/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/location/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector location Retrieves the current location Returns: A dictionary whose keys are - latitude (float) - longitude (float) - altitude (float) log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/location/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/location/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/location/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/location/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/location/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/location/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/location/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/location/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/location/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/location/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/location/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/location/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/location/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/location/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/location/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/location/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/location/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/location/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/location/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/location/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/location/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/location/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/location/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/location/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/location/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/location/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/location/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/location/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/location/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/location/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/location/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/location/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/location/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/location/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/location/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/location/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/location/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/location/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/location/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/location/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/location/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/location/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/location/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/location/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/location/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/location/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/location/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/location/#set_location","text":"def set_location ( self , latitude , longitude , altitude = None ) Set the location of the device Args: latitude (Union[float, str]): String or numeric value between -90.0 and 90.00 longitude (Union[float, str]): String or numeric value between -180.0 and 180.0 altitude (Union[float, str], optional): String or numeric value (Android real device only) Returns: appium.webdriver.webdriver.WebDriver View Source def set_location ( self , latitude , longitude , altitude = None ) : \"\"\" Set the location of the device Args : latitude ( Union [ float , str ] ) : String or numeric value between - 90 . 0 and 90 . 00 longitude ( Union [ float , str ] ) : String or numeric value between - 180 . 0 and 180 . 0 altitude ( Union [ float , str ], optional ) : String or numeric value ( Android real device only ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { \" location \" : { \" latitude \" : latitude , \" longitude \" : longitude , } } if altitude is not None : data [ ' location ' ][ ' altitude ' ] = altitude self . execute ( Command . SET_LOCATION , data ) return self","title":"set_location"},{"location":"reference/appium/webdriver/extensions/location/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/location/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/location/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/location/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/location/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/location/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/location/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/location/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/location/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/location/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/location/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/location/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/location/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/location/#toggle_location_services","text":"def toggle_location_services ( self ) Toggle the location services on the device. Android only. Returns: appium.webdriver.webdriver.WebDriver View Source def toggle_location_services ( self ) : \"\"\" Toggle the location services on the device. Android only . Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . TOGGLE_LOCATION_SERVICES , {} ) return self","title":"toggle_location_services"},{"location":"reference/appium/webdriver/extensions/remote_fs/","text":"Module appium.webdriver.extensions.remote_fs View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import base64 from selenium import webdriver from selenium.common.exceptions import InvalidArgumentException from ..mobilecommand import MobileCommand as Command class RemoteFS ( webdriver . Remote ): def pull_file ( self , path ): \"\"\"Retrieves the file at `path`. Args: path (str): the path to the file on the device Returns: bytes: The file's contents as base64. \"\"\" data = { 'path' : path , } return self . execute ( Command . PULL_FILE , data )[ 'value' ] def pull_folder ( self , path ): \"\"\"Retrieves a folder at `path`. Args: path (str): the path to the folder on the device Returns: bytes: The folder's contents zipped and encoded as Base64. \"\"\" data = { 'path' : path , } return self . execute ( Command . PULL_FOLDER , data )[ 'value' ] def push_file ( self , destination_path , base64data = None , source_path = None ): \"\"\"Puts the data from the file at `source_path`, encoded as Base64, in the file specified as `path`. Specify either `base64data` or `source_path`, if both specified default to `source_path` Args: destination_path (str): the location on the device/simulator where the local file contents should be saved base64data (:obj:`bytes`, optional): file contents, encoded as Base64, to be written to the file on the device/simulator source_path (:obj:`str`, optional): local file path for the file to be loaded on device Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" if source_path is None and base64data is None : raise InvalidArgumentException ( 'Must either pass base64 data or a local file path' ) if source_path is not None : try : with open ( source_path , 'rb' ) as f : data = f . read () except IOError : message = 'source_path {} could not be found. Are you sure the file exists?' . format ( source_path ) raise InvalidArgumentException ( message ) base64data = base64 . b64encode ( data ) . decode ( 'utf-8' ) data = { 'path' : destination_path , 'data' : base64data , } self . execute ( Command . PUSH_FILE , data ) return self # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . PULL_FILE ] = \\ ( 'POST' , '/session/$sessionId/appium/device/pull_file' ) self . command_executor . _commands [ Command . PULL_FOLDER ] = \\ ( 'POST' , '/session/$sessionId/appium/device/pull_folder' ) self . command_executor . _commands [ Command . PUSH_FILE ] = \\ ( 'POST' , '/session/$sessionId/appium/device/push_file' ) Classes RemoteFS class RemoteFS ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class RemoteFS ( webdriver . Remote ) : def pull_file ( self , path ) : \"\"\" Retrieves the file at `path`. Args : path ( str ) : the path to the file on the device Returns : bytes : The file ' s contents as base64. \"\"\" data = { ' path ' : path , } return self . execute ( Command . PULL_FILE , data ) [ ' value ' ] def pull_folder ( self , path ) : \"\"\" Retrieves a folder at `path`. Args : path ( str ) : the path to the folder on the device Returns : bytes : The folder ' s contents zipped and encoded as Base64. \"\"\" data = { ' path ' : path , } return self . execute ( Command . PULL_FOLDER , data ) [ ' value ' ] def push_file ( self , destination_path , base64data = None , source_path = None ) : \"\"\" Puts the data from the file at `source_path`, encoded as Base64, in the file specified as `path`. Specify either ` base64data ` or ` source_path `, if both specified default to ` source_path ` Args : destination_path ( str ) : the location on the device / simulator where the local file contents should be saved base64data ( : obj :` bytes `, optional ) : file contents , encoded as Base64 , to be written to the file on the device / simulator source_path ( : obj :` str `, optional ) : local file path for the file to be loaded on device Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" if source_path is None and base64data is None : raise InvalidArgumentException ( ' Must either pass base64 data or a local file path ' ) if source_path is not None : try : with open ( source_path , ' rb ' ) as f : data = f . read () except IOError : message = ' source_path {} could not be found. Are you sure the file exists? ' . format ( source_path ) raise InvalidArgumentException ( message ) base64data = base64 . b64encode ( data ) . decode ( ' utf-8 ' ) data = { ' path ' : destination_path , ' data ' : base64data , } self . execute ( Command . PUSH_FILE , data ) return self # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . PULL_FILE ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/pull_file ' ) self . command_executor . _commands [ Command . PULL_FOLDER ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/pull_folder ' ) self . command_executor . _commands [ Command . PUSH_FILE ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/push_file ' ) Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) pull_file def pull_file ( self , path ) Retrieves the file at path . Args: path (str): the path to the file on the device Returns: bytes: The file's contents as base64. View Source def pull_file ( self , path ) : \"\"\" Retrieves the file at `path`. Args : path ( str ) : the path to the file on the device Returns : bytes : The file ' s contents as base64. \"\"\" data = { ' path ' : path , } return self . execute ( Command . PULL_FILE , data ) [ ' value ' ] pull_folder def pull_folder ( self , path ) Retrieves a folder at path . Args: path (str): the path to the folder on the device Returns: bytes: The folder's contents zipped and encoded as Base64. View Source def pull_folder ( self , path ) : \"\"\" Retrieves a folder at `path`. Args : path ( str ) : the path to the folder on the device Returns : bytes : The folder ' s contents zipped and encoded as Base64. \"\"\" data = { ' path ' : path , } return self . execute ( Command . PULL_FOLDER , data ) [ ' value ' ] push_file def push_file ( self , destination_path , base64data = None , source_path = None ) Puts the data from the file at source_path , encoded as Base64, in the file specified as path . Specify either base64data or source_path , if both specified default to source_path Args: destination_path (str): the location on the device/simulator where the local file contents should be saved base64data (:obj: bytes , optional): file contents, encoded as Base64, to be written to the file on the device/simulator source_path (:obj: str , optional): local file path for the file to be loaded on device Returns: appium.webdriver.webdriver.WebDriver View Source def push_file ( self , destination_path , base64data = None , source_path = None ) : \"\"\" Puts the data from the file at `source_path`, encoded as Base64, in the file specified as `path`. Specify either ` base64data ` or ` source_path `, if both specified default to ` source_path ` Args : destination_path ( str ) : the location on the device / simulator where the local file contents should be saved base64data ( : obj :` bytes `, optional ) : file contents , encoded as Base64 , to be written to the file on the device / simulator source_path ( : obj :` str `, optional ) : local file path for the file to be loaded on device Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" if source_path is None and base64data is None : raise InvalidArgumentException ( ' Must either pass base64 data or a local file path ' ) if source_path is not None : try : with open ( source_path , ' rb ' ) as f : data = f . read () except IOError : message = ' source_path {} could not be found. Are you sure the file exists? ' . format ( source_path ) raise InvalidArgumentException ( message ) base64data = base64 . b64encode ( data ) . decode ( ' utf-8 ' ) data = { ' path ' : destination_path , ' data ' : base64data , } self . execute ( Command . PUSH_FILE , data ) return self quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"Remote Fs"},{"location":"reference/appium/webdriver/extensions/remote_fs/#module-appiumwebdriverextensionsremote_fs","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import base64 from selenium import webdriver from selenium.common.exceptions import InvalidArgumentException from ..mobilecommand import MobileCommand as Command class RemoteFS ( webdriver . Remote ): def pull_file ( self , path ): \"\"\"Retrieves the file at `path`. Args: path (str): the path to the file on the device Returns: bytes: The file's contents as base64. \"\"\" data = { 'path' : path , } return self . execute ( Command . PULL_FILE , data )[ 'value' ] def pull_folder ( self , path ): \"\"\"Retrieves a folder at `path`. Args: path (str): the path to the folder on the device Returns: bytes: The folder's contents zipped and encoded as Base64. \"\"\" data = { 'path' : path , } return self . execute ( Command . PULL_FOLDER , data )[ 'value' ] def push_file ( self , destination_path , base64data = None , source_path = None ): \"\"\"Puts the data from the file at `source_path`, encoded as Base64, in the file specified as `path`. Specify either `base64data` or `source_path`, if both specified default to `source_path` Args: destination_path (str): the location on the device/simulator where the local file contents should be saved base64data (:obj:`bytes`, optional): file contents, encoded as Base64, to be written to the file on the device/simulator source_path (:obj:`str`, optional): local file path for the file to be loaded on device Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" if source_path is None and base64data is None : raise InvalidArgumentException ( 'Must either pass base64 data or a local file path' ) if source_path is not None : try : with open ( source_path , 'rb' ) as f : data = f . read () except IOError : message = 'source_path {} could not be found. Are you sure the file exists?' . format ( source_path ) raise InvalidArgumentException ( message ) base64data = base64 . b64encode ( data ) . decode ( 'utf-8' ) data = { 'path' : destination_path , 'data' : base64data , } self . execute ( Command . PUSH_FILE , data ) return self # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . PULL_FILE ] = \\ ( 'POST' , '/session/$sessionId/appium/device/pull_file' ) self . command_executor . _commands [ Command . PULL_FOLDER ] = \\ ( 'POST' , '/session/$sessionId/appium/device/pull_folder' ) self . command_executor . _commands [ Command . PUSH_FILE ] = \\ ( 'POST' , '/session/$sessionId/appium/device/push_file' )","title":"Module appium.webdriver.extensions.remote_fs"},{"location":"reference/appium/webdriver/extensions/remote_fs/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/remote_fs/#remotefs","text":"class RemoteFS ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class RemoteFS ( webdriver . Remote ) : def pull_file ( self , path ) : \"\"\" Retrieves the file at `path`. Args : path ( str ) : the path to the file on the device Returns : bytes : The file ' s contents as base64. \"\"\" data = { ' path ' : path , } return self . execute ( Command . PULL_FILE , data ) [ ' value ' ] def pull_folder ( self , path ) : \"\"\" Retrieves a folder at `path`. Args : path ( str ) : the path to the folder on the device Returns : bytes : The folder ' s contents zipped and encoded as Base64. \"\"\" data = { ' path ' : path , } return self . execute ( Command . PULL_FOLDER , data ) [ ' value ' ] def push_file ( self , destination_path , base64data = None , source_path = None ) : \"\"\" Puts the data from the file at `source_path`, encoded as Base64, in the file specified as `path`. Specify either ` base64data ` or ` source_path `, if both specified default to ` source_path ` Args : destination_path ( str ) : the location on the device / simulator where the local file contents should be saved base64data ( : obj :` bytes `, optional ) : file contents , encoded as Base64 , to be written to the file on the device / simulator source_path ( : obj :` str `, optional ) : local file path for the file to be loaded on device Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" if source_path is None and base64data is None : raise InvalidArgumentException ( ' Must either pass base64 data or a local file path ' ) if source_path is not None : try : with open ( source_path , ' rb ' ) as f : data = f . read () except IOError : message = ' source_path {} could not be found. Are you sure the file exists? ' . format ( source_path ) raise InvalidArgumentException ( message ) base64data = base64 . b64encode ( data ) . decode ( ' utf-8 ' ) data = { ' path ' : destination_path , ' data ' : base64data , } self . execute ( Command . PUSH_FILE , data ) return self # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . PULL_FILE ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/pull_file ' ) self . command_executor . _commands [ Command . PULL_FOLDER ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/pull_folder ' ) self . command_executor . _commands [ Command . PUSH_FILE ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/push_file ' )","title":"RemoteFS"},{"location":"reference/appium/webdriver/extensions/remote_fs/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/remote_fs/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/remote_fs/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/remote_fs/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/remote_fs/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/remote_fs/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/remote_fs/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/remote_fs/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/remote_fs/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/remote_fs/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/remote_fs/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/remote_fs/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/remote_fs/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/remote_fs/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/remote_fs/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/remote_fs/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/remote_fs/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/remote_fs/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/remote_fs/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/remote_fs/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/remote_fs/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/remote_fs/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/remote_fs/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/remote_fs/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/remote_fs/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/remote_fs/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/remote_fs/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/remote_fs/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/remote_fs/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/remote_fs/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/remote_fs/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/remote_fs/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/remote_fs/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/remote_fs/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/remote_fs/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/remote_fs/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/remote_fs/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/remote_fs/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/remote_fs/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/remote_fs/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/remote_fs/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/remote_fs/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/remote_fs/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/remote_fs/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/remote_fs/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/remote_fs/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/remote_fs/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/remote_fs/#pull_file","text":"def pull_file ( self , path ) Retrieves the file at path . Args: path (str): the path to the file on the device Returns: bytes: The file's contents as base64. View Source def pull_file ( self , path ) : \"\"\" Retrieves the file at `path`. Args : path ( str ) : the path to the file on the device Returns : bytes : The file ' s contents as base64. \"\"\" data = { ' path ' : path , } return self . execute ( Command . PULL_FILE , data ) [ ' value ' ]","title":"pull_file"},{"location":"reference/appium/webdriver/extensions/remote_fs/#pull_folder","text":"def pull_folder ( self , path ) Retrieves a folder at path . Args: path (str): the path to the folder on the device Returns: bytes: The folder's contents zipped and encoded as Base64. View Source def pull_folder ( self , path ) : \"\"\" Retrieves a folder at `path`. Args : path ( str ) : the path to the folder on the device Returns : bytes : The folder ' s contents zipped and encoded as Base64. \"\"\" data = { ' path ' : path , } return self . execute ( Command . PULL_FOLDER , data ) [ ' value ' ]","title":"pull_folder"},{"location":"reference/appium/webdriver/extensions/remote_fs/#push_file","text":"def push_file ( self , destination_path , base64data = None , source_path = None ) Puts the data from the file at source_path , encoded as Base64, in the file specified as path . Specify either base64data or source_path , if both specified default to source_path Args: destination_path (str): the location on the device/simulator where the local file contents should be saved base64data (:obj: bytes , optional): file contents, encoded as Base64, to be written to the file on the device/simulator source_path (:obj: str , optional): local file path for the file to be loaded on device Returns: appium.webdriver.webdriver.WebDriver View Source def push_file ( self , destination_path , base64data = None , source_path = None ) : \"\"\" Puts the data from the file at `source_path`, encoded as Base64, in the file specified as `path`. Specify either ` base64data ` or ` source_path `, if both specified default to ` source_path ` Args : destination_path ( str ) : the location on the device / simulator where the local file contents should be saved base64data ( : obj :` bytes `, optional ) : file contents , encoded as Base64 , to be written to the file on the device / simulator source_path ( : obj :` str `, optional ) : local file path for the file to be loaded on device Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" if source_path is None and base64data is None : raise InvalidArgumentException ( ' Must either pass base64 data or a local file path ' ) if source_path is not None : try : with open ( source_path , ' rb ' ) as f : data = f . read () except IOError : message = ' source_path {} could not be found. Are you sure the file exists? ' . format ( source_path ) raise InvalidArgumentException ( message ) base64data = base64 . b64encode ( data ) . decode ( ' utf-8 ' ) data = { ' path ' : destination_path , ' data ' : base64data , } self . execute ( Command . PUSH_FILE , data ) return self","title":"push_file"},{"location":"reference/appium/webdriver/extensions/remote_fs/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/remote_fs/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/remote_fs/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/remote_fs/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/remote_fs/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/remote_fs/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/remote_fs/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/remote_fs/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/remote_fs/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/remote_fs/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/remote_fs/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/remote_fs/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/remote_fs/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/remote_fs/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/remote_fs/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/remote_fs/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/screen_record/","text":"Module appium.webdriver.extensions.screen_record View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class ScreenRecord ( webdriver . Remote ): def start_recording_screen ( self , ** options ): \"\"\"Start asynchronous screen recording process. Keyword Args: remotePath (str): The remotePath upload option is the path to the remote location, where the resulting video from the previous screen recording should be uploaded. The following protocols are supported: http/https (multipart), ftp. Missing value (the default setting) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value, but an exception will be thrown if the generated media file is too big to fit into the available process memory. This option only has an effect if there is/was an active screen recording session and forced restart is not enabled (the default setting). user (str): The name of the user for the remote authentication. Only has an effect if both `remotePath` and `password` are set. password (str): The password for the remote authentication. Only has an effect if both `remotePath` and `user` are set. method (str): The HTTP method name ('PUT'/'POST'). PUT method is used by default. Only has an effect if `remotePath` is set. timeLimit (int): The actual time limit of the recorded video in seconds. The default value for both iOS and Android is 180 seconds (3 minutes). The maximum value for Android is 3 minutes. The maximum value for iOS is 10 minutes. forcedRestart (bool): Whether to ignore the result of previous capture and start a new recording immediately (`True` value). By default (`False`) the endpoint will try to catch and return the result of the previous capture if it's still available. bugReport (str): Makes the recorder to display an additional information on the video overlay, such as a timestamp, that is helpful in videos captured to illustrate bugs. This option is only supported since API level 27 (Android P). videoQuality (str): [iOS only] The video encoding quality: 'low', 'medium', 'high', 'photo'. Defaults to 'medium'. videoType (str): [iOS only] The format of the screen capture to be recorded. Available formats: Execute `ffmpeg -codecs` in the terminal to see the list of supported video codecs. 'mjpeg' by default. (Since Appium 1.10.0) videoFps (int): [iOS only] The Frames Per Second rate of the recorded video. Change this value if the resulting video is too slow or too fast. Defaults to 10. This can decrease the resulting file size. videoFilters (str): [iOS only] The FFMPEG video filters to apply. These filters allow to scale, flip, rotate and do many other useful transformations on the source video stream. The format of the property must comply with https://ffmpeg.org/ffmpeg-filters.html. (Since Appium 1.15) videoScale (str): [iOS only] The scaling value to apply. Read https://trac.ffmpeg.org/wiki/Scaling for possible values. No scale is applied by default. If videoFilters are set then the scale setting is effectively ignored. (Since Appium 1.10.0) pixelFormat (str): [iOS only] Output pixel format. Run `ffmpeg -pix_fmts` to list possible values. For Quicktime compatibility, set to \"yuv420p\" along with videoType: \"libx264\". (Since Appium 1.12.0) videoSize (str): [Android only] The video size of the generated media file. The format is WIDTHxHEIGHT. The default value is the device's native display resolution (if supported), 1280x720 if not. For best results, use a size supported by your device's Advanced Video Coding (AVC) encoder. bitRate (int): [Android only] The video bit rate for the video, in megabits per second. The default value is 4. You can increase the bit rate to improve video quality, but doing so results in larger movie files. Returns: bytes: Base-64 encoded content of the recorded media if `stop_recording_screen` isn't called after previous `start_recording_screen`. Otherwise returns an empty string. \"\"\" if 'password' in options : options [ 'pass' ] = options [ 'password' ] del options [ 'password' ] return self . execute ( Command . START_RECORDING_SCREEN , { 'options' : options })[ 'value' ] def stop_recording_screen ( self , ** options ): \"\"\"Gather the output from the previously started screen recording to a media file. Keyword Args: remotePath (str): The remotePath upload option is the path to the remote location, where the resulting video should be uploaded. The following protocols are supported: http/https (multipart), ftp. Missing value (the default setting) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value, but an exception will be thrown if the generated media file is too big to fit into the available process memory. user (str): The name of the user for the remote authentication. Only has an effect if both `remotePath` and `password` are set. password (str): The password for the remote authentication. Only has an effect if both `remotePath` and `user` are set. method (str): The HTTP method name ('PUT'/'POST'). PUT method is used by default. Only has an effect if `remotePath` is set. Returns: bytes: Base-64 encoded content of the recorded media file or an empty string if the file has been successfully uploaded to a remote location (depends on the actual `remotePath` value). \"\"\" if 'password' in options : options [ 'pass' ] = options [ 'password' ] del options [ 'password' ] return self . execute ( Command . STOP_RECORDING_SCREEN , { 'options' : options })[ 'value' ] # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . START_RECORDING_SCREEN ] = \\ ( 'POST' , '/session/$sessionId/appium/start_recording_screen' ) self . command_executor . _commands [ Command . STOP_RECORDING_SCREEN ] = \\ ( 'POST' , '/session/$sessionId/appium/stop_recording_screen' ) Classes ScreenRecord class ScreenRecord ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class ScreenRecord ( webdriver . Remote ) : def start_recording_screen ( self , ** options ) : \"\"\"Start asynchronous screen recording process. Keyword Args : remotePath ( str ) : The remotePath upload option is the path to the remote location , where the resulting video from the previous screen recording should be uploaded . The following protocols are supported : http / https ( multipart ), ftp . Missing value ( the default setting ) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value , but an exception will be thrown if the generated media file is too big to fit into the available process memory . This option only has an effect if there is / was an active screen recording session and forced restart is not enabled ( the default setting ). user ( str ) : The name of the user for the remote authentication . Only has an effect if both ` remotePath ` and ` password ` are set . password ( str ) : The password for the remote authentication . Only has an effect if both ` remotePath ` and ` user ` are set . method ( str ) : The HTTP method name ( ' PUT '/' POST ' ). PUT method is used by default . Only has an effect if ` remotePath ` is set . timeLimit ( int ) : The actual time limit of the recorded video in seconds . The default value for both iOS and Android is 180 seconds ( 3 minutes ). The maximum value for Android is 3 minutes . The maximum value for iOS is 10 minutes . forcedRestart ( bool ) : Whether to ignore the result of previous capture and start a new recording immediately ( ` True ` value ). By default ( ` False ` ) the endpoint will try to catch and return the result of the previous capture if it ' s still available . bugReport ( str ) : Makes the recorder to display an additional information on the video overlay , such as a timestamp , that is helpful in videos captured to illustrate bugs . This option is only supported since API level 27 ( Android P ). videoQuality ( str ) : [ iOS only ] The video encoding quality : ' low ' , ' medium ' , ' high ' , ' photo ' . Defaults to ' medium ' . videoType ( str ) : [ iOS only ] The format of the screen capture to be recorded . Available formats : Execute ` ffmpeg - codecs ` in the terminal to see the list of supported video codecs . ' mjpeg ' by default . ( Since Appium 1.10.0 ) videoFps ( int ) : [ iOS only ] The Frames Per Second rate of the recorded video . Change this value if the resulting video is too slow or too fast . Defaults to 10. This can decrease the resulting file size . videoFilters ( str ) : [ iOS only ] The FFMPEG video filters to apply . These filters allow to scale , flip , rotate and do many other useful transformations on the source video stream . The format of the property must comply with https : //ffmpeg.org/ffmpeg-filters.html. (Since Appium 1.15) videoScale ( str ) : [ iOS only ] The scaling value to apply . Read https : //trac.ffmpeg.org/wiki/Scaling for possible values. No scale is applied by default . If videoFilters are set then the scale setting is effectively ignored . ( Since Appium 1.10.0 ) pixelFormat ( str ) : [ iOS only ] Output pixel format . Run ` ffmpeg - pix_fmts ` to list possible values . For Quicktime compatibility , set to \"yuv420p\" along with videoType : \"libx264\" . ( Since Appium 1.12.0 ) videoSize ( str ) : [ Android only ] The video size of the generated media file . The format is WIDTHxHEIGHT . The default value is the device ' s native display resolution ( if supported ), 1280 x720 if not . For best results , use a size supported by your device ' s Advanced Video Coding ( AVC ) encoder . bitRate ( int ) : [ Android only ] The video bit rate for the video , in megabits per second . The default value is 4. You can increase the bit rate to improve video quality , but doing so results in larger movie files . Returns : bytes : Base - 64 encoded content of the recorded media if ` stop_recording_screen ` isn ' t called after previous ` start_recording_screen ` . Otherwise returns an empty string . \"\"\" if ' password ' in options : options [ ' pass ' ] = options [ ' password ' ] del options [ ' password ' ] return self . execute ( Command . START_RECORDING_SCREEN , { ' options ' : options })[ ' value ' ] def stop_recording_screen ( self , ** options ) : \"\"\"Gather the output from the previously started screen recording to a media file. Keyword Args : remotePath ( str ) : The remotePath upload option is the path to the remote location , where the resulting video should be uploaded . The following protocols are supported : http / https ( multipart ), ftp . Missing value ( the default setting ) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value , but an exception will be thrown if the generated media file is too big to fit into the available process memory . user ( str ) : The name of the user for the remote authentication . Only has an effect if both ` remotePath ` and ` password ` are set . password ( str ) : The password for the remote authentication . Only has an effect if both ` remotePath ` and ` user ` are set . method ( str ) : The HTTP method name ( ' PUT '/' POST ' ). PUT method is used by default . Only has an effect if ` remotePath ` is set . Returns : bytes : Base - 64 encoded content of the recorded media file or an empty string if the file has been successfully uploaded to a remote location ( depends on the actual ` remotePath ` value ). \"\"\" if ' password ' in options : options [ ' pass ' ] = options [ ' password ' ] del options [ ' password ' ] return self . execute ( Command . STOP_RECORDING_SCREEN , { ' options ' : options })[ ' value ' ] # pylint: disable=protected-access def _addCommands ( self ) : self . command_executor . _commands [ Command . START_RECORDING_SCREEN ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / start_recording_screen ' ) self . command_executor . _commands [ Command . STOP_RECORDING_SCREEN ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / stop_recording_screen ' ) Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_recording_screen def start_recording_screen ( self , ** options ) Start asynchronous screen recording process. Keyword Args: remotePath (str): The remotePath upload option is the path to the remote location, where the resulting video from the previous screen recording should be uploaded. The following protocols are supported: http/https (multipart), ftp. Missing value (the default setting) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value, but an exception will be thrown if the generated media file is too big to fit into the available process memory. This option only has an effect if there is/was an active screen recording session and forced restart is not enabled (the default setting). user (str): The name of the user for the remote authentication. Only has an effect if both remotePath and password are set. password (str): The password for the remote authentication. Only has an effect if both remotePath and user are set. method (str): The HTTP method name ('PUT'/'POST'). PUT method is used by default. Only has an effect if remotePath is set. timeLimit (int): The actual time limit of the recorded video in seconds. The default value for both iOS and Android is 180 seconds (3 minutes). The maximum value for Android is 3 minutes. The maximum value for iOS is 10 minutes. forcedRestart (bool): Whether to ignore the result of previous capture and start a new recording immediately ( True value). By default ( False ) the endpoint will try to catch and return the result of the previous capture if it's still available. bugReport (str): Makes the recorder to display an additional information on the video overlay, such as a timestamp, that is helpful in videos captured to illustrate bugs. This option is only supported since API level 27 (Android P). videoQuality ( str ) : [ iOS only ] The video encoding quality : ' low ' , ' medium ' , ' high ' , ' photo ' . Defaults to ' medium ' . videoType ( str ) : [ iOS only ] The format of the screen capture to be recorded . Available formats : Execute ` ffmpeg - codecs ` in the terminal to see the list of supported video codecs . ' mjpeg ' by default . ( Since Appium 1.10.0 ) videoFps ( int ) : [ iOS only ] The Frames Per Second rate of the recorded video . Change this value if the resulting video is too slow or too fast . Defaults to 10. This can decrease the resulting file size . videoFilters ( str ) : [ iOS only ] The FFMPEG video filters to apply . These filters allow to scale , flip , rotate and do many other useful transformations on the source video stream . The format of the property must comply with https : //ffmpeg.org/ffmpeg-filters.html. (Since Appium 1.15) videoScale ( str ) : [ iOS only ] The scaling value to apply . Read https : //trac.ffmpeg.org/wiki/Scaling for possible values. No scale is applied by default . If videoFilters are set then the scale setting is effectively ignored . ( Since Appium 1.10.0 ) pixelFormat ( str ) : [ iOS only ] Output pixel format . Run ` ffmpeg - pix_fmts ` to list possible values . For Quicktime compatibility , set to \"yuv420p\" along with videoType : \"libx264\" . ( Since Appium 1.12.0 ) videoSize ( str ) : [ Android only ] The video size of the generated media file . The format is WIDTHxHEIGHT . The default value is the device ' s native display resolution ( if supported ), 1280 x720 if not . For best results , use a size supported by your device ' s Advanced Video Coding ( AVC ) encoder . bitRate ( int ) : [ Android only ] The video bit rate for the video , in megabits per second . The default value is 4. You can increase the bit rate to improve video quality , but doing so results in larger movie files . Returns: bytes: Base-64 encoded content of the recorded media if stop_recording_screen isn't called after previous start_recording_screen . Otherwise returns an empty string. View Source def start_recording_screen ( self , ** options ) : \"\"\"Start asynchronous screen recording process. Keyword Args : remotePath ( str ) : The remotePath upload option is the path to the remote location , where the resulting video from the previous screen recording should be uploaded . The following protocols are supported : http / https ( multipart ), ftp . Missing value ( the default setting ) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value , but an exception will be thrown if the generated media file is too big to fit into the available process memory . This option only has an effect if there is / was an active screen recording session and forced restart is not enabled ( the default setting ). user ( str ) : The name of the user for the remote authentication . Only has an effect if both ` remotePath ` and ` password ` are set . password ( str ) : The password for the remote authentication . Only has an effect if both ` remotePath ` and ` user ` are set . method ( str ) : The HTTP method name ( ' PUT '/' POST ' ). PUT method is used by default . Only has an effect if ` remotePath ` is set . timeLimit ( int ) : The actual time limit of the recorded video in seconds . The default value for both iOS and Android is 180 seconds ( 3 minutes ). The maximum value for Android is 3 minutes . The maximum value for iOS is 10 minutes . forcedRestart ( bool ) : Whether to ignore the result of previous capture and start a new recording immediately ( ` True ` value ). By default ( ` False ` ) the endpoint will try to catch and return the result of the previous capture if it ' s still available . bugReport ( str ) : Makes the recorder to display an additional information on the video overlay , such as a timestamp , that is helpful in videos captured to illustrate bugs . This option is only supported since API level 27 ( Android P ). videoQuality ( str ) : [ iOS only ] The video encoding quality : ' low ' , ' medium ' , ' high ' , ' photo ' . Defaults to ' medium ' . videoType ( str ) : [ iOS only ] The format of the screen capture to be recorded . Available formats : Execute ` ffmpeg - codecs ` in the terminal to see the list of supported video codecs . ' mjpeg ' by default . ( Since Appium 1.10.0 ) videoFps ( int ) : [ iOS only ] The Frames Per Second rate of the recorded video . Change this value if the resulting video is too slow or too fast . Defaults to 10. This can decrease the resulting file size . videoFilters ( str ) : [ iOS only ] The FFMPEG video filters to apply . These filters allow to scale , flip , rotate and do many other useful transformations on the source video stream . The format of the property must comply with https : //ffmpeg.org/ffmpeg-filters.html. (Since Appium 1.15) videoScale ( str ) : [ iOS only ] The scaling value to apply . Read https : //trac.ffmpeg.org/wiki/Scaling for possible values. No scale is applied by default . If videoFilters are set then the scale setting is effectively ignored . ( Since Appium 1.10.0 ) pixelFormat ( str ) : [ iOS only ] Output pixel format . Run ` ffmpeg - pix_fmts ` to list possible values . For Quicktime compatibility , set to \"yuv420p\" along with videoType : \"libx264\" . ( Since Appium 1.12.0 ) videoSize ( str ) : [ Android only ] The video size of the generated media file . The format is WIDTHxHEIGHT . The default value is the device ' s native display resolution ( if supported ), 1280 x720 if not . For best results , use a size supported by your device ' s Advanced Video Coding ( AVC ) encoder . bitRate ( int ) : [ Android only ] The video bit rate for the video , in megabits per second . The default value is 4. You can increase the bit rate to improve video quality , but doing so results in larger movie files . Returns : bytes : Base - 64 encoded content of the recorded media if ` stop_recording_screen ` isn ' t called after previous ` start_recording_screen ` . Otherwise returns an empty string . \"\"\" if ' password ' in options : options [ ' pass ' ] = options [ ' password ' ] del options [ ' password ' ] return self . execute ( Command . START_RECORDING_SCREEN , { ' options ' : options })[ ' value ' ] start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass stop_recording_screen def stop_recording_screen ( self , ** options ) Gather the output from the previously started screen recording to a media file. Keyword Args: remotePath (str): The remotePath upload option is the path to the remote location, where the resulting video should be uploaded. The following protocols are supported: http/https (multipart), ftp. Missing value (the default setting) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value, but an exception will be thrown if the generated media file is too big to fit into the available process memory. user (str): The name of the user for the remote authentication. Only has an effect if both remotePath and password are set. password (str): The password for the remote authentication. Only has an effect if both remotePath and user are set. method (str): The HTTP method name ('PUT'/'POST'). PUT method is used by default. Only has an effect if remotePath is set. Returns: bytes: Base-64 encoded content of the recorded media file or an empty string if the file has been successfully uploaded to a remote location (depends on the actual remotePath value). View Source def stop_recording_screen ( self , ** options ) : \"\"\" Gather the output from the previously started screen recording to a media file. Keyword Args : remotePath ( str ) : The remotePath upload option is the path to the remote location , where the resulting video should be uploaded . The following protocols are supported : http / https ( multipart ) , ftp . Missing value ( the default setting ) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value , but an exception will be thrown if the generated media file is too big to fit into the available process memory . user ( str ) : The name of the user for the remote authentication . Only has an effect if both ` remotePath ` and ` password ` are set . password ( str ) : The password for the remote authentication . Only has an effect if both ` remotePath ` and ` user ` are set . method ( str ) : The HTTP method name ( ' PUT ' / ' POST ' ) . PUT method is used by default . Only has an effect if ` remotePath ` is set . Returns : bytes : Base - 64 encoded content of the recorded media file or an empty string if the file has been successfully uploaded to a remote location ( depends on the actual ` remotePath ` value ) . \"\"\" if ' password ' in options : options [ ' pass ' ] = options [ ' password ' ] del options [ ' password ' ] return self . execute ( Command . STOP_RECORDING_SCREEN , { ' options ' : options } ) [ ' value ' ] switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"Screen Record"},{"location":"reference/appium/webdriver/extensions/screen_record/#module-appiumwebdriverextensionsscreen_record","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class ScreenRecord ( webdriver . Remote ): def start_recording_screen ( self , ** options ): \"\"\"Start asynchronous screen recording process. Keyword Args: remotePath (str): The remotePath upload option is the path to the remote location, where the resulting video from the previous screen recording should be uploaded. The following protocols are supported: http/https (multipart), ftp. Missing value (the default setting) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value, but an exception will be thrown if the generated media file is too big to fit into the available process memory. This option only has an effect if there is/was an active screen recording session and forced restart is not enabled (the default setting). user (str): The name of the user for the remote authentication. Only has an effect if both `remotePath` and `password` are set. password (str): The password for the remote authentication. Only has an effect if both `remotePath` and `user` are set. method (str): The HTTP method name ('PUT'/'POST'). PUT method is used by default. Only has an effect if `remotePath` is set. timeLimit (int): The actual time limit of the recorded video in seconds. The default value for both iOS and Android is 180 seconds (3 minutes). The maximum value for Android is 3 minutes. The maximum value for iOS is 10 minutes. forcedRestart (bool): Whether to ignore the result of previous capture and start a new recording immediately (`True` value). By default (`False`) the endpoint will try to catch and return the result of the previous capture if it's still available. bugReport (str): Makes the recorder to display an additional information on the video overlay, such as a timestamp, that is helpful in videos captured to illustrate bugs. This option is only supported since API level 27 (Android P). videoQuality (str): [iOS only] The video encoding quality: 'low', 'medium', 'high', 'photo'. Defaults to 'medium'. videoType (str): [iOS only] The format of the screen capture to be recorded. Available formats: Execute `ffmpeg -codecs` in the terminal to see the list of supported video codecs. 'mjpeg' by default. (Since Appium 1.10.0) videoFps (int): [iOS only] The Frames Per Second rate of the recorded video. Change this value if the resulting video is too slow or too fast. Defaults to 10. This can decrease the resulting file size. videoFilters (str): [iOS only] The FFMPEG video filters to apply. These filters allow to scale, flip, rotate and do many other useful transformations on the source video stream. The format of the property must comply with https://ffmpeg.org/ffmpeg-filters.html. (Since Appium 1.15) videoScale (str): [iOS only] The scaling value to apply. Read https://trac.ffmpeg.org/wiki/Scaling for possible values. No scale is applied by default. If videoFilters are set then the scale setting is effectively ignored. (Since Appium 1.10.0) pixelFormat (str): [iOS only] Output pixel format. Run `ffmpeg -pix_fmts` to list possible values. For Quicktime compatibility, set to \"yuv420p\" along with videoType: \"libx264\". (Since Appium 1.12.0) videoSize (str): [Android only] The video size of the generated media file. The format is WIDTHxHEIGHT. The default value is the device's native display resolution (if supported), 1280x720 if not. For best results, use a size supported by your device's Advanced Video Coding (AVC) encoder. bitRate (int): [Android only] The video bit rate for the video, in megabits per second. The default value is 4. You can increase the bit rate to improve video quality, but doing so results in larger movie files. Returns: bytes: Base-64 encoded content of the recorded media if `stop_recording_screen` isn't called after previous `start_recording_screen`. Otherwise returns an empty string. \"\"\" if 'password' in options : options [ 'pass' ] = options [ 'password' ] del options [ 'password' ] return self . execute ( Command . START_RECORDING_SCREEN , { 'options' : options })[ 'value' ] def stop_recording_screen ( self , ** options ): \"\"\"Gather the output from the previously started screen recording to a media file. Keyword Args: remotePath (str): The remotePath upload option is the path to the remote location, where the resulting video should be uploaded. The following protocols are supported: http/https (multipart), ftp. Missing value (the default setting) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value, but an exception will be thrown if the generated media file is too big to fit into the available process memory. user (str): The name of the user for the remote authentication. Only has an effect if both `remotePath` and `password` are set. password (str): The password for the remote authentication. Only has an effect if both `remotePath` and `user` are set. method (str): The HTTP method name ('PUT'/'POST'). PUT method is used by default. Only has an effect if `remotePath` is set. Returns: bytes: Base-64 encoded content of the recorded media file or an empty string if the file has been successfully uploaded to a remote location (depends on the actual `remotePath` value). \"\"\" if 'password' in options : options [ 'pass' ] = options [ 'password' ] del options [ 'password' ] return self . execute ( Command . STOP_RECORDING_SCREEN , { 'options' : options })[ 'value' ] # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . START_RECORDING_SCREEN ] = \\ ( 'POST' , '/session/$sessionId/appium/start_recording_screen' ) self . command_executor . _commands [ Command . STOP_RECORDING_SCREEN ] = \\ ( 'POST' , '/session/$sessionId/appium/stop_recording_screen' )","title":"Module appium.webdriver.extensions.screen_record"},{"location":"reference/appium/webdriver/extensions/screen_record/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/screen_record/#screenrecord","text":"class ScreenRecord ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class ScreenRecord ( webdriver . Remote ) : def start_recording_screen ( self , ** options ) : \"\"\"Start asynchronous screen recording process. Keyword Args : remotePath ( str ) : The remotePath upload option is the path to the remote location , where the resulting video from the previous screen recording should be uploaded . The following protocols are supported : http / https ( multipart ), ftp . Missing value ( the default setting ) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value , but an exception will be thrown if the generated media file is too big to fit into the available process memory . This option only has an effect if there is / was an active screen recording session and forced restart is not enabled ( the default setting ). user ( str ) : The name of the user for the remote authentication . Only has an effect if both ` remotePath ` and ` password ` are set . password ( str ) : The password for the remote authentication . Only has an effect if both ` remotePath ` and ` user ` are set . method ( str ) : The HTTP method name ( ' PUT '/' POST ' ). PUT method is used by default . Only has an effect if ` remotePath ` is set . timeLimit ( int ) : The actual time limit of the recorded video in seconds . The default value for both iOS and Android is 180 seconds ( 3 minutes ). The maximum value for Android is 3 minutes . The maximum value for iOS is 10 minutes . forcedRestart ( bool ) : Whether to ignore the result of previous capture and start a new recording immediately ( ` True ` value ). By default ( ` False ` ) the endpoint will try to catch and return the result of the previous capture if it ' s still available . bugReport ( str ) : Makes the recorder to display an additional information on the video overlay , such as a timestamp , that is helpful in videos captured to illustrate bugs . This option is only supported since API level 27 ( Android P ). videoQuality ( str ) : [ iOS only ] The video encoding quality : ' low ' , ' medium ' , ' high ' , ' photo ' . Defaults to ' medium ' . videoType ( str ) : [ iOS only ] The format of the screen capture to be recorded . Available formats : Execute ` ffmpeg - codecs ` in the terminal to see the list of supported video codecs . ' mjpeg ' by default . ( Since Appium 1.10.0 ) videoFps ( int ) : [ iOS only ] The Frames Per Second rate of the recorded video . Change this value if the resulting video is too slow or too fast . Defaults to 10. This can decrease the resulting file size . videoFilters ( str ) : [ iOS only ] The FFMPEG video filters to apply . These filters allow to scale , flip , rotate and do many other useful transformations on the source video stream . The format of the property must comply with https : //ffmpeg.org/ffmpeg-filters.html. (Since Appium 1.15) videoScale ( str ) : [ iOS only ] The scaling value to apply . Read https : //trac.ffmpeg.org/wiki/Scaling for possible values. No scale is applied by default . If videoFilters are set then the scale setting is effectively ignored . ( Since Appium 1.10.0 ) pixelFormat ( str ) : [ iOS only ] Output pixel format . Run ` ffmpeg - pix_fmts ` to list possible values . For Quicktime compatibility , set to \"yuv420p\" along with videoType : \"libx264\" . ( Since Appium 1.12.0 ) videoSize ( str ) : [ Android only ] The video size of the generated media file . The format is WIDTHxHEIGHT . The default value is the device ' s native display resolution ( if supported ), 1280 x720 if not . For best results , use a size supported by your device ' s Advanced Video Coding ( AVC ) encoder . bitRate ( int ) : [ Android only ] The video bit rate for the video , in megabits per second . The default value is 4. You can increase the bit rate to improve video quality , but doing so results in larger movie files . Returns : bytes : Base - 64 encoded content of the recorded media if ` stop_recording_screen ` isn ' t called after previous ` start_recording_screen ` . Otherwise returns an empty string . \"\"\" if ' password ' in options : options [ ' pass ' ] = options [ ' password ' ] del options [ ' password ' ] return self . execute ( Command . START_RECORDING_SCREEN , { ' options ' : options })[ ' value ' ] def stop_recording_screen ( self , ** options ) : \"\"\"Gather the output from the previously started screen recording to a media file. Keyword Args : remotePath ( str ) : The remotePath upload option is the path to the remote location , where the resulting video should be uploaded . The following protocols are supported : http / https ( multipart ), ftp . Missing value ( the default setting ) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value , but an exception will be thrown if the generated media file is too big to fit into the available process memory . user ( str ) : The name of the user for the remote authentication . Only has an effect if both ` remotePath ` and ` password ` are set . password ( str ) : The password for the remote authentication . Only has an effect if both ` remotePath ` and ` user ` are set . method ( str ) : The HTTP method name ( ' PUT '/' POST ' ). PUT method is used by default . Only has an effect if ` remotePath ` is set . Returns : bytes : Base - 64 encoded content of the recorded media file or an empty string if the file has been successfully uploaded to a remote location ( depends on the actual ` remotePath ` value ). \"\"\" if ' password ' in options : options [ ' pass ' ] = options [ ' password ' ] del options [ ' password ' ] return self . execute ( Command . STOP_RECORDING_SCREEN , { ' options ' : options })[ ' value ' ] # pylint: disable=protected-access def _addCommands ( self ) : self . command_executor . _commands [ Command . START_RECORDING_SCREEN ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / start_recording_screen ' ) self . command_executor . _commands [ Command . STOP_RECORDING_SCREEN ] = \\ ( ' POST ' , ' / session / $ sessionId / appium / stop_recording_screen ' )","title":"ScreenRecord"},{"location":"reference/appium/webdriver/extensions/screen_record/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/screen_record/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/screen_record/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/screen_record/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/screen_record/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/screen_record/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/screen_record/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/screen_record/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/screen_record/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/screen_record/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/screen_record/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/screen_record/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/screen_record/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/screen_record/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/screen_record/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/screen_record/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/screen_record/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/screen_record/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/screen_record/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/screen_record/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/screen_record/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/screen_record/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/screen_record/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/screen_record/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/screen_record/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/screen_record/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/screen_record/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/screen_record/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/screen_record/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/screen_record/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/screen_record/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/screen_record/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/screen_record/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/screen_record/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/screen_record/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/screen_record/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/screen_record/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/screen_record/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/screen_record/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/screen_record/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/screen_record/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/screen_record/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/screen_record/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/screen_record/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/screen_record/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/screen_record/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/screen_record/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/screen_record/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/screen_record/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/screen_record/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/screen_record/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/screen_record/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/screen_record/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/screen_record/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/screen_record/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/screen_record/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/screen_record/#start_recording_screen","text":"def start_recording_screen ( self , ** options ) Start asynchronous screen recording process. Keyword Args: remotePath (str): The remotePath upload option is the path to the remote location, where the resulting video from the previous screen recording should be uploaded. The following protocols are supported: http/https (multipart), ftp. Missing value (the default setting) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value, but an exception will be thrown if the generated media file is too big to fit into the available process memory. This option only has an effect if there is/was an active screen recording session and forced restart is not enabled (the default setting). user (str): The name of the user for the remote authentication. Only has an effect if both remotePath and password are set. password (str): The password for the remote authentication. Only has an effect if both remotePath and user are set. method (str): The HTTP method name ('PUT'/'POST'). PUT method is used by default. Only has an effect if remotePath is set. timeLimit (int): The actual time limit of the recorded video in seconds. The default value for both iOS and Android is 180 seconds (3 minutes). The maximum value for Android is 3 minutes. The maximum value for iOS is 10 minutes. forcedRestart (bool): Whether to ignore the result of previous capture and start a new recording immediately ( True value). By default ( False ) the endpoint will try to catch and return the result of the previous capture if it's still available. bugReport (str): Makes the recorder to display an additional information on the video overlay, such as a timestamp, that is helpful in videos captured to illustrate bugs. This option is only supported since API level 27 (Android P). videoQuality ( str ) : [ iOS only ] The video encoding quality : ' low ' , ' medium ' , ' high ' , ' photo ' . Defaults to ' medium ' . videoType ( str ) : [ iOS only ] The format of the screen capture to be recorded . Available formats : Execute ` ffmpeg - codecs ` in the terminal to see the list of supported video codecs . ' mjpeg ' by default . ( Since Appium 1.10.0 ) videoFps ( int ) : [ iOS only ] The Frames Per Second rate of the recorded video . Change this value if the resulting video is too slow or too fast . Defaults to 10. This can decrease the resulting file size . videoFilters ( str ) : [ iOS only ] The FFMPEG video filters to apply . These filters allow to scale , flip , rotate and do many other useful transformations on the source video stream . The format of the property must comply with https : //ffmpeg.org/ffmpeg-filters.html. (Since Appium 1.15) videoScale ( str ) : [ iOS only ] The scaling value to apply . Read https : //trac.ffmpeg.org/wiki/Scaling for possible values. No scale is applied by default . If videoFilters are set then the scale setting is effectively ignored . ( Since Appium 1.10.0 ) pixelFormat ( str ) : [ iOS only ] Output pixel format . Run ` ffmpeg - pix_fmts ` to list possible values . For Quicktime compatibility , set to \"yuv420p\" along with videoType : \"libx264\" . ( Since Appium 1.12.0 ) videoSize ( str ) : [ Android only ] The video size of the generated media file . The format is WIDTHxHEIGHT . The default value is the device ' s native display resolution ( if supported ), 1280 x720 if not . For best results , use a size supported by your device ' s Advanced Video Coding ( AVC ) encoder . bitRate ( int ) : [ Android only ] The video bit rate for the video , in megabits per second . The default value is 4. You can increase the bit rate to improve video quality , but doing so results in larger movie files . Returns: bytes: Base-64 encoded content of the recorded media if stop_recording_screen isn't called after previous start_recording_screen . Otherwise returns an empty string. View Source def start_recording_screen ( self , ** options ) : \"\"\"Start asynchronous screen recording process. Keyword Args : remotePath ( str ) : The remotePath upload option is the path to the remote location , where the resulting video from the previous screen recording should be uploaded . The following protocols are supported : http / https ( multipart ), ftp . Missing value ( the default setting ) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value , but an exception will be thrown if the generated media file is too big to fit into the available process memory . This option only has an effect if there is / was an active screen recording session and forced restart is not enabled ( the default setting ). user ( str ) : The name of the user for the remote authentication . Only has an effect if both ` remotePath ` and ` password ` are set . password ( str ) : The password for the remote authentication . Only has an effect if both ` remotePath ` and ` user ` are set . method ( str ) : The HTTP method name ( ' PUT '/' POST ' ). PUT method is used by default . Only has an effect if ` remotePath ` is set . timeLimit ( int ) : The actual time limit of the recorded video in seconds . The default value for both iOS and Android is 180 seconds ( 3 minutes ). The maximum value for Android is 3 minutes . The maximum value for iOS is 10 minutes . forcedRestart ( bool ) : Whether to ignore the result of previous capture and start a new recording immediately ( ` True ` value ). By default ( ` False ` ) the endpoint will try to catch and return the result of the previous capture if it ' s still available . bugReport ( str ) : Makes the recorder to display an additional information on the video overlay , such as a timestamp , that is helpful in videos captured to illustrate bugs . This option is only supported since API level 27 ( Android P ). videoQuality ( str ) : [ iOS only ] The video encoding quality : ' low ' , ' medium ' , ' high ' , ' photo ' . Defaults to ' medium ' . videoType ( str ) : [ iOS only ] The format of the screen capture to be recorded . Available formats : Execute ` ffmpeg - codecs ` in the terminal to see the list of supported video codecs . ' mjpeg ' by default . ( Since Appium 1.10.0 ) videoFps ( int ) : [ iOS only ] The Frames Per Second rate of the recorded video . Change this value if the resulting video is too slow or too fast . Defaults to 10. This can decrease the resulting file size . videoFilters ( str ) : [ iOS only ] The FFMPEG video filters to apply . These filters allow to scale , flip , rotate and do many other useful transformations on the source video stream . The format of the property must comply with https : //ffmpeg.org/ffmpeg-filters.html. (Since Appium 1.15) videoScale ( str ) : [ iOS only ] The scaling value to apply . Read https : //trac.ffmpeg.org/wiki/Scaling for possible values. No scale is applied by default . If videoFilters are set then the scale setting is effectively ignored . ( Since Appium 1.10.0 ) pixelFormat ( str ) : [ iOS only ] Output pixel format . Run ` ffmpeg - pix_fmts ` to list possible values . For Quicktime compatibility , set to \"yuv420p\" along with videoType : \"libx264\" . ( Since Appium 1.12.0 ) videoSize ( str ) : [ Android only ] The video size of the generated media file . The format is WIDTHxHEIGHT . The default value is the device ' s native display resolution ( if supported ), 1280 x720 if not . For best results , use a size supported by your device ' s Advanced Video Coding ( AVC ) encoder . bitRate ( int ) : [ Android only ] The video bit rate for the video , in megabits per second . The default value is 4. You can increase the bit rate to improve video quality , but doing so results in larger movie files . Returns : bytes : Base - 64 encoded content of the recorded media if ` stop_recording_screen ` isn ' t called after previous ` start_recording_screen ` . Otherwise returns an empty string . \"\"\" if ' password ' in options : options [ ' pass ' ] = options [ ' password ' ] del options [ ' password ' ] return self . execute ( Command . START_RECORDING_SCREEN , { ' options ' : options })[ ' value ' ]","title":"start_recording_screen"},{"location":"reference/appium/webdriver/extensions/screen_record/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/screen_record/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/screen_record/#stop_recording_screen","text":"def stop_recording_screen ( self , ** options ) Gather the output from the previously started screen recording to a media file. Keyword Args: remotePath (str): The remotePath upload option is the path to the remote location, where the resulting video should be uploaded. The following protocols are supported: http/https (multipart), ftp. Missing value (the default setting) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value, but an exception will be thrown if the generated media file is too big to fit into the available process memory. user (str): The name of the user for the remote authentication. Only has an effect if both remotePath and password are set. password (str): The password for the remote authentication. Only has an effect if both remotePath and user are set. method (str): The HTTP method name ('PUT'/'POST'). PUT method is used by default. Only has an effect if remotePath is set. Returns: bytes: Base-64 encoded content of the recorded media file or an empty string if the file has been successfully uploaded to a remote location (depends on the actual remotePath value). View Source def stop_recording_screen ( self , ** options ) : \"\"\" Gather the output from the previously started screen recording to a media file. Keyword Args : remotePath ( str ) : The remotePath upload option is the path to the remote location , where the resulting video should be uploaded . The following protocols are supported : http / https ( multipart ) , ftp . Missing value ( the default setting ) means the content of the resulting file should be encoded as Base64 and passed as the endpoint response value , but an exception will be thrown if the generated media file is too big to fit into the available process memory . user ( str ) : The name of the user for the remote authentication . Only has an effect if both ` remotePath ` and ` password ` are set . password ( str ) : The password for the remote authentication . Only has an effect if both ` remotePath ` and ` user ` are set . method ( str ) : The HTTP method name ( ' PUT ' / ' POST ' ) . PUT method is used by default . Only has an effect if ` remotePath ` is set . Returns : bytes : Base - 64 encoded content of the recorded media file or an empty string if the file has been successfully uploaded to a remote location ( depends on the actual ` remotePath ` value ) . \"\"\" if ' password ' in options : options [ ' pass ' ] = options [ ' password ' ] del options [ ' password ' ] return self . execute ( Command . STOP_RECORDING_SCREEN , { ' options ' : options } ) [ ' value ' ]","title":"stop_recording_screen"},{"location":"reference/appium/webdriver/extensions/screen_record/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/screen_record/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/screen_record/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/screen_record/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/screen_record/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/search_context/","text":"Module appium.webdriver.extensions.search_context View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # pylint: disable=abstract-method import json from selenium import webdriver from selenium.webdriver.remote.webelement import \\ WebElement as SeleniumWebElement from appium.webdriver.common.mobileby import MobileBy class BaseSearchContext ( object ): \"\"\"Used by each search context. Dummy find_element/s are for preventing pylint error\"\"\" def find_element ( self , by = None , value = None ): raise NotImplementedError def find_elements ( self , by = None , value = None ): raise NotImplementedError class AndroidSearchContext ( BaseSearchContext ): \"\"\"Define search context for Android\"\"\" def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ): \"\"\"Finds element by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [Espresso Driver](https://github.com/appium/appium-espresso-driver). Args: name (:obj:`str`, optional): The name of a method to invoke. The method must return a Hamcrest [Matcher](http://hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args (:obj:`str`, optional): The args provided to the method className (:obj:`str`, optional): The class name that the method is part of (defaults to `org.hamcrest.Matchers`). Can be fully qualified, or simple, and simple defaults to `androidx.test.espresso.matcher` package (e.g.: `class=CursorMatchers` fully qualified is `class=androidx.test.espresso.matcher.CursorMatchers` Returns: `appium.webdriver.webelement.WebElement`: The found element Raises: TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage: driver.find_element_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) \"\"\" return self . find_element ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) ) def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ): \"\"\"Finds elements by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [Espresso Driver](https://github.com/appium/appium-espresso-driver). Args: name (:obj:`str`, optional): The name of a method to invoke. The method must return a Hamcrest [Matcher](http://hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args (:obj:`str`, optional): The args provided to the method className (:obj:`str`, optional): The class name that the method is part of (defaults to `org.hamcrest.Matchers`). Can be fully qualified, or simple, and simple defaults to `androidx.test.espresso.matcher` package (e.g.: `class=CursorMatchers` fully qualified is `class=androidx.test.espresso.matcher.CursorMatchers` Returns: `appium.webdriver.webelement.WebElement`: The found elements Usage: driver.find_elements_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) \"\"\" return self . find_elements ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) ) def _build_data_matcher ( self , name = None , args = None , className = None ): result = {} for key , value in { 'name' : name , 'args' : args , 'class' : className } . items (): if value is not None : result [ key ] = value return json . dumps ( result ) class AppiumSearchContext ( webdriver . Remote , AndroidSearchContext ): \"\"\"Returns appium driver search conext\"\"\" class AppiumWebElementSearchContext ( SeleniumWebElement , AndroidSearchContext ): \"\"\"Returns appium web element search context\"\"\" Classes AndroidSearchContext class AndroidSearchContext ( / , * args , ** kwargs ) Define search context for Android View Source class AndroidSearchContext ( BaseSearchContext ) : \"\"\"Define search context for Android\"\"\" def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds element by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found element Raises : TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage : driver . find_element_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_element ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) ) def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds elements by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found elements Usage : driver . find_elements_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_elements ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) ) def _build_data_matcher ( self , name = None , args = None , className = None ) : result = {} for key , value in { ' name ' : name , ' args ' : args , ' class ' : className }. items () : if value is not None : result [ key ] = value return json . dumps ( result ) Ancestors (in MRO) appium.webdriver.extensions.search_context.BaseSearchContext Descendants appium.webdriver.extensions.search_context.AppiumSearchContext appium.webdriver.extensions.search_context.AppiumWebElementSearchContext Methods find_element def find_element ( self , by = None , value = None ) View Source def find_element ( self , by = None , value = None ): raise NotImplementedError find_element_by_android_data_matcher def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) Finds element by onData in Android It works with Espresso Driver . Args: name (:obj: str , optional): The name of a method to invoke. The method must return a Hamcrest Matcher args (:obj: str , optional): The args provided to the method className (:obj: str , optional): The class name that the method is part of (defaults to org.hamcrest.Matchers ). Can be fully qualified, or simple, and simple defaults to androidx.test.espresso.matcher package (e.g.: class=CursorMatchers fully qualified is class=androidx.test.espresso.matcher.CursorMatchers Returns: appium.webdriver.webelement.WebElement : The found element Raises: TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage: driver.find_element_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) View Source def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds element by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found element Raises : TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage : driver . find_element_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_element ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) ) find_elements def find_elements ( self , by = None , value = None ) View Source def find_elements ( self , by = None , value = None ): raise NotImplementedError find_elements_by_android_data_matcher def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) Finds elements by onData in Android It works with Espresso Driver . Args: name (:obj: str , optional): The name of a method to invoke. The method must return a Hamcrest Matcher args (:obj: str , optional): The args provided to the method className (:obj: str , optional): The class name that the method is part of (defaults to org.hamcrest.Matchers ). Can be fully qualified, or simple, and simple defaults to androidx.test.espresso.matcher package (e.g.: class=CursorMatchers fully qualified is class=androidx.test.espresso.matcher.CursorMatchers Returns: appium.webdriver.webelement.WebElement : The found elements Usage: driver.find_elements_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) View Source def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds elements by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found elements Usage : driver . find_elements_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_elements ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) ) AppiumSearchContext class AppiumSearchContext ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Returns appium driver search conext View Source class AppiumSearchContext ( webdriver . Remote , AndroidSearchContext ): \"\"\"Returns appium driver search conext\"\"\" Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver appium.webdriver.extensions.search_context.AndroidSearchContext appium.webdriver.extensions.search_context.BaseSearchContext Descendants appium.webdriver.webdriver.WebDriver Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_android_data_matcher def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) Finds element by onData in Android It works with Espresso Driver . Args: name (:obj: str , optional): The name of a method to invoke. The method must return a Hamcrest Matcher args (:obj: str , optional): The args provided to the method className (:obj: str , optional): The class name that the method is part of (defaults to org.hamcrest.Matchers ). Can be fully qualified, or simple, and simple defaults to androidx.test.espresso.matcher package (e.g.: class=CursorMatchers fully qualified is class=androidx.test.espresso.matcher.CursorMatchers Returns: appium.webdriver.webelement.WebElement : The found element Raises: TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage: driver.find_element_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) View Source def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds element by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found element Raises : TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage : driver . find_element_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_element ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) ) find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_android_data_matcher def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) Finds elements by onData in Android It works with Espresso Driver . Args: name (:obj: str , optional): The name of a method to invoke. The method must return a Hamcrest Matcher args (:obj: str , optional): The args provided to the method className (:obj: str , optional): The class name that the method is part of (defaults to org.hamcrest.Matchers ). Can be fully qualified, or simple, and simple defaults to androidx.test.espresso.matcher package (e.g.: class=CursorMatchers fully qualified is class=androidx.test.espresso.matcher.CursorMatchers Returns: appium.webdriver.webelement.WebElement : The found elements Usage: driver.find_elements_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) View Source def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds elements by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found elements Usage : driver . find_elements_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_elements ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) ) find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name ) AppiumWebElementSearchContext class AppiumWebElementSearchContext ( parent , id_ , w3c = False ) Returns appium web element search context View Source class AppiumWebElementSearchContext ( SeleniumWebElement , AndroidSearchContext ): \"\"\"Returns appium web element search context\"\"\" Ancestors (in MRO) selenium.webdriver.remote.webelement.WebElement appium.webdriver.extensions.search_context.AndroidSearchContext appium.webdriver.extensions.search_context.BaseSearchContext Descendants appium.webdriver.webelement.WebElement Instance variables id Internal ID used by selenium. This is mainly for internal use. Simple use cases such as checking if 2 webelements refer to the same element, can be done using == :: if element1 == element2 : print ( \" These 2 are equal \" ) location The location of the element in the renderable canvas. location_once_scrolled_into_view THIS PROPERTY MAY CHANGE WITHOUT WARNING. Use this to discover where on the screen an element is so that we can click it. This method should cause the element to be scrolled into view. Returns the top lefthand corner location on the screen, or None if the element is not visible. parent Internal reference to the WebDriver instance this element was found from. rect A dictionary with the size and location of the element. screenshot_as_base64 Gets the screenshot of the current element as a base64 encoded string. :Usage: img_b64 = element.screenshot_as_base64 screenshot_as_png Gets the screenshot of the current element as a binary data. :Usage: element_png = element.screenshot_as_png size The size of the element. tag_name This element's tagName property. text The text of the element. Methods clear def clear ( self ) Clears the text if it's a text entry element. View Source def clear ( self ) : \"\"\" Clears the text if it's a text entry element. \"\"\" self . _execute ( Command . CLEAR_ELEMENT ) click def click ( self ) Clicks the element. View Source def click ( self ): \"\"\"Clicks the element.\"\"\" self . _execute ( Command . CLICK_ELEMENT ) find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = element.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = element . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . _w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . _execute ( Command . FIND_CHILD_ELEMENT , { \" using \" : by , \" value \" : value } ) [ ' value ' ] find_element_by_android_data_matcher def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) Finds element by onData in Android It works with Espresso Driver . Args: name (:obj: str , optional): The name of a method to invoke. The method must return a Hamcrest Matcher args (:obj: str , optional): The args provided to the method className (:obj: str , optional): The class name that the method is part of (defaults to org.hamcrest.Matchers ). Can be fully qualified, or simple, and simple defaults to androidx.test.espresso.matcher package (e.g.: class=CursorMatchers fully qualified is class=androidx.test.espresso.matcher.CursorMatchers Returns: appium.webdriver.webelement.WebElement : The found element Raises: TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage: driver.find_element_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) View Source def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds element by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found element Raises : TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage : driver . find_element_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_element ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) ) find_element_by_class_name def find_element_by_class_name ( self , name ) Finds element within this element's children by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds element within this element's children by class name. :Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds element within this element's children by CSS selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds element within this element's children by CSS selector. :Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds element within this element's children by ID. :Args: - id_ - ID of child element to locate. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: foo_element = element.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds element within this element's children by ID. :Args : - id \\ _ - ID of child element to locate . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : foo_element = element . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds element within this element's children by visible link text. :Args: - link_text - Link text string to search for. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds element within this element's children by visible link text. :Args : - link_text - Link text string to search for . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds element within this element's children by name. :Args: - name - name property of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds element within this element's children by name. :Args : - name - name property of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds element within this element's children by partially visible link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds element within this element's children by partially visible link text. :Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds element within this element's children by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds element within this element's children by tag name. :Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds element by xpath. :Args: - xpath - xpath of element to locate. \"//input[@class='myelement']\" Note: The base path will be relative to this element's location. This will select the first link under this element. :: myelement . find_element_by_xpath ( \".//a\" ) However, this will select the first link on the page. :: myelement . find_element_by_xpath ( \"//a\" ) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds element by xpath. :Args : - xpath - xpath of element to locate . \" //input[@class='myelement'] \" Note : The base path will be relative to this element ' s location. This will select the first link under this element . :: myelement . find_element_by_xpath ( \" .//a \" ) However , this will select the first link on the page . :: myelement . find_element_by_xpath ( \" //a \" ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: element = element.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : element = element . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . _w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . _execute ( Command . FIND_CHILD_ELEMENTS , { \" using \" : by , \" value \" : value } ) [ ' value ' ] find_elements_by_android_data_matcher def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) Finds elements by onData in Android It works with Espresso Driver . Args: name (:obj: str , optional): The name of a method to invoke. The method must return a Hamcrest Matcher args (:obj: str , optional): The args provided to the method className (:obj: str , optional): The class name that the method is part of (defaults to org.hamcrest.Matchers ). Can be fully qualified, or simple, and simple defaults to androidx.test.espresso.matcher package (e.g.: class=CursorMatchers fully qualified is class=androidx.test.espresso.matcher.CursorMatchers Returns: appium.webdriver.webelement.WebElement : The found elements Usage: driver.find_elements_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) View Source def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds elements by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found elements Usage : driver . find_elements_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_elements ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) ) find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds a list of elements within this element's children by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = element.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds a list of elements within this element's children by class name. :Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = element . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds a list of elements within this element's children by CSS selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = element.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds a list of elements within this element's children by CSS selector. :Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = element . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds a list of elements within this element's children by ID. Will return a list of webelements if found, or an empty list if not. :Args: - id_ - Id of child element to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = element.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds a list of elements within this element's children by ID. Will return a list of webelements if found , or an empty list if not . : Args : - id \\ _ - Id of child element to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = element . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , link_text ) Finds a list of elements within this element's children by visible link text. :Args: - link_text - Link text string to search for. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = element.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , link_text ) : \"\"\" Finds a list of elements within this element's children by visible link text. :Args : - link_text - Link text string to search for . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = element . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = link_text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds a list of elements within this element's children by name. :Args: - name - name property to search for. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = element.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds a list of elements within this element's children by name. :Args : - name - name property to search for . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = element . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds a list of elements within this element's children by link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = element.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds a list of elements within this element's children by link text. :Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = element . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds a list of elements within this element's children by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = element.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds a list of elements within this element's children by tag name. :Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = element . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds elements within the element by xpath. :Args: - xpath - xpath locator string. Note: The base path will be relative to this element's location. This will select all links under this element. :: myelement . find_elements_by_xpath ( \".//a\" ) However, this will select all links in the page itself. :: myelement . find_elements_by_xpath ( \"//a\" ) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = element.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds elements within the element by xpath. :Args : - xpath - xpath locator string . Note : The base path will be relative to this element ' s location. This will select all links under this element . :: myelement . find_elements_by_xpath ( \" .//a \" ) However , this will select all links in the page itself . :: myelement . find_elements_by_xpath ( \" //a \" ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = element . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) get_attribute def get_attribute ( self , name ) Gets the given attribute or property of the element. This method will first try to return the value of a property with the given name. If a property with that name doesn't exist, it returns the value of the attribute with the same name. If there's no attribute with that name, None is returned. Values which are considered truthy, that is equals \"true\" or \"false\", are returned as booleans. All other non- None values are returned as strings. For attributes or properties which do not exist, None is returned. :Args: - name - Name of the attribute/property to retrieve. Example:: # Check if the \" active \" CSS class is applied to an element . is_active = \" active \" in target_element . get_attribute ( \" class \" ) View Source def get_attribute ( self , name ) : \"\"\" Gets the given attribute or property of the element. This method will first try to return the value of a property with the given name . If a property with that name doesn ' t exist, it returns the value of the attribute with the same name . If there ' s no attribute with that name , `` None `` is returned . Values which are considered truthy , that is equals \" true \" or \" false \" , are returned as booleans . All other non - `` None `` values are returned as strings . For attributes or properties which do not exist , `` None `` is returned . : Args : - name - Name of the attribute / property to retrieve . Example :: # Check if the \" active \" CSS class is applied to an element . is_active = \" active \" in target_element . get_attribute ( \" class \" ) \"\"\" attributeValue = '' if self . _w3c : attributeValue = self . parent . execute_script ( \" return (%s).apply(null, arguments); \" % getAttribute_js , self , name ) else : resp = self . _execute ( Command . GET_ELEMENT_ATTRIBUTE , { ' name ' : name } ) attributeValue = resp . get ( ' value ' ) if attributeValue is not None : if name != ' value ' and attributeValue . lower () in ( ' true ' , ' false ' ) : attributeValue = attributeValue . lower () return attributeValue get_property def get_property ( self , name ) Gets the given property of the element. :Args: - name - Name of the property to retrieve. Example:: text_length = target_element . get_property ( \"text_length\" ) View Source def get_property ( self , name ) : \"\"\" Gets the given property of the element . : Args : - name - Name of the property to retrieve . Example :: text_length = target_element . get_property ( \" text_length \" ) \"\"\" try : return self . _execute ( Command . GET_ELEMENT_PROPERTY , { \" name \" : name } ) [ \" value \" ] except WebDriverException : # if we hit an end point that doesnt understand getElementProperty lets fake it return self . parent . execute_script ( ' return arguments[0][arguments[1]] ' , self , name ) is_displayed def is_displayed ( self ) Whether the element is visible to a user. View Source def is_displayed ( self ) : \"\"\" Whether the element is visible to a user. \"\"\" # Only go into this conditional for browsers that don ' t use the atom themselves if self . _w3c : return self . parent . execute_script ( \" return (%s).apply(null, arguments); \" % isDisplayed_js , self ) else : return self . _execute ( Command . IS_ELEMENT_DISPLAYED ) [ ' value ' ] is_enabled def is_enabled ( self ) Returns whether the element is enabled. View Source def is_enabled ( self ) : \"\"\" Returns whether the element is enabled. \"\"\" return self . _execute ( Command . IS_ELEMENT_ENABLED ) [ ' value ' ] is_selected def is_selected ( self ) Returns whether the element is selected. Can be used to check if a checkbox or radio button is selected. View Source def is_selected ( self ) : \"\"\" Returns whether the element is selected. Can be used to check if a checkbox or radio button is selected . \"\"\" return self . _execute ( Command . IS_ELEMENT_SELECTED ) [ ' value ' ] screenshot def screenshot ( self , filename ) Saves a screenshot of the current element to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: element.screenshot('/Screenshots/foo.png') View Source def screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current element to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : element . screenshot ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . screenshot_as_png try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True send_keys def send_keys ( self , * value ) Simulates typing into the element. :Args: - value - A string for typing, or setting form fields. For setting file inputs, this could be a local file path. Use this to send simple key events or to fill out form fields:: form_textfield = driver . find_element_by_name ( 'username' ) form_textfield . send_keys ( \"admin\" ) This can also be used to set file inputs. :: file_input = driver . find_element_by_name ( ' profilePic ' ) file_input . send_keys ( \" path/to/profilepic.gif \" ) # Generally it ' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \" path/to/profilepic.gif \" )) View Source def send_keys ( self , * value ) : \"\"\" Simulates typing into the element. :Args : - value - A string for typing , or setting form fields . For setting file inputs , this could be a local file path . Use this to send simple key events or to fill out form fields :: form_textfield = driver . find_element_by_name ( ' username ' ) form_textfield . send_keys ( \" admin \" ) This can also be used to set file inputs . :: file_input = driver . find_element_by_name ( ' profilePic ' ) file_input . send_keys ( \" path/to/profilepic.gif \" ) # Generally it ' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \" path/to/profilepic.gif \" )) \"\"\" # transfer file to another machine only if remote driver is used # the same behaviour as for java binding if self . parent . _is_remote : local_file = self . parent . file_detector . is_local_file ( * value ) if local_file is not None : value = self . _upload ( local_file ) self . _execute ( Command . SEND_KEYS_TO_ELEMENT , { ' text ' : \"\" . join ( keys_to_typing ( value )) , ' value ' : keys_to_typing ( value ) } ) submit def submit ( self ) Submits a form. View Source def submit ( self ) : \"\"\" Submits a form. \"\"\" if self . _w3c : form = self . find_element ( By . XPATH , \" ./ancestor-or-self::form \" ) self . _parent . execute_script ( \" var e = arguments[0].ownerDocument.createEvent('Event'); \" \" e.initEvent('submit', true, true); \" \" if (arguments[0].dispatchEvent(e)) { arguments[0].submit() } \" , form ) else : self . _execute ( Command . SUBMIT_ELEMENT ) value_of_css_property def value_of_css_property ( self , property_name ) The value of a CSS property. View Source def value_of_css_property ( self , property_name ) : \"\"\" The value of a CSS property. \"\"\" return self . _execute ( Command . GET_ELEMENT_VALUE_OF_CSS_PROPERTY , { ' propertyName ' : property_name } ) [ ' value ' ] BaseSearchContext class BaseSearchContext ( / , * args , ** kwargs ) Used by each search context. Dummy find_element/s are for preventing pylint error View Source class BaseSearchContext ( object ) : \"\"\" Used by each search context. Dummy find_element/s are for preventing pylint error \"\"\" def find_element ( self , by = None , value = None ) : raise NotImplementedError def find_elements ( self , by = None , value = None ) : raise NotImplementedError Descendants appium.webdriver.extensions.search_context.AndroidSearchContext Methods find_element def find_element ( self , by = None , value = None ) View Source def find_element ( self , by = None , value = None ): raise NotImplementedError find_elements def find_elements ( self , by = None , value = None ) View Source def find_elements ( self , by = None , value = None ): raise NotImplementedError","title":"Search Context"},{"location":"reference/appium/webdriver/extensions/search_context/#module-appiumwebdriverextensionssearch_context","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # pylint: disable=abstract-method import json from selenium import webdriver from selenium.webdriver.remote.webelement import \\ WebElement as SeleniumWebElement from appium.webdriver.common.mobileby import MobileBy class BaseSearchContext ( object ): \"\"\"Used by each search context. Dummy find_element/s are for preventing pylint error\"\"\" def find_element ( self , by = None , value = None ): raise NotImplementedError def find_elements ( self , by = None , value = None ): raise NotImplementedError class AndroidSearchContext ( BaseSearchContext ): \"\"\"Define search context for Android\"\"\" def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ): \"\"\"Finds element by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [Espresso Driver](https://github.com/appium/appium-espresso-driver). Args: name (:obj:`str`, optional): The name of a method to invoke. The method must return a Hamcrest [Matcher](http://hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args (:obj:`str`, optional): The args provided to the method className (:obj:`str`, optional): The class name that the method is part of (defaults to `org.hamcrest.Matchers`). Can be fully qualified, or simple, and simple defaults to `androidx.test.espresso.matcher` package (e.g.: `class=CursorMatchers` fully qualified is `class=androidx.test.espresso.matcher.CursorMatchers` Returns: `appium.webdriver.webelement.WebElement`: The found element Raises: TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage: driver.find_element_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) \"\"\" return self . find_element ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) ) def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ): \"\"\"Finds elements by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [Espresso Driver](https://github.com/appium/appium-espresso-driver). Args: name (:obj:`str`, optional): The name of a method to invoke. The method must return a Hamcrest [Matcher](http://hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args (:obj:`str`, optional): The args provided to the method className (:obj:`str`, optional): The class name that the method is part of (defaults to `org.hamcrest.Matchers`). Can be fully qualified, or simple, and simple defaults to `androidx.test.espresso.matcher` package (e.g.: `class=CursorMatchers` fully qualified is `class=androidx.test.espresso.matcher.CursorMatchers` Returns: `appium.webdriver.webelement.WebElement`: The found elements Usage: driver.find_elements_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) \"\"\" return self . find_elements ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) ) def _build_data_matcher ( self , name = None , args = None , className = None ): result = {} for key , value in { 'name' : name , 'args' : args , 'class' : className } . items (): if value is not None : result [ key ] = value return json . dumps ( result ) class AppiumSearchContext ( webdriver . Remote , AndroidSearchContext ): \"\"\"Returns appium driver search conext\"\"\" class AppiumWebElementSearchContext ( SeleniumWebElement , AndroidSearchContext ): \"\"\"Returns appium web element search context\"\"\"","title":"Module appium.webdriver.extensions.search_context"},{"location":"reference/appium/webdriver/extensions/search_context/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/search_context/#androidsearchcontext","text":"class AndroidSearchContext ( / , * args , ** kwargs ) Define search context for Android View Source class AndroidSearchContext ( BaseSearchContext ) : \"\"\"Define search context for Android\"\"\" def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds element by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found element Raises : TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage : driver . find_element_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_element ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) ) def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds elements by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found elements Usage : driver . find_elements_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_elements ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) ) def _build_data_matcher ( self , name = None , args = None , className = None ) : result = {} for key , value in { ' name ' : name , ' args ' : args , ' class ' : className }. items () : if value is not None : result [ key ] = value return json . dumps ( result )","title":"AndroidSearchContext"},{"location":"reference/appium/webdriver/extensions/search_context/#ancestors-in-mro","text":"appium.webdriver.extensions.search_context.BaseSearchContext","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/search_context/#descendants","text":"appium.webdriver.extensions.search_context.AppiumSearchContext appium.webdriver.extensions.search_context.AppiumWebElementSearchContext","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/search_context/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element","text":"def find_element ( self , by = None , value = None ) View Source def find_element ( self , by = None , value = None ): raise NotImplementedError","title":"find_element"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_by_android_data_matcher","text":"def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) Finds element by onData in Android It works with Espresso Driver . Args: name (:obj: str , optional): The name of a method to invoke. The method must return a Hamcrest Matcher args (:obj: str , optional): The args provided to the method className (:obj: str , optional): The class name that the method is part of (defaults to org.hamcrest.Matchers ). Can be fully qualified, or simple, and simple defaults to androidx.test.espresso.matcher package (e.g.: class=CursorMatchers fully qualified is class=androidx.test.espresso.matcher.CursorMatchers Returns: appium.webdriver.webelement.WebElement : The found element Raises: TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage: driver.find_element_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) View Source def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds element by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found element Raises : TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage : driver . find_element_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_element ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) )","title":"find_element_by_android_data_matcher"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements","text":"def find_elements ( self , by = None , value = None ) View Source def find_elements ( self , by = None , value = None ): raise NotImplementedError","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_by_android_data_matcher","text":"def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) Finds elements by onData in Android It works with Espresso Driver . Args: name (:obj: str , optional): The name of a method to invoke. The method must return a Hamcrest Matcher args (:obj: str , optional): The args provided to the method className (:obj: str , optional): The class name that the method is part of (defaults to org.hamcrest.Matchers ). Can be fully qualified, or simple, and simple defaults to androidx.test.espresso.matcher package (e.g.: class=CursorMatchers fully qualified is class=androidx.test.espresso.matcher.CursorMatchers Returns: appium.webdriver.webelement.WebElement : The found elements Usage: driver.find_elements_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) View Source def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds elements by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found elements Usage : driver . find_elements_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_elements ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) )","title":"find_elements_by_android_data_matcher"},{"location":"reference/appium/webdriver/extensions/search_context/#appiumsearchcontext","text":"class AppiumSearchContext ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Returns appium driver search conext View Source class AppiumSearchContext ( webdriver . Remote , AndroidSearchContext ): \"\"\"Returns appium driver search conext\"\"\"","title":"AppiumSearchContext"},{"location":"reference/appium/webdriver/extensions/search_context/#ancestors-in-mro_1","text":"selenium.webdriver.remote.webdriver.WebDriver appium.webdriver.extensions.search_context.AndroidSearchContext appium.webdriver.extensions.search_context.BaseSearchContext","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/search_context/#descendants_1","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/search_context/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/search_context/#methods_1","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/search_context/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/search_context/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/search_context/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/search_context/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/search_context/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/search_context/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/search_context/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/search_context/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/search_context/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/search_context/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_1","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_by_android_data_matcher_1","text":"def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) Finds element by onData in Android It works with Espresso Driver . Args: name (:obj: str , optional): The name of a method to invoke. The method must return a Hamcrest Matcher args (:obj: str , optional): The args provided to the method className (:obj: str , optional): The class name that the method is part of (defaults to org.hamcrest.Matchers ). Can be fully qualified, or simple, and simple defaults to androidx.test.espresso.matcher package (e.g.: class=CursorMatchers fully qualified is class=androidx.test.espresso.matcher.CursorMatchers Returns: appium.webdriver.webelement.WebElement : The found element Raises: TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage: driver.find_element_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) View Source def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds element by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found element Raises : TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage : driver . find_element_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_element ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) )","title":"find_element_by_android_data_matcher"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_1","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_by_android_data_matcher_1","text":"def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) Finds elements by onData in Android It works with Espresso Driver . Args: name (:obj: str , optional): The name of a method to invoke. The method must return a Hamcrest Matcher args (:obj: str , optional): The args provided to the method className (:obj: str , optional): The class name that the method is part of (defaults to org.hamcrest.Matchers ). Can be fully qualified, or simple, and simple defaults to androidx.test.espresso.matcher package (e.g.: class=CursorMatchers fully qualified is class=androidx.test.espresso.matcher.CursorMatchers Returns: appium.webdriver.webelement.WebElement : The found elements Usage: driver.find_elements_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) View Source def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds elements by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found elements Usage : driver . find_elements_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_elements ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) )","title":"find_elements_by_android_data_matcher"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/search_context/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/search_context/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/search_context/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/search_context/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/search_context/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/search_context/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/search_context/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/search_context/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/search_context/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/search_context/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/search_context/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/search_context/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/search_context/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/search_context/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/search_context/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/search_context/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/search_context/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/search_context/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/search_context/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/search_context/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/search_context/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/search_context/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/search_context/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/search_context/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/search_context/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/search_context/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/search_context/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/search_context/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/search_context/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/search_context/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/search_context/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/search_context/#appiumwebelementsearchcontext","text":"class AppiumWebElementSearchContext ( parent , id_ , w3c = False ) Returns appium web element search context View Source class AppiumWebElementSearchContext ( SeleniumWebElement , AndroidSearchContext ): \"\"\"Returns appium web element search context\"\"\"","title":"AppiumWebElementSearchContext"},{"location":"reference/appium/webdriver/extensions/search_context/#ancestors-in-mro_2","text":"selenium.webdriver.remote.webelement.WebElement appium.webdriver.extensions.search_context.AndroidSearchContext appium.webdriver.extensions.search_context.BaseSearchContext","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/search_context/#descendants_2","text":"appium.webdriver.webelement.WebElement","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/search_context/#instance-variables_1","text":"id Internal ID used by selenium. This is mainly for internal use. Simple use cases such as checking if 2 webelements refer to the same element, can be done using == :: if element1 == element2 : print ( \" These 2 are equal \" ) location The location of the element in the renderable canvas. location_once_scrolled_into_view THIS PROPERTY MAY CHANGE WITHOUT WARNING. Use this to discover where on the screen an element is so that we can click it. This method should cause the element to be scrolled into view. Returns the top lefthand corner location on the screen, or None if the element is not visible. parent Internal reference to the WebDriver instance this element was found from. rect A dictionary with the size and location of the element. screenshot_as_base64 Gets the screenshot of the current element as a base64 encoded string. :Usage: img_b64 = element.screenshot_as_base64 screenshot_as_png Gets the screenshot of the current element as a binary data. :Usage: element_png = element.screenshot_as_png size The size of the element. tag_name This element's tagName property. text The text of the element.","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/search_context/#methods_2","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/search_context/#clear","text":"def clear ( self ) Clears the text if it's a text entry element. View Source def clear ( self ) : \"\"\" Clears the text if it's a text entry element. \"\"\" self . _execute ( Command . CLEAR_ELEMENT )","title":"clear"},{"location":"reference/appium/webdriver/extensions/search_context/#click","text":"def click ( self ) Clicks the element. View Source def click ( self ): \"\"\"Clicks the element.\"\"\" self . _execute ( Command . CLICK_ELEMENT )","title":"click"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_2","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = element.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = element . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . _w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . _execute ( Command . FIND_CHILD_ELEMENT , { \" using \" : by , \" value \" : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_by_android_data_matcher_2","text":"def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) Finds element by onData in Android It works with Espresso Driver . Args: name (:obj: str , optional): The name of a method to invoke. The method must return a Hamcrest Matcher args (:obj: str , optional): The args provided to the method className (:obj: str , optional): The class name that the method is part of (defaults to org.hamcrest.Matchers ). Can be fully qualified, or simple, and simple defaults to androidx.test.espresso.matcher package (e.g.: class=CursorMatchers fully qualified is class=androidx.test.espresso.matcher.CursorMatchers Returns: appium.webdriver.webelement.WebElement : The found element Raises: TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage: driver.find_element_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) View Source def find_element_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds element by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found element Raises : TypeError - Raises a TypeError if the arguments are not validated for JSON format Usage : driver . find_element_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_element ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) )","title":"find_element_by_android_data_matcher"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_by_class_name_1","text":"def find_element_by_class_name ( self , name ) Finds element within this element's children by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds element within this element's children by class name. :Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_by_css_selector_1","text":"def find_element_by_css_selector ( self , css_selector ) Finds element within this element's children by CSS selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds element within this element's children by CSS selector. :Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_by_id_1","text":"def find_element_by_id ( self , id_ ) Finds element within this element's children by ID. :Args: - id_ - ID of child element to locate. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: foo_element = element.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds element within this element's children by ID. :Args : - id \\ _ - ID of child element to locate . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : foo_element = element . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_by_link_text_1","text":"def find_element_by_link_text ( self , link_text ) Finds element within this element's children by visible link text. :Args: - link_text - Link text string to search for. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds element within this element's children by visible link text. :Args : - link_text - Link text string to search for . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_by_name_1","text":"def find_element_by_name ( self , name ) Finds element within this element's children by name. :Args: - name - name property of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds element within this element's children by name. :Args : - name - name property of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_by_partial_link_text_1","text":"def find_element_by_partial_link_text ( self , link_text ) Finds element within this element's children by partially visible link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds element within this element's children by partially visible link text. :Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_by_tag_name_1","text":"def find_element_by_tag_name ( self , name ) Finds element within this element's children by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds element within this element's children by tag name. :Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_by_xpath_1","text":"def find_element_by_xpath ( self , xpath ) Finds element by xpath. :Args: - xpath - xpath of element to locate. \"//input[@class='myelement']\" Note: The base path will be relative to this element's location. This will select the first link under this element. :: myelement . find_element_by_xpath ( \".//a\" ) However, this will select the first link on the page. :: myelement . find_element_by_xpath ( \"//a\" ) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = element.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds element by xpath. :Args : - xpath - xpath of element to locate . \" //input[@class='myelement'] \" Note : The base path will be relative to this element ' s location. This will select the first link under this element . :: myelement . find_element_by_xpath ( \" .//a \" ) However , this will select the first link on the page . :: myelement . find_element_by_xpath ( \" //a \" ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = element . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_2","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: element = element.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : element = element . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . _w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . _execute ( Command . FIND_CHILD_ELEMENTS , { \" using \" : by , \" value \" : value } ) [ ' value ' ]","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_by_android_data_matcher_2","text":"def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) Finds elements by onData in Android It works with Espresso Driver . Args: name (:obj: str , optional): The name of a method to invoke. The method must return a Hamcrest Matcher args (:obj: str , optional): The args provided to the method className (:obj: str , optional): The class name that the method is part of (defaults to org.hamcrest.Matchers ). Can be fully qualified, or simple, and simple defaults to androidx.test.espresso.matcher package (e.g.: class=CursorMatchers fully qualified is class=androidx.test.espresso.matcher.CursorMatchers Returns: appium.webdriver.webelement.WebElement : The found elements Usage: driver.find_elements_by_android_data_matcher(name='hasEntry', args=['title', 'Animation']) View Source def find_elements_by_android_data_matcher ( self , name = None , args = None , className = None ) : \"\"\"Finds elements by [onData](https://medium.com/androiddevelopers/adapterviews-and-espresso-f4172aa853cf) in Android It works with [ Espresso Driver ]( https : //github.com/appium/appium-espresso-driver). Args : name ( : obj : ` str ` , optional ) : The name of a method to invoke . The method must return a Hamcrest [ Matcher ]( http : //hamcrest.org/JavaHamcrest/javadoc/1.3/org/hamcrest/Matcher.html) args ( : obj : ` str ` , optional ) : The args provided to the method className ( : obj : ` str ` , optional ) : The class name that the method is part of ( defaults to ` org . hamcrest . Matchers ` ). Can be fully qualified , or simple , and simple defaults to ` androidx . test . espresso . matcher ` package ( e . g . : ` class = CursorMatchers ` fully qualified is ` class = androidx . test . espresso . matcher . CursorMatchers ` Returns : ` appium . webdriver . webelement . WebElement ` : The found elements Usage : driver . find_elements_by_android_data_matcher ( name = ' hasEntry ' , args = [ ' title ' , ' Animation ' ]) \"\"\" return self . find_elements ( by = MobileBy . ANDROID_DATA_MATCHER , value = self . _build_data_matcher ( name = name , args = args , className = className ) )","title":"find_elements_by_android_data_matcher"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_by_class_name_1","text":"def find_elements_by_class_name ( self , name ) Finds a list of elements within this element's children by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = element.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds a list of elements within this element's children by class name. :Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = element . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_by_css_selector_1","text":"def find_elements_by_css_selector ( self , css_selector ) Finds a list of elements within this element's children by CSS selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = element.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds a list of elements within this element's children by CSS selector. :Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = element . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_by_id_1","text":"def find_elements_by_id ( self , id_ ) Finds a list of elements within this element's children by ID. Will return a list of webelements if found, or an empty list if not. :Args: - id_ - Id of child element to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = element.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds a list of elements within this element's children by ID. Will return a list of webelements if found , or an empty list if not . : Args : - id \\ _ - Id of child element to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = element . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_by_link_text_1","text":"def find_elements_by_link_text ( self , link_text ) Finds a list of elements within this element's children by visible link text. :Args: - link_text - Link text string to search for. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = element.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , link_text ) : \"\"\" Finds a list of elements within this element's children by visible link text. :Args : - link_text - Link text string to search for . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = element . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = link_text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_by_name_1","text":"def find_elements_by_name ( self , name ) Finds a list of elements within this element's children by name. :Args: - name - name property to search for. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = element.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds a list of elements within this element's children by name. :Args : - name - name property to search for . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = element . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_by_partial_link_text_1","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds a list of elements within this element's children by link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = element.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds a list of elements within this element's children by link text. :Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = element . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_by_tag_name_1","text":"def find_elements_by_tag_name ( self , name ) Finds a list of elements within this element's children by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = element.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds a list of elements within this element's children by tag name. :Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = element . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_by_xpath_1","text":"def find_elements_by_xpath ( self , xpath ) Finds elements within the element by xpath. :Args: - xpath - xpath locator string. Note: The base path will be relative to this element's location. This will select all links under this element. :: myelement . find_elements_by_xpath ( \".//a\" ) However, this will select all links in the page itself. :: myelement . find_elements_by_xpath ( \"//a\" ) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = element.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds elements within the element by xpath. :Args : - xpath - xpath locator string . Note : The base path will be relative to this element ' s location. This will select all links under this element . :: myelement . find_elements_by_xpath ( \" .//a \" ) However , this will select all links in the page itself . :: myelement . find_elements_by_xpath ( \" //a \" ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = element . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/search_context/#get_attribute","text":"def get_attribute ( self , name ) Gets the given attribute or property of the element. This method will first try to return the value of a property with the given name. If a property with that name doesn't exist, it returns the value of the attribute with the same name. If there's no attribute with that name, None is returned. Values which are considered truthy, that is equals \"true\" or \"false\", are returned as booleans. All other non- None values are returned as strings. For attributes or properties which do not exist, None is returned. :Args: - name - Name of the attribute/property to retrieve. Example:: # Check if the \" active \" CSS class is applied to an element . is_active = \" active \" in target_element . get_attribute ( \" class \" ) View Source def get_attribute ( self , name ) : \"\"\" Gets the given attribute or property of the element. This method will first try to return the value of a property with the given name . If a property with that name doesn ' t exist, it returns the value of the attribute with the same name . If there ' s no attribute with that name , `` None `` is returned . Values which are considered truthy , that is equals \" true \" or \" false \" , are returned as booleans . All other non - `` None `` values are returned as strings . For attributes or properties which do not exist , `` None `` is returned . : Args : - name - Name of the attribute / property to retrieve . Example :: # Check if the \" active \" CSS class is applied to an element . is_active = \" active \" in target_element . get_attribute ( \" class \" ) \"\"\" attributeValue = '' if self . _w3c : attributeValue = self . parent . execute_script ( \" return (%s).apply(null, arguments); \" % getAttribute_js , self , name ) else : resp = self . _execute ( Command . GET_ELEMENT_ATTRIBUTE , { ' name ' : name } ) attributeValue = resp . get ( ' value ' ) if attributeValue is not None : if name != ' value ' and attributeValue . lower () in ( ' true ' , ' false ' ) : attributeValue = attributeValue . lower () return attributeValue","title":"get_attribute"},{"location":"reference/appium/webdriver/extensions/search_context/#get_property","text":"def get_property ( self , name ) Gets the given property of the element. :Args: - name - Name of the property to retrieve. Example:: text_length = target_element . get_property ( \"text_length\" ) View Source def get_property ( self , name ) : \"\"\" Gets the given property of the element . : Args : - name - Name of the property to retrieve . Example :: text_length = target_element . get_property ( \" text_length \" ) \"\"\" try : return self . _execute ( Command . GET_ELEMENT_PROPERTY , { \" name \" : name } ) [ \" value \" ] except WebDriverException : # if we hit an end point that doesnt understand getElementProperty lets fake it return self . parent . execute_script ( ' return arguments[0][arguments[1]] ' , self , name )","title":"get_property"},{"location":"reference/appium/webdriver/extensions/search_context/#is_displayed","text":"def is_displayed ( self ) Whether the element is visible to a user. View Source def is_displayed ( self ) : \"\"\" Whether the element is visible to a user. \"\"\" # Only go into this conditional for browsers that don ' t use the atom themselves if self . _w3c : return self . parent . execute_script ( \" return (%s).apply(null, arguments); \" % isDisplayed_js , self ) else : return self . _execute ( Command . IS_ELEMENT_DISPLAYED ) [ ' value ' ]","title":"is_displayed"},{"location":"reference/appium/webdriver/extensions/search_context/#is_enabled","text":"def is_enabled ( self ) Returns whether the element is enabled. View Source def is_enabled ( self ) : \"\"\" Returns whether the element is enabled. \"\"\" return self . _execute ( Command . IS_ELEMENT_ENABLED ) [ ' value ' ]","title":"is_enabled"},{"location":"reference/appium/webdriver/extensions/search_context/#is_selected","text":"def is_selected ( self ) Returns whether the element is selected. Can be used to check if a checkbox or radio button is selected. View Source def is_selected ( self ) : \"\"\" Returns whether the element is selected. Can be used to check if a checkbox or radio button is selected . \"\"\" return self . _execute ( Command . IS_ELEMENT_SELECTED ) [ ' value ' ]","title":"is_selected"},{"location":"reference/appium/webdriver/extensions/search_context/#screenshot","text":"def screenshot ( self , filename ) Saves a screenshot of the current element to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: element.screenshot('/Screenshots/foo.png') View Source def screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current element to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : element . screenshot ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . screenshot_as_png try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"screenshot"},{"location":"reference/appium/webdriver/extensions/search_context/#send_keys","text":"def send_keys ( self , * value ) Simulates typing into the element. :Args: - value - A string for typing, or setting form fields. For setting file inputs, this could be a local file path. Use this to send simple key events or to fill out form fields:: form_textfield = driver . find_element_by_name ( 'username' ) form_textfield . send_keys ( \"admin\" ) This can also be used to set file inputs. :: file_input = driver . find_element_by_name ( ' profilePic ' ) file_input . send_keys ( \" path/to/profilepic.gif \" ) # Generally it ' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \" path/to/profilepic.gif \" )) View Source def send_keys ( self , * value ) : \"\"\" Simulates typing into the element. :Args : - value - A string for typing , or setting form fields . For setting file inputs , this could be a local file path . Use this to send simple key events or to fill out form fields :: form_textfield = driver . find_element_by_name ( ' username ' ) form_textfield . send_keys ( \" admin \" ) This can also be used to set file inputs . :: file_input = driver . find_element_by_name ( ' profilePic ' ) file_input . send_keys ( \" path/to/profilepic.gif \" ) # Generally it ' s better to wrap the file path in one of the methods # in os . path to return the actual path to support cross OS testing . # file_input . send_keys ( os . path . abspath ( \" path/to/profilepic.gif \" )) \"\"\" # transfer file to another machine only if remote driver is used # the same behaviour as for java binding if self . parent . _is_remote : local_file = self . parent . file_detector . is_local_file ( * value ) if local_file is not None : value = self . _upload ( local_file ) self . _execute ( Command . SEND_KEYS_TO_ELEMENT , { ' text ' : \"\" . join ( keys_to_typing ( value )) , ' value ' : keys_to_typing ( value ) } )","title":"send_keys"},{"location":"reference/appium/webdriver/extensions/search_context/#submit","text":"def submit ( self ) Submits a form. View Source def submit ( self ) : \"\"\" Submits a form. \"\"\" if self . _w3c : form = self . find_element ( By . XPATH , \" ./ancestor-or-self::form \" ) self . _parent . execute_script ( \" var e = arguments[0].ownerDocument.createEvent('Event'); \" \" e.initEvent('submit', true, true); \" \" if (arguments[0].dispatchEvent(e)) { arguments[0].submit() } \" , form ) else : self . _execute ( Command . SUBMIT_ELEMENT )","title":"submit"},{"location":"reference/appium/webdriver/extensions/search_context/#value_of_css_property","text":"def value_of_css_property ( self , property_name ) The value of a CSS property. View Source def value_of_css_property ( self , property_name ) : \"\"\" The value of a CSS property. \"\"\" return self . _execute ( Command . GET_ELEMENT_VALUE_OF_CSS_PROPERTY , { ' propertyName ' : property_name } ) [ ' value ' ]","title":"value_of_css_property"},{"location":"reference/appium/webdriver/extensions/search_context/#basesearchcontext","text":"class BaseSearchContext ( / , * args , ** kwargs ) Used by each search context. Dummy find_element/s are for preventing pylint error View Source class BaseSearchContext ( object ) : \"\"\" Used by each search context. Dummy find_element/s are for preventing pylint error \"\"\" def find_element ( self , by = None , value = None ) : raise NotImplementedError def find_elements ( self , by = None , value = None ) : raise NotImplementedError","title":"BaseSearchContext"},{"location":"reference/appium/webdriver/extensions/search_context/#descendants_3","text":"appium.webdriver.extensions.search_context.AndroidSearchContext","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/search_context/#methods_3","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/search_context/#find_element_3","text":"def find_element ( self , by = None , value = None ) View Source def find_element ( self , by = None , value = None ): raise NotImplementedError","title":"find_element"},{"location":"reference/appium/webdriver/extensions/search_context/#find_elements_3","text":"def find_elements ( self , by = None , value = None ) View Source def find_elements ( self , by = None , value = None ): raise NotImplementedError","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/settings/","text":"Module appium.webdriver.extensions.settings View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class Settings ( webdriver . Remote ): def get_settings ( self ): \"\"\"Returns the appium server Settings for the current session. Do not get Settings confused with Desired Capabilities, they are separate concepts. See https://github.com/appium/appium/blob/master/docs/en/advanced-concepts/settings.md Returns: dict: Current settings \"\"\" return self . execute ( Command . GET_SETTINGS , {})[ 'value' ] def update_settings ( self , settings ): \"\"\"Set settings for the current session. For more on settings, see: https://github.com/appium/appium/blob/master/docs/en/advanced-concepts/settings.md Args: settings (dict): dictionary of settings to apply to the current test session \"\"\" data = { \"settings\" : settings } self . execute ( Command . UPDATE_SETTINGS , data ) return self # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . GET_SETTINGS ] = \\ ( 'GET' , '/session/$sessionId/appium/settings' ) self . command_executor . _commands [ Command . UPDATE_SETTINGS ] = \\ ( 'POST' , '/session/$sessionId/appium/settings' ) Classes Settings class Settings ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Settings ( webdriver . Remote ) : def get_settings ( self ) : \"\"\" Returns the appium server Settings for the current session. Do not get Settings confused with Desired Capabilities , they are separate concepts . See https : // github . com / appium / appium / blob / master / docs / en / advanced - concepts / settings . md Returns : dict : Current settings \"\"\" return self . execute ( Command . GET_SETTINGS , {} ) [ ' value ' ] def update_settings ( self , settings ) : \"\"\" Set settings for the current session. For more on settings , see : https : // github . com / appium / appium / blob / master / docs / en / advanced - concepts / settings . md Args : settings ( dict ) : dictionary of settings to apply to the current test session \"\"\" data = { \" settings \" : settings } self . execute ( Command . UPDATE_SETTINGS , data ) return self # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . GET_SETTINGS ] = \\ ( ' GET ' , ' /session/$sessionId/appium/settings ' ) self . command_executor . _commands [ Command . UPDATE_SETTINGS ] = \\ ( ' POST ' , ' /session/$sessionId/appium/settings ' ) Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_settings def get_settings ( self ) Returns the appium server Settings for the current session. Do not get Settings confused with Desired Capabilities, they are separate concepts. See https://github.com/appium/appium/blob/master/docs/en/advanced-concepts/settings.md Returns: dict: Current settings View Source def get_settings ( self ) : \"\"\" Returns the appium server Settings for the current session. Do not get Settings confused with Desired Capabilities , they are separate concepts . See https : // github . com / appium / appium / blob / master / docs / en / advanced - concepts / settings . md Returns : dict : Current settings \"\"\" return self . execute ( Command . GET_SETTINGS , {} ) [ ' value ' ] get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name ) update_settings def update_settings ( self , settings ) Set settings for the current session. For more on settings, see: https://github.com/appium/appium/blob/master/docs/en/advanced-concepts/settings.md Args: settings (dict): dictionary of settings to apply to the current test session View Source def update_settings ( self , settings ) : \"\"\" Set settings for the current session. For more on settings , see : https : // github . com / appium / appium / blob / master / docs / en / advanced - concepts / settings . md Args : settings ( dict ) : dictionary of settings to apply to the current test session \"\"\" data = { \" settings \" : settings } self . execute ( Command . UPDATE_SETTINGS , data ) return self","title":"Settings"},{"location":"reference/appium/webdriver/extensions/settings/#module-appiumwebdriverextensionssettings","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from ..mobilecommand import MobileCommand as Command class Settings ( webdriver . Remote ): def get_settings ( self ): \"\"\"Returns the appium server Settings for the current session. Do not get Settings confused with Desired Capabilities, they are separate concepts. See https://github.com/appium/appium/blob/master/docs/en/advanced-concepts/settings.md Returns: dict: Current settings \"\"\" return self . execute ( Command . GET_SETTINGS , {})[ 'value' ] def update_settings ( self , settings ): \"\"\"Set settings for the current session. For more on settings, see: https://github.com/appium/appium/blob/master/docs/en/advanced-concepts/settings.md Args: settings (dict): dictionary of settings to apply to the current test session \"\"\" data = { \"settings\" : settings } self . execute ( Command . UPDATE_SETTINGS , data ) return self # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . GET_SETTINGS ] = \\ ( 'GET' , '/session/$sessionId/appium/settings' ) self . command_executor . _commands [ Command . UPDATE_SETTINGS ] = \\ ( 'POST' , '/session/$sessionId/appium/settings' )","title":"Module appium.webdriver.extensions.settings"},{"location":"reference/appium/webdriver/extensions/settings/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/settings/#settings","text":"class Settings ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Settings ( webdriver . Remote ) : def get_settings ( self ) : \"\"\" Returns the appium server Settings for the current session. Do not get Settings confused with Desired Capabilities , they are separate concepts . See https : // github . com / appium / appium / blob / master / docs / en / advanced - concepts / settings . md Returns : dict : Current settings \"\"\" return self . execute ( Command . GET_SETTINGS , {} ) [ ' value ' ] def update_settings ( self , settings ) : \"\"\" Set settings for the current session. For more on settings , see : https : // github . com / appium / appium / blob / master / docs / en / advanced - concepts / settings . md Args : settings ( dict ) : dictionary of settings to apply to the current test session \"\"\" data = { \" settings \" : settings } self . execute ( Command . UPDATE_SETTINGS , data ) return self # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . GET_SETTINGS ] = \\ ( ' GET ' , ' /session/$sessionId/appium/settings ' ) self . command_executor . _commands [ Command . UPDATE_SETTINGS ] = \\ ( ' POST ' , ' /session/$sessionId/appium/settings ' )","title":"Settings"},{"location":"reference/appium/webdriver/extensions/settings/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/settings/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/settings/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/settings/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/settings/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/settings/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/settings/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/settings/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/settings/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/settings/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/settings/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/settings/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/settings/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/settings/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/settings/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/settings/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/settings/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/settings/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/settings/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/settings/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/settings/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/settings/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/settings/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/settings/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/settings/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/settings/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/settings/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/settings/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/settings/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/settings/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/settings/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/settings/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/settings/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/settings/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/settings/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/settings/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/settings/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/settings/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/settings/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/settings/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/settings/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/settings/#get_settings","text":"def get_settings ( self ) Returns the appium server Settings for the current session. Do not get Settings confused with Desired Capabilities, they are separate concepts. See https://github.com/appium/appium/blob/master/docs/en/advanced-concepts/settings.md Returns: dict: Current settings View Source def get_settings ( self ) : \"\"\" Returns the appium server Settings for the current session. Do not get Settings confused with Desired Capabilities , they are separate concepts . See https : // github . com / appium / appium / blob / master / docs / en / advanced - concepts / settings . md Returns : dict : Current settings \"\"\" return self . execute ( Command . GET_SETTINGS , {} ) [ ' value ' ]","title":"get_settings"},{"location":"reference/appium/webdriver/extensions/settings/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/settings/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/settings/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/settings/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/settings/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/settings/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/settings/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/settings/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/settings/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/settings/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/settings/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/settings/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/settings/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/settings/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/settings/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/settings/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/settings/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/settings/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/settings/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/settings/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/settings/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/settings/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/settings/#update_settings","text":"def update_settings ( self , settings ) Set settings for the current session. For more on settings, see: https://github.com/appium/appium/blob/master/docs/en/advanced-concepts/settings.md Args: settings (dict): dictionary of settings to apply to the current test session View Source def update_settings ( self , settings ) : \"\"\" Set settings for the current session. For more on settings , see : https : // github . com / appium / appium / blob / master / docs / en / advanced - concepts / settings . md Args : settings ( dict ) : dictionary of settings to apply to the current test session \"\"\" data = { \" settings \" : settings } self . execute ( Command . UPDATE_SETTINGS , data ) return self","title":"update_settings"},{"location":"reference/appium/webdriver/extensions/android/","text":"Module appium.webdriver.extensions.android Sub-modules appium.webdriver.extensions.android.activities appium.webdriver.extensions.android.display appium.webdriver.extensions.android.gsm appium.webdriver.extensions.android.network appium.webdriver.extensions.android.performance appium.webdriver.extensions.android.power appium.webdriver.extensions.android.sms appium.webdriver.extensions.android.system_bars","title":"Index"},{"location":"reference/appium/webdriver/extensions/android/#module-appiumwebdriverextensionsandroid","text":"","title":"Module appium.webdriver.extensions.android"},{"location":"reference/appium/webdriver/extensions/android/#sub-modules","text":"appium.webdriver.extensions.android.activities appium.webdriver.extensions.android.display appium.webdriver.extensions.android.gsm appium.webdriver.extensions.android.network appium.webdriver.extensions.android.performance appium.webdriver.extensions.android.power appium.webdriver.extensions.android.sms appium.webdriver.extensions.android.system_bars","title":"Sub-modules"},{"location":"reference/appium/webdriver/extensions/android/activities/","text":"Module appium.webdriver.extensions.android.activities View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from selenium.common.exceptions import TimeoutException from selenium.webdriver.support.ui import WebDriverWait from appium.webdriver.mobilecommand import MobileCommand as Command class Activities ( webdriver . Remote ): def start_activity ( self , app_package , app_activity , ** opts ): \"\"\"Opens an arbitrary activity during a test. If the activity belongs to another application, that application is started and the activity is opened. This is an Android-only method. Args: app_package (str): The package containing the activity to start. app_activity (str): The activity to start. Keyword Args: app_wait_package (str): Begin automation after this package starts. app_wait_activity (str): Begin automation after this activity starts. intent_action (str): Intent to start. intent_category (str): Intent category to start. intent_flags (str): Flags to send to the intent. optional_intent_arguments (str): Optional arguments to the intent. dont_stop_app_on_reset (str): Should the app be stopped on reset? \"\"\" data = { 'appPackage' : app_package , 'appActivity' : app_activity } arguments = { 'app_wait_package' : 'appWaitPackage' , 'app_wait_activity' : 'appWaitActivity' , 'intent_action' : 'intentAction' , 'intent_category' : 'intentCategory' , 'intent_flags' : 'intentFlags' , 'optional_intent_arguments' : 'optionalIntentArguments' , 'dont_stop_app_on_reset' : 'dontStopAppOnReset' } for key , value in arguments . items (): if key in opts : data [ value ] = opts [ key ] self . execute ( Command . START_ACTIVITY , data ) return self @property def current_activity ( self ): \"\"\"Retrieves the current activity running on the device. Returns: str: The current activity name running on the device \"\"\" return self . execute ( Command . GET_CURRENT_ACTIVITY )[ 'value' ] def wait_activity ( self , activity , timeout , interval = 1 ): \"\"\"Wait for an activity: block until target activity presents or time out. This is an Android-only method. Args: activity (str): target activity timeout (int): max wait time, in seconds interval (int): sleep interval between retries, in seconds \"\"\" try : WebDriverWait ( self , timeout , interval ) . until ( lambda d : d . current_activity == activity ) return True except TimeoutException : return False # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . GET_CURRENT_ACTIVITY ] = \\ ( 'GET' , '/session/$sessionId/appium/device/current_activity' ) self . command_executor . _commands [ Command . START_ACTIVITY ] = \\ ( 'POST' , '/session/$sessionId/appium/device/start_activity' ) Classes Activities class Activities ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Activities ( webdriver . Remote ) : def start_activity ( self , app_package , app_activity , ** opts ) : \"\"\" Opens an arbitrary activity during a test. If the activity belongs to another application , that application is started and the activity is opened . This is an Android - only method . Args : app_package ( str ) : The package containing the activity to start . app_activity ( str ) : The activity to start . Keyword Args : app_wait_package ( str ) : Begin automation after this package starts . app_wait_activity ( str ) : Begin automation after this activity starts . intent_action ( str ) : Intent to start . intent_category ( str ) : Intent category to start . intent_flags ( str ) : Flags to send to the intent . optional_intent_arguments ( str ) : Optional arguments to the intent . dont_stop_app_on_reset ( str ) : Should the app be stopped on reset ? \"\"\" data = { ' appPackage ' : app_package , ' appActivity ' : app_activity } arguments = { ' app_wait_package ' : ' appWaitPackage ' , ' app_wait_activity ' : ' appWaitActivity ' , ' intent_action ' : ' intentAction ' , ' intent_category ' : ' intentCategory ' , ' intent_flags ' : ' intentFlags ' , ' optional_intent_arguments ' : ' optionalIntentArguments ' , ' dont_stop_app_on_reset ' : ' dontStopAppOnReset ' } for key , value in arguments . items () : if key in opts : data [ value ] = opts [ key ] self . execute ( Command . START_ACTIVITY , data ) return self @ property def current_activity ( self ) : \"\"\" Retrieves the current activity running on the device. Returns : str : The current activity name running on the device \"\"\" return self . execute ( Command . GET_CURRENT_ACTIVITY ) [ ' value ' ] def wait_activity ( self , activity , timeout , interval = 1 ) : \"\"\" Wait for an activity: block until target activity presents or time out. This is an Android - only method . Args : activity ( str ) : target activity timeout ( int ) : max wait time , in seconds interval ( int ) : sleep interval between retries , in seconds \"\"\" try : WebDriverWait ( self , timeout , interval ) . until ( lambda d : d . current_activity == activity ) return True except TimeoutException : return False # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . GET_CURRENT_ACTIVITY ] = \\ ( ' GET ' , ' /session/$sessionId/appium/device/current_activity ' ) self . command_executor . _commands [ Command . START_ACTIVITY ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/start_activity ' ) Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache current_activity Retrieves the current activity running on the device. Returns: str: The current activity name running on the device current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_activity def start_activity ( self , app_package , app_activity , ** opts ) Opens an arbitrary activity during a test. If the activity belongs to another application, that application is started and the activity is opened. This is an Android-only method. Args: app_package (str): The package containing the activity to start. app_activity (str): The activity to start. Keyword Args: app_wait_package (str): Begin automation after this package starts. app_wait_activity (str): Begin automation after this activity starts. intent_action (str): Intent to start. intent_category (str): Intent category to start. intent_flags (str): Flags to send to the intent. optional_intent_arguments (str): Optional arguments to the intent. dont_stop_app_on_reset (str): Should the app be stopped on reset? View Source def start_activity ( self , app_package , app_activity , ** opts ) : \"\"\" Opens an arbitrary activity during a test. If the activity belongs to another application , that application is started and the activity is opened . This is an Android - only method . Args : app_package ( str ) : The package containing the activity to start . app_activity ( str ) : The activity to start . Keyword Args : app_wait_package ( str ) : Begin automation after this package starts . app_wait_activity ( str ) : Begin automation after this activity starts . intent_action ( str ) : Intent to start . intent_category ( str ) : Intent category to start . intent_flags ( str ) : Flags to send to the intent . optional_intent_arguments ( str ) : Optional arguments to the intent . dont_stop_app_on_reset ( str ) : Should the app be stopped on reset ? \"\"\" data = { ' appPackage ' : app_package , ' appActivity ' : app_activity } arguments = { ' app_wait_package ' : ' appWaitPackage ' , ' app_wait_activity ' : ' appWaitActivity ' , ' intent_action ' : ' intentAction ' , ' intent_category ' : ' intentCategory ' , ' intent_flags ' : ' intentFlags ' , ' optional_intent_arguments ' : ' optionalIntentArguments ' , ' dont_stop_app_on_reset ' : ' dontStopAppOnReset ' } for key , value in arguments . items () : if key in opts : data [ value ] = opts [ key ] self . execute ( Command . START_ACTIVITY , data ) return self start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name ) wait_activity def wait_activity ( self , activity , timeout , interval = 1 ) Wait for an activity: block until target activity presents or time out. This is an Android-only method. Args: activity (str): target activity timeout (int): max wait time, in seconds interval (int): sleep interval between retries, in seconds View Source def wait_activity ( self , activity , timeout , interval = 1 ) : \"\"\" Wait for an activity: block until target activity presents or time out. This is an Android - only method . Args : activity ( str ) : target activity timeout ( int ) : max wait time , in seconds interval ( int ) : sleep interval between retries , in seconds \"\"\" try : WebDriverWait ( self , timeout , interval ) . until ( lambda d : d . current_activity == activity ) return True except TimeoutException : return False","title":"Activities"},{"location":"reference/appium/webdriver/extensions/android/activities/#module-appiumwebdriverextensionsandroidactivities","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from selenium.common.exceptions import TimeoutException from selenium.webdriver.support.ui import WebDriverWait from appium.webdriver.mobilecommand import MobileCommand as Command class Activities ( webdriver . Remote ): def start_activity ( self , app_package , app_activity , ** opts ): \"\"\"Opens an arbitrary activity during a test. If the activity belongs to another application, that application is started and the activity is opened. This is an Android-only method. Args: app_package (str): The package containing the activity to start. app_activity (str): The activity to start. Keyword Args: app_wait_package (str): Begin automation after this package starts. app_wait_activity (str): Begin automation after this activity starts. intent_action (str): Intent to start. intent_category (str): Intent category to start. intent_flags (str): Flags to send to the intent. optional_intent_arguments (str): Optional arguments to the intent. dont_stop_app_on_reset (str): Should the app be stopped on reset? \"\"\" data = { 'appPackage' : app_package , 'appActivity' : app_activity } arguments = { 'app_wait_package' : 'appWaitPackage' , 'app_wait_activity' : 'appWaitActivity' , 'intent_action' : 'intentAction' , 'intent_category' : 'intentCategory' , 'intent_flags' : 'intentFlags' , 'optional_intent_arguments' : 'optionalIntentArguments' , 'dont_stop_app_on_reset' : 'dontStopAppOnReset' } for key , value in arguments . items (): if key in opts : data [ value ] = opts [ key ] self . execute ( Command . START_ACTIVITY , data ) return self @property def current_activity ( self ): \"\"\"Retrieves the current activity running on the device. Returns: str: The current activity name running on the device \"\"\" return self . execute ( Command . GET_CURRENT_ACTIVITY )[ 'value' ] def wait_activity ( self , activity , timeout , interval = 1 ): \"\"\"Wait for an activity: block until target activity presents or time out. This is an Android-only method. Args: activity (str): target activity timeout (int): max wait time, in seconds interval (int): sleep interval between retries, in seconds \"\"\" try : WebDriverWait ( self , timeout , interval ) . until ( lambda d : d . current_activity == activity ) return True except TimeoutException : return False # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . GET_CURRENT_ACTIVITY ] = \\ ( 'GET' , '/session/$sessionId/appium/device/current_activity' ) self . command_executor . _commands [ Command . START_ACTIVITY ] = \\ ( 'POST' , '/session/$sessionId/appium/device/start_activity' )","title":"Module appium.webdriver.extensions.android.activities"},{"location":"reference/appium/webdriver/extensions/android/activities/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/android/activities/#activities","text":"class Activities ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Activities ( webdriver . Remote ) : def start_activity ( self , app_package , app_activity , ** opts ) : \"\"\" Opens an arbitrary activity during a test. If the activity belongs to another application , that application is started and the activity is opened . This is an Android - only method . Args : app_package ( str ) : The package containing the activity to start . app_activity ( str ) : The activity to start . Keyword Args : app_wait_package ( str ) : Begin automation after this package starts . app_wait_activity ( str ) : Begin automation after this activity starts . intent_action ( str ) : Intent to start . intent_category ( str ) : Intent category to start . intent_flags ( str ) : Flags to send to the intent . optional_intent_arguments ( str ) : Optional arguments to the intent . dont_stop_app_on_reset ( str ) : Should the app be stopped on reset ? \"\"\" data = { ' appPackage ' : app_package , ' appActivity ' : app_activity } arguments = { ' app_wait_package ' : ' appWaitPackage ' , ' app_wait_activity ' : ' appWaitActivity ' , ' intent_action ' : ' intentAction ' , ' intent_category ' : ' intentCategory ' , ' intent_flags ' : ' intentFlags ' , ' optional_intent_arguments ' : ' optionalIntentArguments ' , ' dont_stop_app_on_reset ' : ' dontStopAppOnReset ' } for key , value in arguments . items () : if key in opts : data [ value ] = opts [ key ] self . execute ( Command . START_ACTIVITY , data ) return self @ property def current_activity ( self ) : \"\"\" Retrieves the current activity running on the device. Returns : str : The current activity name running on the device \"\"\" return self . execute ( Command . GET_CURRENT_ACTIVITY ) [ ' value ' ] def wait_activity ( self , activity , timeout , interval = 1 ) : \"\"\" Wait for an activity: block until target activity presents or time out. This is an Android - only method . Args : activity ( str ) : target activity timeout ( int ) : max wait time , in seconds interval ( int ) : sleep interval between retries , in seconds \"\"\" try : WebDriverWait ( self , timeout , interval ) . until ( lambda d : d . current_activity == activity ) return True except TimeoutException : return False # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . GET_CURRENT_ACTIVITY ] = \\ ( ' GET ' , ' /session/$sessionId/appium/device/current_activity ' ) self . command_executor . _commands [ Command . START_ACTIVITY ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/start_activity ' )","title":"Activities"},{"location":"reference/appium/webdriver/extensions/android/activities/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/android/activities/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/android/activities/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache current_activity Retrieves the current activity running on the device. Returns: str: The current activity name running on the device current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/android/activities/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/android/activities/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/android/activities/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/android/activities/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/android/activities/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/android/activities/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/android/activities/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/android/activities/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/android/activities/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/android/activities/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/android/activities/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/android/activities/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/android/activities/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/android/activities/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/android/activities/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/android/activities/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/android/activities/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/android/activities/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/android/activities/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/android/activities/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/android/activities/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/android/activities/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/android/activities/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/android/activities/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/android/activities/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/android/activities/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/android/activities/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/android/activities/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/android/activities/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/android/activities/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/android/activities/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/android/activities/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/android/activities/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/android/activities/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/android/activities/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/android/activities/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/android/activities/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/android/activities/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/android/activities/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/android/activities/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/android/activities/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/android/activities/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/android/activities/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/android/activities/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/android/activities/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/android/activities/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/android/activities/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/android/activities/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/android/activities/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/android/activities/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/android/activities/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/android/activities/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/android/activities/#start_activity","text":"def start_activity ( self , app_package , app_activity , ** opts ) Opens an arbitrary activity during a test. If the activity belongs to another application, that application is started and the activity is opened. This is an Android-only method. Args: app_package (str): The package containing the activity to start. app_activity (str): The activity to start. Keyword Args: app_wait_package (str): Begin automation after this package starts. app_wait_activity (str): Begin automation after this activity starts. intent_action (str): Intent to start. intent_category (str): Intent category to start. intent_flags (str): Flags to send to the intent. optional_intent_arguments (str): Optional arguments to the intent. dont_stop_app_on_reset (str): Should the app be stopped on reset? View Source def start_activity ( self , app_package , app_activity , ** opts ) : \"\"\" Opens an arbitrary activity during a test. If the activity belongs to another application , that application is started and the activity is opened . This is an Android - only method . Args : app_package ( str ) : The package containing the activity to start . app_activity ( str ) : The activity to start . Keyword Args : app_wait_package ( str ) : Begin automation after this package starts . app_wait_activity ( str ) : Begin automation after this activity starts . intent_action ( str ) : Intent to start . intent_category ( str ) : Intent category to start . intent_flags ( str ) : Flags to send to the intent . optional_intent_arguments ( str ) : Optional arguments to the intent . dont_stop_app_on_reset ( str ) : Should the app be stopped on reset ? \"\"\" data = { ' appPackage ' : app_package , ' appActivity ' : app_activity } arguments = { ' app_wait_package ' : ' appWaitPackage ' , ' app_wait_activity ' : ' appWaitActivity ' , ' intent_action ' : ' intentAction ' , ' intent_category ' : ' intentCategory ' , ' intent_flags ' : ' intentFlags ' , ' optional_intent_arguments ' : ' optionalIntentArguments ' , ' dont_stop_app_on_reset ' : ' dontStopAppOnReset ' } for key , value in arguments . items () : if key in opts : data [ value ] = opts [ key ] self . execute ( Command . START_ACTIVITY , data ) return self","title":"start_activity"},{"location":"reference/appium/webdriver/extensions/android/activities/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/android/activities/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/android/activities/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/android/activities/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/android/activities/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/android/activities/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/android/activities/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/android/activities/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/android/activities/#wait_activity","text":"def wait_activity ( self , activity , timeout , interval = 1 ) Wait for an activity: block until target activity presents or time out. This is an Android-only method. Args: activity (str): target activity timeout (int): max wait time, in seconds interval (int): sleep interval between retries, in seconds View Source def wait_activity ( self , activity , timeout , interval = 1 ) : \"\"\" Wait for an activity: block until target activity presents or time out. This is an Android - only method . Args : activity ( str ) : target activity timeout ( int ) : max wait time , in seconds interval ( int ) : sleep interval between retries , in seconds \"\"\" try : WebDriverWait ( self , timeout , interval ) . until ( lambda d : d . current_activity == activity ) return True except TimeoutException : return False","title":"wait_activity"},{"location":"reference/appium/webdriver/extensions/android/display/","text":"Module appium.webdriver.extensions.android.display View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from appium.webdriver.mobilecommand import MobileCommand as Command class Display ( webdriver . Remote ): def get_display_density ( self ): \"\"\"Get the display density, Android only Returns: int: The display density of the Android device(dpi) Usage: self.driver.get_display_density() \"\"\" return self . execute ( Command . GET_DISPLAY_DENSITY )[ 'value' ] # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . GET_DISPLAY_DENSITY ] = \\ ( 'GET' , '/session/$sessionId/appium/device/display_density' ) Classes Display class Display ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Display ( webdriver . Remote ) : def get_display_density ( self ) : \"\"\" Get the display density, Android only Returns : int : The display density of the Android device ( dpi ) Usage : self . driver . get_display_density () \"\"\" return self . execute ( Command . GET_DISPLAY_DENSITY ) [ ' value ' ] # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . GET_DISPLAY_DENSITY ] = \\ ( ' GET ' , ' /session/$sessionId/appium/device/display_density ' ) Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_display_density def get_display_density ( self ) Get the display density, Android only Returns: int: The display density of the Android device(dpi) Usage: self.driver.get_display_density() View Source def get_display_density ( self ) : \"\"\" Get the display density, Android only Returns : int : The display density of the Android device ( dpi ) Usage : self . driver . get_display_density () \"\"\" return self . execute ( Command . GET_DISPLAY_DENSITY ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"Display"},{"location":"reference/appium/webdriver/extensions/android/display/#module-appiumwebdriverextensionsandroiddisplay","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from appium.webdriver.mobilecommand import MobileCommand as Command class Display ( webdriver . Remote ): def get_display_density ( self ): \"\"\"Get the display density, Android only Returns: int: The display density of the Android device(dpi) Usage: self.driver.get_display_density() \"\"\" return self . execute ( Command . GET_DISPLAY_DENSITY )[ 'value' ] # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . GET_DISPLAY_DENSITY ] = \\ ( 'GET' , '/session/$sessionId/appium/device/display_density' )","title":"Module appium.webdriver.extensions.android.display"},{"location":"reference/appium/webdriver/extensions/android/display/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/android/display/#display","text":"class Display ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Display ( webdriver . Remote ) : def get_display_density ( self ) : \"\"\" Get the display density, Android only Returns : int : The display density of the Android device ( dpi ) Usage : self . driver . get_display_density () \"\"\" return self . execute ( Command . GET_DISPLAY_DENSITY ) [ ' value ' ] # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . GET_DISPLAY_DENSITY ] = \\ ( ' GET ' , ' /session/$sessionId/appium/device/display_density ' )","title":"Display"},{"location":"reference/appium/webdriver/extensions/android/display/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/android/display/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/android/display/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/android/display/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/android/display/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/android/display/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/android/display/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/android/display/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/android/display/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/android/display/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/android/display/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/android/display/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/android/display/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/android/display/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/android/display/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/android/display/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/android/display/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/android/display/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/android/display/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/android/display/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/android/display/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/android/display/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/android/display/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/android/display/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/android/display/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/android/display/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/android/display/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/android/display/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/android/display/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/android/display/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/android/display/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/android/display/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/android/display/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/android/display/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/android/display/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/android/display/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/android/display/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/android/display/#get_display_density","text":"def get_display_density ( self ) Get the display density, Android only Returns: int: The display density of the Android device(dpi) Usage: self.driver.get_display_density() View Source def get_display_density ( self ) : \"\"\" Get the display density, Android only Returns : int : The display density of the Android device ( dpi ) Usage : self . driver . get_display_density () \"\"\" return self . execute ( Command . GET_DISPLAY_DENSITY ) [ ' value ' ]","title":"get_display_density"},{"location":"reference/appium/webdriver/extensions/android/display/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/android/display/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/android/display/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/android/display/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/android/display/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/android/display/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/android/display/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/android/display/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/android/display/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/android/display/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/android/display/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/android/display/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/android/display/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/android/display/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/android/display/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/android/display/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/android/display/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/android/display/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/android/display/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/android/display/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/android/display/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/android/display/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/android/display/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/android/display/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/android/display/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/android/display/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/android/gsm/","text":"Module appium.webdriver.extensions.android.gsm View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from appium.common.helper import extract_const_attributes from appium.common.logger import logger from appium.webdriver.mobilecommand import MobileCommand as Command class GsmCallActions ( object ): CALL = 'call' ACCEPT = 'accept' CANCEL = 'cancel' HOLD = 'hold' class GsmSignalStrength ( object ): NONE_OR_UNKNOWN = 0 POOR = 1 MODERATE = 2 GOOD = 3 GREAT = 4 class GsmVoiceState ( object ): UNREGISTERED = 'unregistered' HOME = 'home' ROAMING = 'roaming' SEARCHING = 'searching' DENIED = 'denied' OFF = 'off' ON = 'on' class Gsm ( webdriver . Remote ): def make_gsm_call ( self , phone_number , action ): \"\"\"Make GSM call (Emulator only) Android only. Args: phone_number (str): The phone number to call to. action (str): The call action. A member of the const `appium.webdriver.extensions.android.gsm.GsmCallActions` :Usage: self.driver.make_gsm_call('5551234567', GsmCallActions.CALL) \"\"\" constants = extract_const_attributes ( GsmCallActions ) if action not in constants . values (): logger . warning ( '{} is unknown. Consider using one of {} constants. (e.g. {}.CALL)' . format ( action , list ( constants . keys ()), GsmCallActions . __name__ )) self . execute ( Command . MAKE_GSM_CALL , { 'phoneNumber' : phone_number , 'action' : action }) return self def set_gsm_signal ( self , strength ): \"\"\"Set GSM signal strength (Emulator only) Android only. Args: strength (int): Signal strength. A member of the enum `appium.webdriver.extensions.android.gsm.GsmSignalStrength` Usage: self.driver.set_gsm_signal(GsmSignalStrength.GOOD) \"\"\" constants = extract_const_attributes ( GsmSignalStrength ) if strength not in constants . values (): logger . warning ( '{} is out of range. Consider using one of {} constants. (e.g. {}.GOOD)' . format ( strength , list ( constants . keys ()), GsmSignalStrength . __name__ )) self . execute ( Command . SET_GSM_SIGNAL , { 'signalStrength' : strength , 'signalStrengh' : strength }) return self def set_gsm_voice ( self , state ): \"\"\"Set GSM voice state (Emulator only) Android only. Args: state (str): State of GSM voice. A member of the const `appium.webdriver.extensions.android.gsm.GsmVoiceState` Usage: self.driver.set_gsm_voice(GsmVoiceState.HOME) \"\"\" constants = extract_const_attributes ( GsmVoiceState ) if state not in constants . values (): logger . warning ( '{} is unknown. Consider using one of {} constants. (e.g. {}.HOME)' . format ( state , list ( constants . keys ()), GsmVoiceState . __name__ )) self . execute ( Command . SET_GSM_VOICE , { 'state' : state }) return self # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . MAKE_GSM_CALL ] = \\ ( 'POST' , '/session/$sessionId/appium/device/gsm_call' ) self . command_executor . _commands [ Command . SET_GSM_SIGNAL ] = \\ ( 'POST' , '/session/$sessionId/appium/device/gsm_signal' ) self . command_executor . _commands [ Command . SET_GSM_VOICE ] = \\ ( 'POST' , '/session/$sessionId/appium/device/gsm_voice' ) Classes Gsm class Gsm ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Gsm ( webdriver . Remote ) : def make_gsm_call ( self , phone_number , action ) : \"\"\" Make GSM call (Emulator only) Android only . Args : phone_number ( str ) : The phone number to call to . action ( str ) : The call action . A member of the const ` appium . webdriver . extensions . android . gsm . GsmCallActions ` : Usage : self . driver . make_gsm_call ( ' 5551234567 ' , GsmCallActions . CALL ) \"\"\" constants = extract_const_attributes ( GsmCallActions ) if action not in constants . values () : logger . warning ( ' {} is unknown. Consider using one of {} constants. (e.g. {}.CALL) ' . format ( action , list ( constants . keys ()) , GsmCallActions . __name__ )) self . execute ( Command . MAKE_GSM_CALL , { ' phoneNumber ' : phone_number , ' action ' : action } ) return self def set_gsm_signal ( self , strength ) : \"\"\" Set GSM signal strength (Emulator only) Android only . Args : strength ( int ) : Signal strength . A member of the enum ` appium . webdriver . extensions . android . gsm . GsmSignalStrength ` Usage : self . driver . set_gsm_signal ( GsmSignalStrength . GOOD ) \"\"\" constants = extract_const_attributes ( GsmSignalStrength ) if strength not in constants . values () : logger . warning ( ' {} is out of range. Consider using one of {} constants. (e.g. {}.GOOD) ' . format ( strength , list ( constants . keys ()) , GsmSignalStrength . __name__ )) self . execute ( Command . SET_GSM_SIGNAL , { ' signalStrength ' : strength , ' signalStrengh ' : strength } ) return self def set_gsm_voice ( self , state ) : \"\"\" Set GSM voice state (Emulator only) Android only . Args : state ( str ) : State of GSM voice . A member of the const ` appium . webdriver . extensions . android . gsm . GsmVoiceState ` Usage : self . driver . set_gsm_voice ( GsmVoiceState . HOME ) \"\"\" constants = extract_const_attributes ( GsmVoiceState ) if state not in constants . values () : logger . warning ( ' {} is unknown. Consider using one of {} constants. (e.g. {}.HOME) ' . format ( state , list ( constants . keys ()) , GsmVoiceState . __name__ )) self . execute ( Command . SET_GSM_VOICE , { ' state ' : state } ) return self # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . MAKE_GSM_CALL ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/gsm_call ' ) self . command_executor . _commands [ Command . SET_GSM_SIGNAL ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/gsm_signal ' ) self . command_executor . _commands [ Command . SET_GSM_VOICE ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/gsm_voice ' ) Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) make_gsm_call def make_gsm_call ( self , phone_number , action ) Make GSM call (Emulator only) Android only. Args: phone_number (str): The phone number to call to. action (str): The call action. A member of the const appium.webdriver.extensions.android.gsm.GsmCallActions :Usage: self.driver.make_gsm_call('5551234567', GsmCallActions.CALL) View Source def make_gsm_call ( self , phone_number , action ) : \"\"\" Make GSM call (Emulator only) Android only . Args : phone_number ( str ) : The phone number to call to . action ( str ) : The call action . A member of the const ` appium . webdriver . extensions . android . gsm . GsmCallActions ` : Usage : self . driver . make_gsm_call ( ' 5551234567 ' , GsmCallActions . CALL ) \"\"\" constants = extract_const_attributes ( GsmCallActions ) if action not in constants . values () : logger . warning ( ' {} is unknown. Consider using one of {} constants. (e.g. {}.CALL) ' . format ( action , list ( constants . keys ()) , GsmCallActions . __name__ )) self . execute ( Command . MAKE_GSM_CALL , { ' phoneNumber ' : phone_number , ' action ' : action } ) return self maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) set_gsm_signal def set_gsm_signal ( self , strength ) Set GSM signal strength (Emulator only) Android only. Args: strength (int): Signal strength. A member of the enum appium.webdriver.extensions.android.gsm.GsmSignalStrength Usage: self.driver.set_gsm_signal(GsmSignalStrength.GOOD) View Source def set_gsm_signal ( self , strength ) : \"\"\" Set GSM signal strength (Emulator only) Android only . Args : strength ( int ) : Signal strength . A member of the enum ` appium . webdriver . extensions . android . gsm . GsmSignalStrength ` Usage : self . driver . set_gsm_signal ( GsmSignalStrength . GOOD ) \"\"\" constants = extract_const_attributes ( GsmSignalStrength ) if strength not in constants . values () : logger . warning ( ' {} is out of range. Consider using one of {} constants. (e.g. {}.GOOD) ' . format ( strength , list ( constants . keys ()) , GsmSignalStrength . __name__ )) self . execute ( Command . SET_GSM_SIGNAL , { ' signalStrength ' : strength , ' signalStrengh ' : strength } ) return self set_gsm_voice def set_gsm_voice ( self , state ) Set GSM voice state (Emulator only) Android only. Args: state (str): State of GSM voice. A member of the const appium.webdriver.extensions.android.gsm.GsmVoiceState Usage: self.driver.set_gsm_voice(GsmVoiceState.HOME) View Source def set_gsm_voice ( self , state ) : \"\"\" Set GSM voice state (Emulator only) Android only . Args : state ( str ) : State of GSM voice . A member of the const ` appium . webdriver . extensions . android . gsm . GsmVoiceState ` Usage : self . driver . set_gsm_voice ( GsmVoiceState . HOME ) \"\"\" constants = extract_const_attributes ( GsmVoiceState ) if state not in constants . values () : logger . warning ( ' {} is unknown. Consider using one of {} constants. (e.g. {}.HOME) ' . format ( state , list ( constants . keys ()) , GsmVoiceState . __name__ )) self . execute ( Command . SET_GSM_VOICE , { ' state ' : state } ) return self set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name ) GsmCallActions class GsmCallActions ( / , * args , ** kwargs ) View Source class GsmCallActions ( object ): CALL = 'call' ACCEPT = 'accept' CANCEL = 'cancel' HOLD = 'hold' Class variables ACCEPT CALL CANCEL HOLD GsmSignalStrength class GsmSignalStrength ( / , * args , ** kwargs ) View Source class GsmSignalStrength ( object ): NONE_OR_UNKNOWN = 0 POOR = 1 MODERATE = 2 GOOD = 3 GREAT = 4 Class variables GOOD GREAT MODERATE NONE_OR_UNKNOWN POOR GsmVoiceState class GsmVoiceState ( / , * args , ** kwargs ) View Source class GsmVoiceState ( object ): UNREGISTERED = 'unregistered' HOME = 'home' ROAMING = 'roaming' SEARCHING = 'searching' DENIED = 'denied' OFF = 'off' ON = 'on' Class variables DENIED HOME OFF ON ROAMING SEARCHING UNREGISTERED","title":"Gsm"},{"location":"reference/appium/webdriver/extensions/android/gsm/#module-appiumwebdriverextensionsandroidgsm","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from appium.common.helper import extract_const_attributes from appium.common.logger import logger from appium.webdriver.mobilecommand import MobileCommand as Command class GsmCallActions ( object ): CALL = 'call' ACCEPT = 'accept' CANCEL = 'cancel' HOLD = 'hold' class GsmSignalStrength ( object ): NONE_OR_UNKNOWN = 0 POOR = 1 MODERATE = 2 GOOD = 3 GREAT = 4 class GsmVoiceState ( object ): UNREGISTERED = 'unregistered' HOME = 'home' ROAMING = 'roaming' SEARCHING = 'searching' DENIED = 'denied' OFF = 'off' ON = 'on' class Gsm ( webdriver . Remote ): def make_gsm_call ( self , phone_number , action ): \"\"\"Make GSM call (Emulator only) Android only. Args: phone_number (str): The phone number to call to. action (str): The call action. A member of the const `appium.webdriver.extensions.android.gsm.GsmCallActions` :Usage: self.driver.make_gsm_call('5551234567', GsmCallActions.CALL) \"\"\" constants = extract_const_attributes ( GsmCallActions ) if action not in constants . values (): logger . warning ( '{} is unknown. Consider using one of {} constants. (e.g. {}.CALL)' . format ( action , list ( constants . keys ()), GsmCallActions . __name__ )) self . execute ( Command . MAKE_GSM_CALL , { 'phoneNumber' : phone_number , 'action' : action }) return self def set_gsm_signal ( self , strength ): \"\"\"Set GSM signal strength (Emulator only) Android only. Args: strength (int): Signal strength. A member of the enum `appium.webdriver.extensions.android.gsm.GsmSignalStrength` Usage: self.driver.set_gsm_signal(GsmSignalStrength.GOOD) \"\"\" constants = extract_const_attributes ( GsmSignalStrength ) if strength not in constants . values (): logger . warning ( '{} is out of range. Consider using one of {} constants. (e.g. {}.GOOD)' . format ( strength , list ( constants . keys ()), GsmSignalStrength . __name__ )) self . execute ( Command . SET_GSM_SIGNAL , { 'signalStrength' : strength , 'signalStrengh' : strength }) return self def set_gsm_voice ( self , state ): \"\"\"Set GSM voice state (Emulator only) Android only. Args: state (str): State of GSM voice. A member of the const `appium.webdriver.extensions.android.gsm.GsmVoiceState` Usage: self.driver.set_gsm_voice(GsmVoiceState.HOME) \"\"\" constants = extract_const_attributes ( GsmVoiceState ) if state not in constants . values (): logger . warning ( '{} is unknown. Consider using one of {} constants. (e.g. {}.HOME)' . format ( state , list ( constants . keys ()), GsmVoiceState . __name__ )) self . execute ( Command . SET_GSM_VOICE , { 'state' : state }) return self # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . MAKE_GSM_CALL ] = \\ ( 'POST' , '/session/$sessionId/appium/device/gsm_call' ) self . command_executor . _commands [ Command . SET_GSM_SIGNAL ] = \\ ( 'POST' , '/session/$sessionId/appium/device/gsm_signal' ) self . command_executor . _commands [ Command . SET_GSM_VOICE ] = \\ ( 'POST' , '/session/$sessionId/appium/device/gsm_voice' )","title":"Module appium.webdriver.extensions.android.gsm"},{"location":"reference/appium/webdriver/extensions/android/gsm/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/android/gsm/#gsm","text":"class Gsm ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Gsm ( webdriver . Remote ) : def make_gsm_call ( self , phone_number , action ) : \"\"\" Make GSM call (Emulator only) Android only . Args : phone_number ( str ) : The phone number to call to . action ( str ) : The call action . A member of the const ` appium . webdriver . extensions . android . gsm . GsmCallActions ` : Usage : self . driver . make_gsm_call ( ' 5551234567 ' , GsmCallActions . CALL ) \"\"\" constants = extract_const_attributes ( GsmCallActions ) if action not in constants . values () : logger . warning ( ' {} is unknown. Consider using one of {} constants. (e.g. {}.CALL) ' . format ( action , list ( constants . keys ()) , GsmCallActions . __name__ )) self . execute ( Command . MAKE_GSM_CALL , { ' phoneNumber ' : phone_number , ' action ' : action } ) return self def set_gsm_signal ( self , strength ) : \"\"\" Set GSM signal strength (Emulator only) Android only . Args : strength ( int ) : Signal strength . A member of the enum ` appium . webdriver . extensions . android . gsm . GsmSignalStrength ` Usage : self . driver . set_gsm_signal ( GsmSignalStrength . GOOD ) \"\"\" constants = extract_const_attributes ( GsmSignalStrength ) if strength not in constants . values () : logger . warning ( ' {} is out of range. Consider using one of {} constants. (e.g. {}.GOOD) ' . format ( strength , list ( constants . keys ()) , GsmSignalStrength . __name__ )) self . execute ( Command . SET_GSM_SIGNAL , { ' signalStrength ' : strength , ' signalStrengh ' : strength } ) return self def set_gsm_voice ( self , state ) : \"\"\" Set GSM voice state (Emulator only) Android only . Args : state ( str ) : State of GSM voice . A member of the const ` appium . webdriver . extensions . android . gsm . GsmVoiceState ` Usage : self . driver . set_gsm_voice ( GsmVoiceState . HOME ) \"\"\" constants = extract_const_attributes ( GsmVoiceState ) if state not in constants . values () : logger . warning ( ' {} is unknown. Consider using one of {} constants. (e.g. {}.HOME) ' . format ( state , list ( constants . keys ()) , GsmVoiceState . __name__ )) self . execute ( Command . SET_GSM_VOICE , { ' state ' : state } ) return self # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . MAKE_GSM_CALL ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/gsm_call ' ) self . command_executor . _commands [ Command . SET_GSM_SIGNAL ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/gsm_signal ' ) self . command_executor . _commands [ Command . SET_GSM_VOICE ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/gsm_voice ' )","title":"Gsm"},{"location":"reference/appium/webdriver/extensions/android/gsm/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/android/gsm/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/android/gsm/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/android/gsm/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/android/gsm/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/android/gsm/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/android/gsm/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/android/gsm/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/android/gsm/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/android/gsm/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/android/gsm/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/android/gsm/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/android/gsm/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/android/gsm/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/android/gsm/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/android/gsm/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/android/gsm/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/android/gsm/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/android/gsm/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/android/gsm/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/android/gsm/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/android/gsm/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/android/gsm/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/android/gsm/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/android/gsm/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/android/gsm/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/android/gsm/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/android/gsm/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/android/gsm/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/android/gsm/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/android/gsm/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/android/gsm/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/android/gsm/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/android/gsm/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/android/gsm/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/android/gsm/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/android/gsm/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/android/gsm/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/android/gsm/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/android/gsm/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/android/gsm/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/android/gsm/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/android/gsm/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/android/gsm/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/android/gsm/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/android/gsm/#make_gsm_call","text":"def make_gsm_call ( self , phone_number , action ) Make GSM call (Emulator only) Android only. Args: phone_number (str): The phone number to call to. action (str): The call action. A member of the const appium.webdriver.extensions.android.gsm.GsmCallActions :Usage: self.driver.make_gsm_call('5551234567', GsmCallActions.CALL) View Source def make_gsm_call ( self , phone_number , action ) : \"\"\" Make GSM call (Emulator only) Android only . Args : phone_number ( str ) : The phone number to call to . action ( str ) : The call action . A member of the const ` appium . webdriver . extensions . android . gsm . GsmCallActions ` : Usage : self . driver . make_gsm_call ( ' 5551234567 ' , GsmCallActions . CALL ) \"\"\" constants = extract_const_attributes ( GsmCallActions ) if action not in constants . values () : logger . warning ( ' {} is unknown. Consider using one of {} constants. (e.g. {}.CALL) ' . format ( action , list ( constants . keys ()) , GsmCallActions . __name__ )) self . execute ( Command . MAKE_GSM_CALL , { ' phoneNumber ' : phone_number , ' action ' : action } ) return self","title":"make_gsm_call"},{"location":"reference/appium/webdriver/extensions/android/gsm/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/android/gsm/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/android/gsm/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/android/gsm/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/android/gsm/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/android/gsm/#set_gsm_signal","text":"def set_gsm_signal ( self , strength ) Set GSM signal strength (Emulator only) Android only. Args: strength (int): Signal strength. A member of the enum appium.webdriver.extensions.android.gsm.GsmSignalStrength Usage: self.driver.set_gsm_signal(GsmSignalStrength.GOOD) View Source def set_gsm_signal ( self , strength ) : \"\"\" Set GSM signal strength (Emulator only) Android only . Args : strength ( int ) : Signal strength . A member of the enum ` appium . webdriver . extensions . android . gsm . GsmSignalStrength ` Usage : self . driver . set_gsm_signal ( GsmSignalStrength . GOOD ) \"\"\" constants = extract_const_attributes ( GsmSignalStrength ) if strength not in constants . values () : logger . warning ( ' {} is out of range. Consider using one of {} constants. (e.g. {}.GOOD) ' . format ( strength , list ( constants . keys ()) , GsmSignalStrength . __name__ )) self . execute ( Command . SET_GSM_SIGNAL , { ' signalStrength ' : strength , ' signalStrengh ' : strength } ) return self","title":"set_gsm_signal"},{"location":"reference/appium/webdriver/extensions/android/gsm/#set_gsm_voice","text":"def set_gsm_voice ( self , state ) Set GSM voice state (Emulator only) Android only. Args: state (str): State of GSM voice. A member of the const appium.webdriver.extensions.android.gsm.GsmVoiceState Usage: self.driver.set_gsm_voice(GsmVoiceState.HOME) View Source def set_gsm_voice ( self , state ) : \"\"\" Set GSM voice state (Emulator only) Android only . Args : state ( str ) : State of GSM voice . A member of the const ` appium . webdriver . extensions . android . gsm . GsmVoiceState ` Usage : self . driver . set_gsm_voice ( GsmVoiceState . HOME ) \"\"\" constants = extract_const_attributes ( GsmVoiceState ) if state not in constants . values () : logger . warning ( ' {} is unknown. Consider using one of {} constants. (e.g. {}.HOME) ' . format ( state , list ( constants . keys ()) , GsmVoiceState . __name__ )) self . execute ( Command . SET_GSM_VOICE , { ' state ' : state } ) return self","title":"set_gsm_voice"},{"location":"reference/appium/webdriver/extensions/android/gsm/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/android/gsm/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/android/gsm/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/android/gsm/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/android/gsm/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/android/gsm/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/android/gsm/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/android/gsm/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/android/gsm/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/android/gsm/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/android/gsm/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/android/gsm/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/android/gsm/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/android/gsm/#gsmcallactions","text":"class GsmCallActions ( / , * args , ** kwargs ) View Source class GsmCallActions ( object ): CALL = 'call' ACCEPT = 'accept' CANCEL = 'cancel' HOLD = 'hold'","title":"GsmCallActions"},{"location":"reference/appium/webdriver/extensions/android/gsm/#class-variables","text":"ACCEPT CALL CANCEL HOLD","title":"Class variables"},{"location":"reference/appium/webdriver/extensions/android/gsm/#gsmsignalstrength","text":"class GsmSignalStrength ( / , * args , ** kwargs ) View Source class GsmSignalStrength ( object ): NONE_OR_UNKNOWN = 0 POOR = 1 MODERATE = 2 GOOD = 3 GREAT = 4","title":"GsmSignalStrength"},{"location":"reference/appium/webdriver/extensions/android/gsm/#class-variables_1","text":"GOOD GREAT MODERATE NONE_OR_UNKNOWN POOR","title":"Class variables"},{"location":"reference/appium/webdriver/extensions/android/gsm/#gsmvoicestate","text":"class GsmVoiceState ( / , * args , ** kwargs ) View Source class GsmVoiceState ( object ): UNREGISTERED = 'unregistered' HOME = 'home' ROAMING = 'roaming' SEARCHING = 'searching' DENIED = 'denied' OFF = 'off' ON = 'on'","title":"GsmVoiceState"},{"location":"reference/appium/webdriver/extensions/android/gsm/#class-variables_2","text":"DENIED HOME OFF ON ROAMING SEARCHING UNREGISTERED","title":"Class variables"},{"location":"reference/appium/webdriver/extensions/android/network/","text":"Module appium.webdriver.extensions.android.network View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from appium.common.helper import extract_const_attributes from appium.common.logger import logger from appium.webdriver.mobilecommand import MobileCommand as Command class NetSpeed ( object ): GSM = 'gsm' # GSM/CSD (up: 14.4(kbps), down: 14.4(kbps)) SCSD = 'scsd' # HSCSD (up: 14.4, down: 57.6) GPRS = 'gprs' # GPRS (up: 28.8, down: 57.6) EDGE = 'edge' # EDGE/EGPRS (up: 473.6, down: 473.6) UMTS = 'umts' # UMTS/3G (up: 384.0, down: 384.0) HSDPA = 'hsdpa' # HSDPA (up: 5760.0, down: 13,980.0) LTE = 'lte' # LTE (up: 58,000, down: 173,000) EVDO = 'evdo' # EVDO (up: 75,000, down: 280,000) FULL = 'full' # No limit, the default (up: 0.0, down: 0.0) class Network ( webdriver . Remote ): @property def network_connection ( self ): \"\"\"Returns an integer bitmask specifying the network connection type. Android only. Possible values are available through the enumeration `appium.webdriver.ConnectionType` \"\"\" return self . execute ( Command . GET_NETWORK_CONNECTION , {})[ 'value' ] def set_network_connection ( self , connection_type ): \"\"\"Sets the network connection type. Android only. Possible values: Value (Alias) | Data | Wifi | Airplane Mode ------------------------------------------------- 0 (None) | 0 | 0 | 0 1 (Airplane Mode) | 0 | 0 | 1 2 (Wifi only) | 0 | 1 | 0 4 (Data only) | 1 | 0 | 0 6 (All network on) | 1 | 1 | 0 These are available through the enumeration `appium.webdriver.ConnectionType` Args: connection_type (int): a member of the enum appium.webdriver.ConnectionType Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'parameters' : { 'type' : connection_type } } return self . execute ( Command . SET_NETWORK_CONNECTION , data )[ 'value' ] def toggle_wifi ( self ): \"\"\"Toggle the wifi on the device, Android only. Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . TOGGLE_WIFI , {}) return self def set_network_speed ( self , speed_type ): \"\"\"Set the network speed emulation. Android Emulator only. Args: speed_type (str): The network speed type. A member of the const appium.webdriver.extensions.android.network.NetSpeed. Usage: self.driver.set_network_speed(NetSpeed.LTE) Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" constants = extract_const_attributes ( NetSpeed ) if speed_type not in constants . values (): logger . warning ( '{} is unknown. Consider using one of {} constants. (e.g. {}.LTE)' . format ( speed_type , list ( constants . keys ()), NetSpeed . __name__ )) self . execute ( Command . SET_NETWORK_SPEED , { 'netspeed' : speed_type }) return self # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . TOGGLE_WIFI ] = \\ ( 'POST' , '/session/$sessionId/appium/device/toggle_wifi' ) self . command_executor . _commands [ Command . GET_NETWORK_CONNECTION ] = \\ ( 'GET' , '/session/$sessionId/network_connection' ) self . command_executor . _commands [ Command . SET_NETWORK_CONNECTION ] = \\ ( 'POST' , '/session/$sessionId/network_connection' ) self . command_executor . _commands [ Command . SET_NETWORK_SPEED ] = \\ ( 'POST' , '/session/$sessionId/appium/device/network_speed' ) Classes NetSpeed class NetSpeed ( / , * args , ** kwargs ) View Source class NetSpeed ( object ): GSM = 'gsm' # GSM/CSD (up: 14.4(kbps), down: 14.4(kbps)) SCSD = 'scsd' # HSCSD (up: 14.4, down: 57.6) GPRS = 'gprs' # GPRS (up: 28.8, down: 57.6) EDGE = 'edge' # EDGE/EGPRS (up: 473.6, down: 473.6) UMTS = 'umts' # UMTS/3G (up: 384.0, down: 384.0) HSDPA = 'hsdpa' # HSDPA (up: 5760.0, down: 13,980.0) LTE = 'lte' # LTE (up: 58,000, down: 173,000) EVDO = 'evdo' # EVDO (up: 75,000, down: 280,000) FULL = 'full' # No limit, the default (up: 0.0, down: 0.0) Class variables EDGE EVDO FULL GPRS GSM HSDPA LTE SCSD UMTS Network class Network ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Network ( webdriver . Remote ) : @ property def network_connection ( self ) : \"\"\" Returns an integer bitmask specifying the network connection type. Android only . Possible values are available through the enumeration ` appium . webdriver . ConnectionType ` \"\"\" return self . execute ( Command . GET_NETWORK_CONNECTION , {} ) [ ' value ' ] def set_network_connection ( self , connection_type ) : \"\"\" Sets the network connection type. Android only. Possible values : Value ( Alias ) | Data | Wifi | Airplane Mode ------------------------------------------------- 0 ( None ) | 0 | 0 | 0 1 ( Airplane Mode ) | 0 | 0 | 1 2 ( Wifi only ) | 0 | 1 | 0 4 ( Data only ) | 1 | 0 | 0 6 ( All network on ) | 1 | 1 | 0 These are available through the enumeration ` appium . webdriver . ConnectionType ` Args : connection_type ( int ) : a member of the enum appium . webdriver . ConnectionType Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' parameters ' : { ' type ' : connection_type } } return self . execute ( Command . SET_NETWORK_CONNECTION , data ) [ ' value ' ] def toggle_wifi ( self ) : \"\"\" Toggle the wifi on the device, Android only. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . TOGGLE_WIFI , {} ) return self def set_network_speed ( self , speed_type ) : \"\"\" Set the network speed emulation. Android Emulator only . Args : speed_type ( str ) : The network speed type . A member of the const appium . webdriver . extensions . android . network . NetSpeed . Usage : self . driver . set_network_speed ( NetSpeed . LTE ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" constants = extract_const_attributes ( NetSpeed ) if speed_type not in constants . values () : logger . warning ( ' {} is unknown. Consider using one of {} constants. (e.g. {}.LTE) ' . format ( speed_type , list ( constants . keys ()) , NetSpeed . __name__ )) self . execute ( Command . SET_NETWORK_SPEED , { ' netspeed ' : speed_type } ) return self # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . TOGGLE_WIFI ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/toggle_wifi ' ) self . command_executor . _commands [ Command . GET_NETWORK_CONNECTION ] = \\ ( ' GET ' , ' /session/$sessionId/network_connection ' ) self . command_executor . _commands [ Command . SET_NETWORK_CONNECTION ] = \\ ( ' POST ' , ' /session/$sessionId/network_connection ' ) self . command_executor . _commands [ Command . SET_NETWORK_SPEED ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/network_speed ' ) Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name network_connection Returns an integer bitmask specifying the network connection type. Android only. Possible values are available through the enumeration appium.webdriver.ConnectionType orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) set_network_connection def set_network_connection ( self , connection_type ) Sets the network connection type. Android only. Possible values: Value (Alias) | Data | Wifi | Airplane Mode ------------------------------------------------- 0 (None) | 0 | 0 | 0 1 (Airplane Mode) | 0 | 0 | 1 2 (Wifi only) | 0 | 1 | 0 4 (Data only) | 1 | 0 | 0 6 (All network on) | 1 | 1 | 0 These are available through the enumeration appium.webdriver.ConnectionType Args: connection_type (int): a member of the enum appium.webdriver.ConnectionType Returns: appium.webdriver.webdriver.WebDriver View Source def set_network_connection ( self , connection_type ) : \"\"\" Sets the network connection type. Android only. Possible values : Value ( Alias ) | Data | Wifi | Airplane Mode ------------------------------------------------- 0 ( None ) | 0 | 0 | 0 1 ( Airplane Mode ) | 0 | 0 | 1 2 ( Wifi only ) | 0 | 1 | 0 4 ( Data only ) | 1 | 0 | 0 6 ( All network on ) | 1 | 1 | 0 These are available through the enumeration ` appium . webdriver . ConnectionType ` Args : connection_type ( int ) : a member of the enum appium . webdriver . ConnectionType Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' parameters ' : { ' type ' : connection_type } } return self . execute ( Command . SET_NETWORK_CONNECTION , data ) [ ' value ' ] set_network_speed def set_network_speed ( self , speed_type ) Set the network speed emulation. Android Emulator only. Args: speed_type (str): The network speed type. A member of the const appium.webdriver.extensions.android.network.NetSpeed. Usage: self.driver.set_network_speed(NetSpeed.LTE) Returns: appium.webdriver.webdriver.WebDriver View Source def set_network_speed ( self , speed_type ) : \"\"\" Set the network speed emulation. Android Emulator only . Args : speed_type ( str ) : The network speed type . A member of the const appium . webdriver . extensions . android . network . NetSpeed . Usage : self . driver . set_network_speed ( NetSpeed . LTE ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" constants = extract_const_attributes ( NetSpeed ) if speed_type not in constants . values () : logger . warning ( ' {} is unknown. Consider using one of {} constants. (e.g. {}.LTE) ' . format ( speed_type , list ( constants . keys ()) , NetSpeed . __name__ )) self . execute ( Command . SET_NETWORK_SPEED , { ' netspeed ' : speed_type } ) return self set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name ) toggle_wifi def toggle_wifi ( self ) Toggle the wifi on the device, Android only. Returns: appium.webdriver.webdriver.WebDriver View Source def toggle_wifi ( self ) : \"\"\" Toggle the wifi on the device, Android only. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . TOGGLE_WIFI , {} ) return self","title":"Network"},{"location":"reference/appium/webdriver/extensions/android/network/#module-appiumwebdriverextensionsandroidnetwork","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from appium.common.helper import extract_const_attributes from appium.common.logger import logger from appium.webdriver.mobilecommand import MobileCommand as Command class NetSpeed ( object ): GSM = 'gsm' # GSM/CSD (up: 14.4(kbps), down: 14.4(kbps)) SCSD = 'scsd' # HSCSD (up: 14.4, down: 57.6) GPRS = 'gprs' # GPRS (up: 28.8, down: 57.6) EDGE = 'edge' # EDGE/EGPRS (up: 473.6, down: 473.6) UMTS = 'umts' # UMTS/3G (up: 384.0, down: 384.0) HSDPA = 'hsdpa' # HSDPA (up: 5760.0, down: 13,980.0) LTE = 'lte' # LTE (up: 58,000, down: 173,000) EVDO = 'evdo' # EVDO (up: 75,000, down: 280,000) FULL = 'full' # No limit, the default (up: 0.0, down: 0.0) class Network ( webdriver . Remote ): @property def network_connection ( self ): \"\"\"Returns an integer bitmask specifying the network connection type. Android only. Possible values are available through the enumeration `appium.webdriver.ConnectionType` \"\"\" return self . execute ( Command . GET_NETWORK_CONNECTION , {})[ 'value' ] def set_network_connection ( self , connection_type ): \"\"\"Sets the network connection type. Android only. Possible values: Value (Alias) | Data | Wifi | Airplane Mode ------------------------------------------------- 0 (None) | 0 | 0 | 0 1 (Airplane Mode) | 0 | 0 | 1 2 (Wifi only) | 0 | 1 | 0 4 (Data only) | 1 | 0 | 0 6 (All network on) | 1 | 1 | 0 These are available through the enumeration `appium.webdriver.ConnectionType` Args: connection_type (int): a member of the enum appium.webdriver.ConnectionType Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" data = { 'parameters' : { 'type' : connection_type } } return self . execute ( Command . SET_NETWORK_CONNECTION , data )[ 'value' ] def toggle_wifi ( self ): \"\"\"Toggle the wifi on the device, Android only. Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . TOGGLE_WIFI , {}) return self def set_network_speed ( self , speed_type ): \"\"\"Set the network speed emulation. Android Emulator only. Args: speed_type (str): The network speed type. A member of the const appium.webdriver.extensions.android.network.NetSpeed. Usage: self.driver.set_network_speed(NetSpeed.LTE) Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" constants = extract_const_attributes ( NetSpeed ) if speed_type not in constants . values (): logger . warning ( '{} is unknown. Consider using one of {} constants. (e.g. {}.LTE)' . format ( speed_type , list ( constants . keys ()), NetSpeed . __name__ )) self . execute ( Command . SET_NETWORK_SPEED , { 'netspeed' : speed_type }) return self # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . TOGGLE_WIFI ] = \\ ( 'POST' , '/session/$sessionId/appium/device/toggle_wifi' ) self . command_executor . _commands [ Command . GET_NETWORK_CONNECTION ] = \\ ( 'GET' , '/session/$sessionId/network_connection' ) self . command_executor . _commands [ Command . SET_NETWORK_CONNECTION ] = \\ ( 'POST' , '/session/$sessionId/network_connection' ) self . command_executor . _commands [ Command . SET_NETWORK_SPEED ] = \\ ( 'POST' , '/session/$sessionId/appium/device/network_speed' )","title":"Module appium.webdriver.extensions.android.network"},{"location":"reference/appium/webdriver/extensions/android/network/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/android/network/#netspeed","text":"class NetSpeed ( / , * args , ** kwargs ) View Source class NetSpeed ( object ): GSM = 'gsm' # GSM/CSD (up: 14.4(kbps), down: 14.4(kbps)) SCSD = 'scsd' # HSCSD (up: 14.4, down: 57.6) GPRS = 'gprs' # GPRS (up: 28.8, down: 57.6) EDGE = 'edge' # EDGE/EGPRS (up: 473.6, down: 473.6) UMTS = 'umts' # UMTS/3G (up: 384.0, down: 384.0) HSDPA = 'hsdpa' # HSDPA (up: 5760.0, down: 13,980.0) LTE = 'lte' # LTE (up: 58,000, down: 173,000) EVDO = 'evdo' # EVDO (up: 75,000, down: 280,000) FULL = 'full' # No limit, the default (up: 0.0, down: 0.0)","title":"NetSpeed"},{"location":"reference/appium/webdriver/extensions/android/network/#class-variables","text":"EDGE EVDO FULL GPRS GSM HSDPA LTE SCSD UMTS","title":"Class variables"},{"location":"reference/appium/webdriver/extensions/android/network/#network","text":"class Network ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Network ( webdriver . Remote ) : @ property def network_connection ( self ) : \"\"\" Returns an integer bitmask specifying the network connection type. Android only . Possible values are available through the enumeration ` appium . webdriver . ConnectionType ` \"\"\" return self . execute ( Command . GET_NETWORK_CONNECTION , {} ) [ ' value ' ] def set_network_connection ( self , connection_type ) : \"\"\" Sets the network connection type. Android only. Possible values : Value ( Alias ) | Data | Wifi | Airplane Mode ------------------------------------------------- 0 ( None ) | 0 | 0 | 0 1 ( Airplane Mode ) | 0 | 0 | 1 2 ( Wifi only ) | 0 | 1 | 0 4 ( Data only ) | 1 | 0 | 0 6 ( All network on ) | 1 | 1 | 0 These are available through the enumeration ` appium . webdriver . ConnectionType ` Args : connection_type ( int ) : a member of the enum appium . webdriver . ConnectionType Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' parameters ' : { ' type ' : connection_type } } return self . execute ( Command . SET_NETWORK_CONNECTION , data ) [ ' value ' ] def toggle_wifi ( self ) : \"\"\" Toggle the wifi on the device, Android only. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . TOGGLE_WIFI , {} ) return self def set_network_speed ( self , speed_type ) : \"\"\" Set the network speed emulation. Android Emulator only . Args : speed_type ( str ) : The network speed type . A member of the const appium . webdriver . extensions . android . network . NetSpeed . Usage : self . driver . set_network_speed ( NetSpeed . LTE ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" constants = extract_const_attributes ( NetSpeed ) if speed_type not in constants . values () : logger . warning ( ' {} is unknown. Consider using one of {} constants. (e.g. {}.LTE) ' . format ( speed_type , list ( constants . keys ()) , NetSpeed . __name__ )) self . execute ( Command . SET_NETWORK_SPEED , { ' netspeed ' : speed_type } ) return self # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . TOGGLE_WIFI ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/toggle_wifi ' ) self . command_executor . _commands [ Command . GET_NETWORK_CONNECTION ] = \\ ( ' GET ' , ' /session/$sessionId/network_connection ' ) self . command_executor . _commands [ Command . SET_NETWORK_CONNECTION ] = \\ ( ' POST ' , ' /session/$sessionId/network_connection ' ) self . command_executor . _commands [ Command . SET_NETWORK_SPEED ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/network_speed ' )","title":"Network"},{"location":"reference/appium/webdriver/extensions/android/network/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/android/network/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/android/network/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name network_connection Returns an integer bitmask specifying the network connection type. Android only. Possible values are available through the enumeration appium.webdriver.ConnectionType orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/android/network/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/android/network/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/android/network/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/android/network/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/android/network/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/android/network/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/android/network/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/android/network/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/android/network/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/android/network/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/android/network/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/android/network/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/android/network/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/android/network/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/android/network/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/android/network/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/android/network/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/android/network/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/android/network/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/android/network/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/android/network/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/android/network/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/android/network/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/android/network/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/android/network/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/android/network/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/android/network/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/android/network/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/android/network/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/android/network/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/android/network/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/android/network/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/android/network/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/android/network/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/android/network/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/android/network/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/android/network/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/android/network/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/android/network/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/android/network/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/android/network/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/android/network/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/android/network/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/android/network/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/android/network/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/android/network/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/android/network/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/android/network/#set_network_connection","text":"def set_network_connection ( self , connection_type ) Sets the network connection type. Android only. Possible values: Value (Alias) | Data | Wifi | Airplane Mode ------------------------------------------------- 0 (None) | 0 | 0 | 0 1 (Airplane Mode) | 0 | 0 | 1 2 (Wifi only) | 0 | 1 | 0 4 (Data only) | 1 | 0 | 0 6 (All network on) | 1 | 1 | 0 These are available through the enumeration appium.webdriver.ConnectionType Args: connection_type (int): a member of the enum appium.webdriver.ConnectionType Returns: appium.webdriver.webdriver.WebDriver View Source def set_network_connection ( self , connection_type ) : \"\"\" Sets the network connection type. Android only. Possible values : Value ( Alias ) | Data | Wifi | Airplane Mode ------------------------------------------------- 0 ( None ) | 0 | 0 | 0 1 ( Airplane Mode ) | 0 | 0 | 1 2 ( Wifi only ) | 0 | 1 | 0 4 ( Data only ) | 1 | 0 | 0 6 ( All network on ) | 1 | 1 | 0 These are available through the enumeration ` appium . webdriver . ConnectionType ` Args : connection_type ( int ) : a member of the enum appium . webdriver . ConnectionType Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" data = { ' parameters ' : { ' type ' : connection_type } } return self . execute ( Command . SET_NETWORK_CONNECTION , data ) [ ' value ' ]","title":"set_network_connection"},{"location":"reference/appium/webdriver/extensions/android/network/#set_network_speed","text":"def set_network_speed ( self , speed_type ) Set the network speed emulation. Android Emulator only. Args: speed_type (str): The network speed type. A member of the const appium.webdriver.extensions.android.network.NetSpeed. Usage: self.driver.set_network_speed(NetSpeed.LTE) Returns: appium.webdriver.webdriver.WebDriver View Source def set_network_speed ( self , speed_type ) : \"\"\" Set the network speed emulation. Android Emulator only . Args : speed_type ( str ) : The network speed type . A member of the const appium . webdriver . extensions . android . network . NetSpeed . Usage : self . driver . set_network_speed ( NetSpeed . LTE ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" constants = extract_const_attributes ( NetSpeed ) if speed_type not in constants . values () : logger . warning ( ' {} is unknown. Consider using one of {} constants. (e.g. {}.LTE) ' . format ( speed_type , list ( constants . keys ()) , NetSpeed . __name__ )) self . execute ( Command . SET_NETWORK_SPEED , { ' netspeed ' : speed_type } ) return self","title":"set_network_speed"},{"location":"reference/appium/webdriver/extensions/android/network/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/android/network/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/android/network/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/android/network/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/android/network/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/android/network/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/android/network/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/android/network/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/android/network/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/android/network/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/android/network/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/android/network/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/android/network/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/android/network/#toggle_wifi","text":"def toggle_wifi ( self ) Toggle the wifi on the device, Android only. Returns: appium.webdriver.webdriver.WebDriver View Source def toggle_wifi ( self ) : \"\"\" Toggle the wifi on the device, Android only. Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . TOGGLE_WIFI , {} ) return self","title":"toggle_wifi"},{"location":"reference/appium/webdriver/extensions/android/performance/","text":"Module appium.webdriver.extensions.android.performance View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from appium.webdriver.mobilecommand import MobileCommand as Command class Performance ( webdriver . Remote ): def get_performance_data ( self , package_name , data_type , data_read_timeout = None ): \"\"\"Returns the information of the system state which is supported to read as like cpu, memory, network traffic, and battery. Android only. Args: package_name (str): The package name of the application data_type (str): The type of system state which wants to read. It should be one of the supported performance data types. Check :func:`.get_performance_data_types` for supported types data_read_timeout (:obj:`int`, optional): The number of attempts to read Usage: self.driver.get_performance_data('my.app.package', 'cpuinfo', 5) Returns: dict: The data along to `data_type` \"\"\" data = { 'packageName' : package_name , 'dataType' : data_type } if data_read_timeout is not None : data [ 'dataReadTimeout' ] = data_read_timeout return self . execute ( Command . GET_PERFORMANCE_DATA , data )[ 'value' ] def get_performance_data_types ( self ): \"\"\"Returns the information types of the system state which is supported to read as like cpu, memory, network traffic, and battery. Android only. Usage: self.driver.get_performance_data_types() Returns: list: Available data types \"\"\" return self . execute ( Command . GET_PERFORMANCE_DATA_TYPES )[ 'value' ] # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . GET_PERFORMANCE_DATA ] = \\ ( 'POST' , '/session/$sessionId/appium/getPerformanceData' ) self . command_executor . _commands [ Command . GET_PERFORMANCE_DATA_TYPES ] = \\ ( 'POST' , '/session/$sessionId/appium/performanceData/types' ) Classes Performance class Performance ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Performance ( webdriver . Remote ) : def get_performance_data ( self , package_name , data_type , data_read_timeout = None ) : \"\"\" Returns the information of the system state which is supported to read as like cpu , memory , network traffic , and battery . Android only . Args : package_name ( str ) : The package name of the application data_type ( str ) : The type of system state which wants to read . It should be one of the supported performance data types . Check : func :`. get_performance_data_types ` for supported types data_read_timeout ( : obj :` int `, optional ) : The number of attempts to read Usage : self . driver . get_performance_data ( ' my.app.package ' , ' cpuinfo ' , 5 ) Returns : dict : The data along to ` data_type ` \"\"\" data = { ' packageName ' : package_name , ' dataType ' : data_type } if data_read_timeout is not None : data [ ' dataReadTimeout ' ] = data_read_timeout return self . execute ( Command . GET_PERFORMANCE_DATA , data ) [ ' value ' ] def get_performance_data_types ( self ) : \"\"\" Returns the information types of the system state which is supported to read as like cpu , memory , network traffic , and battery . Android only . Usage : self . driver . get_performance_data_types () Returns : list : Available data types \"\"\" return self . execute ( Command . GET_PERFORMANCE_DATA_TYPES ) [ ' value ' ] # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . GET_PERFORMANCE_DATA ] = \\ ( ' POST ' , ' /session/$sessionId/appium/getPerformanceData ' ) self . command_executor . _commands [ Command . GET_PERFORMANCE_DATA_TYPES ] = \\ ( ' POST ' , ' /session/$sessionId/appium/performanceData/types ' ) Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_performance_data def get_performance_data ( self , package_name , data_type , data_read_timeout = None ) Returns the information of the system state which is supported to read as like cpu, memory, network traffic, and battery. Android only. Args: package_name (str): The package name of the application data_type (str): The type of system state which wants to read. It should be one of the supported performance data types. Check :func: .get_performance_data_types for supported types data_read_timeout (:obj: int , optional): The number of attempts to read Usage: self.driver.get_performance_data('my.app.package', 'cpuinfo', 5) Returns: dict: The data along to data_type View Source def get_performance_data ( self , package_name , data_type , data_read_timeout = None ) : \"\"\" Returns the information of the system state which is supported to read as like cpu , memory , network traffic , and battery . Android only . Args : package_name ( str ) : The package name of the application data_type ( str ) : The type of system state which wants to read . It should be one of the supported performance data types . Check : func :`. get_performance_data_types ` for supported types data_read_timeout ( : obj :` int `, optional ) : The number of attempts to read Usage : self . driver . get_performance_data ( ' my.app.package ' , ' cpuinfo ' , 5 ) Returns : dict : The data along to ` data_type ` \"\"\" data = { ' packageName ' : package_name , ' dataType ' : data_type } if data_read_timeout is not None : data [ ' dataReadTimeout ' ] = data_read_timeout return self . execute ( Command . GET_PERFORMANCE_DATA , data ) [ ' value ' ] get_performance_data_types def get_performance_data_types ( self ) Returns the information types of the system state which is supported to read as like cpu, memory, network traffic, and battery. Android only. Usage: self.driver.get_performance_data_types() Returns: list: Available data types View Source def get_performance_data_types ( self ) : \"\"\" Returns the information types of the system state which is supported to read as like cpu , memory , network traffic , and battery . Android only . Usage : self . driver . get_performance_data_types () Returns : list : Available data types \"\"\" return self . execute ( Command . GET_PERFORMANCE_DATA_TYPES ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"Performance"},{"location":"reference/appium/webdriver/extensions/android/performance/#module-appiumwebdriverextensionsandroidperformance","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from appium.webdriver.mobilecommand import MobileCommand as Command class Performance ( webdriver . Remote ): def get_performance_data ( self , package_name , data_type , data_read_timeout = None ): \"\"\"Returns the information of the system state which is supported to read as like cpu, memory, network traffic, and battery. Android only. Args: package_name (str): The package name of the application data_type (str): The type of system state which wants to read. It should be one of the supported performance data types. Check :func:`.get_performance_data_types` for supported types data_read_timeout (:obj:`int`, optional): The number of attempts to read Usage: self.driver.get_performance_data('my.app.package', 'cpuinfo', 5) Returns: dict: The data along to `data_type` \"\"\" data = { 'packageName' : package_name , 'dataType' : data_type } if data_read_timeout is not None : data [ 'dataReadTimeout' ] = data_read_timeout return self . execute ( Command . GET_PERFORMANCE_DATA , data )[ 'value' ] def get_performance_data_types ( self ): \"\"\"Returns the information types of the system state which is supported to read as like cpu, memory, network traffic, and battery. Android only. Usage: self.driver.get_performance_data_types() Returns: list: Available data types \"\"\" return self . execute ( Command . GET_PERFORMANCE_DATA_TYPES )[ 'value' ] # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . GET_PERFORMANCE_DATA ] = \\ ( 'POST' , '/session/$sessionId/appium/getPerformanceData' ) self . command_executor . _commands [ Command . GET_PERFORMANCE_DATA_TYPES ] = \\ ( 'POST' , '/session/$sessionId/appium/performanceData/types' )","title":"Module appium.webdriver.extensions.android.performance"},{"location":"reference/appium/webdriver/extensions/android/performance/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/android/performance/#performance","text":"class Performance ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Performance ( webdriver . Remote ) : def get_performance_data ( self , package_name , data_type , data_read_timeout = None ) : \"\"\" Returns the information of the system state which is supported to read as like cpu , memory , network traffic , and battery . Android only . Args : package_name ( str ) : The package name of the application data_type ( str ) : The type of system state which wants to read . It should be one of the supported performance data types . Check : func :`. get_performance_data_types ` for supported types data_read_timeout ( : obj :` int `, optional ) : The number of attempts to read Usage : self . driver . get_performance_data ( ' my.app.package ' , ' cpuinfo ' , 5 ) Returns : dict : The data along to ` data_type ` \"\"\" data = { ' packageName ' : package_name , ' dataType ' : data_type } if data_read_timeout is not None : data [ ' dataReadTimeout ' ] = data_read_timeout return self . execute ( Command . GET_PERFORMANCE_DATA , data ) [ ' value ' ] def get_performance_data_types ( self ) : \"\"\" Returns the information types of the system state which is supported to read as like cpu , memory , network traffic , and battery . Android only . Usage : self . driver . get_performance_data_types () Returns : list : Available data types \"\"\" return self . execute ( Command . GET_PERFORMANCE_DATA_TYPES ) [ ' value ' ] # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . GET_PERFORMANCE_DATA ] = \\ ( ' POST ' , ' /session/$sessionId/appium/getPerformanceData ' ) self . command_executor . _commands [ Command . GET_PERFORMANCE_DATA_TYPES ] = \\ ( ' POST ' , ' /session/$sessionId/appium/performanceData/types ' )","title":"Performance"},{"location":"reference/appium/webdriver/extensions/android/performance/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/android/performance/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/android/performance/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/android/performance/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/android/performance/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/android/performance/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/android/performance/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/android/performance/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/android/performance/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/android/performance/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/android/performance/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/android/performance/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/android/performance/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/android/performance/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/android/performance/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/android/performance/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/android/performance/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/android/performance/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/android/performance/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/android/performance/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/android/performance/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/android/performance/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/android/performance/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/android/performance/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/android/performance/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/android/performance/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/android/performance/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/android/performance/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/android/performance/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/android/performance/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/android/performance/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/android/performance/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/android/performance/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/android/performance/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/android/performance/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/android/performance/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/android/performance/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/android/performance/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/android/performance/#get_performance_data","text":"def get_performance_data ( self , package_name , data_type , data_read_timeout = None ) Returns the information of the system state which is supported to read as like cpu, memory, network traffic, and battery. Android only. Args: package_name (str): The package name of the application data_type (str): The type of system state which wants to read. It should be one of the supported performance data types. Check :func: .get_performance_data_types for supported types data_read_timeout (:obj: int , optional): The number of attempts to read Usage: self.driver.get_performance_data('my.app.package', 'cpuinfo', 5) Returns: dict: The data along to data_type View Source def get_performance_data ( self , package_name , data_type , data_read_timeout = None ) : \"\"\" Returns the information of the system state which is supported to read as like cpu , memory , network traffic , and battery . Android only . Args : package_name ( str ) : The package name of the application data_type ( str ) : The type of system state which wants to read . It should be one of the supported performance data types . Check : func :`. get_performance_data_types ` for supported types data_read_timeout ( : obj :` int `, optional ) : The number of attempts to read Usage : self . driver . get_performance_data ( ' my.app.package ' , ' cpuinfo ' , 5 ) Returns : dict : The data along to ` data_type ` \"\"\" data = { ' packageName ' : package_name , ' dataType ' : data_type } if data_read_timeout is not None : data [ ' dataReadTimeout ' ] = data_read_timeout return self . execute ( Command . GET_PERFORMANCE_DATA , data ) [ ' value ' ]","title":"get_performance_data"},{"location":"reference/appium/webdriver/extensions/android/performance/#get_performance_data_types","text":"def get_performance_data_types ( self ) Returns the information types of the system state which is supported to read as like cpu, memory, network traffic, and battery. Android only. Usage: self.driver.get_performance_data_types() Returns: list: Available data types View Source def get_performance_data_types ( self ) : \"\"\" Returns the information types of the system state which is supported to read as like cpu , memory , network traffic , and battery . Android only . Usage : self . driver . get_performance_data_types () Returns : list : Available data types \"\"\" return self . execute ( Command . GET_PERFORMANCE_DATA_TYPES ) [ ' value ' ]","title":"get_performance_data_types"},{"location":"reference/appium/webdriver/extensions/android/performance/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/android/performance/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/android/performance/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/android/performance/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/android/performance/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/android/performance/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/android/performance/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/android/performance/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/android/performance/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/android/performance/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/android/performance/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/android/performance/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/android/performance/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/android/performance/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/android/performance/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/android/performance/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/android/performance/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/android/performance/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/android/performance/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/android/performance/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/android/performance/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/android/performance/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/android/performance/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/android/performance/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/android/performance/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/android/power/","text":"Module appium.webdriver.extensions.android.power View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from appium.webdriver.mobilecommand import MobileCommand as Command class Power ( webdriver . Remote ): AC_OFF , AC_ON = 'off' , 'on' def set_power_capacity ( self , percent ): \"\"\"Emulate power capacity change on the connected emulator. Android only. Args: percent (int): The power capacity to be set. Can be set from 0 to 100 Usage: self.driver.set_power_capacity(50) Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . SET_POWER_CAPACITY , { 'percent' : percent }) return self def set_power_ac ( self , ac_state ): \"\"\"Emulate power state change on the connected emulator. Android only. Args: ac_state (str): The power ac state to be set. Use `.AC_OFF`, `.AC_ON` Usage: self.driver.set_power_ac(Power.AC_OFF) self.driver.set_power_ac(Power.AC_ON) Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . SET_POWER_AC , { 'state' : ac_state }) return self # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . SET_POWER_CAPACITY ] = \\ ( 'POST' , '/session/$sessionId/appium/device/power_capacity' ) self . command_executor . _commands [ Command . SET_POWER_AC ] = \\ ( 'POST' , '/session/$sessionId/appium/device/power_ac' ) Classes Power class Power ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Power ( webdriver . Remote ) : AC_OFF , AC_ON = ' off ' , ' on ' def set_power_capacity ( self , percent ) : \"\"\" Emulate power capacity change on the connected emulator. Android only . Args : percent ( int ) : The power capacity to be set . Can be set from 0 to 100 Usage : self . driver . set_power_capacity ( 50 ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SET_POWER_CAPACITY , { ' percent ' : percent } ) return self def set_power_ac ( self , ac_state ) : \"\"\" Emulate power state change on the connected emulator. Android only . Args : ac_state ( str ) : The power ac state to be set . Use `. AC_OFF `, `. AC_ON ` Usage : self . driver . set_power_ac ( Power . AC_OFF ) self . driver . set_power_ac ( Power . AC_ON ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SET_POWER_AC , { ' state ' : ac_state } ) return self # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . SET_POWER_CAPACITY ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/power_capacity ' ) self . command_executor . _commands [ Command . SET_POWER_AC ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/power_ac ' ) Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Class variables AC_OFF AC_ON Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_power_ac def set_power_ac ( self , ac_state ) Emulate power state change on the connected emulator. Android only. Args: ac_state (str): The power ac state to be set. Use .AC_OFF , .AC_ON Usage: self.driver.set_power_ac(Power.AC_OFF) self.driver.set_power_ac(Power.AC_ON) Returns: appium.webdriver.webdriver.WebDriver View Source def set_power_ac ( self , ac_state ) : \"\"\" Emulate power state change on the connected emulator. Android only . Args : ac_state ( str ) : The power ac state to be set . Use `. AC_OFF `, `. AC_ON ` Usage : self . driver . set_power_ac ( Power . AC_OFF ) self . driver . set_power_ac ( Power . AC_ON ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SET_POWER_AC , { ' state ' : ac_state } ) return self set_power_capacity def set_power_capacity ( self , percent ) Emulate power capacity change on the connected emulator. Android only. Args: percent (int): The power capacity to be set. Can be set from 0 to 100 Usage: self.driver.set_power_capacity(50) Returns: appium.webdriver.webdriver.WebDriver View Source def set_power_capacity ( self , percent ) : \"\"\" Emulate power capacity change on the connected emulator. Android only . Args : percent ( int ) : The power capacity to be set . Can be set from 0 to 100 Usage : self . driver . set_power_capacity ( 50 ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SET_POWER_CAPACITY , { ' percent ' : percent } ) return self set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"Power"},{"location":"reference/appium/webdriver/extensions/android/power/#module-appiumwebdriverextensionsandroidpower","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from appium.webdriver.mobilecommand import MobileCommand as Command class Power ( webdriver . Remote ): AC_OFF , AC_ON = 'off' , 'on' def set_power_capacity ( self , percent ): \"\"\"Emulate power capacity change on the connected emulator. Android only. Args: percent (int): The power capacity to be set. Can be set from 0 to 100 Usage: self.driver.set_power_capacity(50) Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . SET_POWER_CAPACITY , { 'percent' : percent }) return self def set_power_ac ( self , ac_state ): \"\"\"Emulate power state change on the connected emulator. Android only. Args: ac_state (str): The power ac state to be set. Use `.AC_OFF`, `.AC_ON` Usage: self.driver.set_power_ac(Power.AC_OFF) self.driver.set_power_ac(Power.AC_ON) Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . SET_POWER_AC , { 'state' : ac_state }) return self # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . SET_POWER_CAPACITY ] = \\ ( 'POST' , '/session/$sessionId/appium/device/power_capacity' ) self . command_executor . _commands [ Command . SET_POWER_AC ] = \\ ( 'POST' , '/session/$sessionId/appium/device/power_ac' )","title":"Module appium.webdriver.extensions.android.power"},{"location":"reference/appium/webdriver/extensions/android/power/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/android/power/#power","text":"class Power ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Power ( webdriver . Remote ) : AC_OFF , AC_ON = ' off ' , ' on ' def set_power_capacity ( self , percent ) : \"\"\" Emulate power capacity change on the connected emulator. Android only . Args : percent ( int ) : The power capacity to be set . Can be set from 0 to 100 Usage : self . driver . set_power_capacity ( 50 ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SET_POWER_CAPACITY , { ' percent ' : percent } ) return self def set_power_ac ( self , ac_state ) : \"\"\" Emulate power state change on the connected emulator. Android only . Args : ac_state ( str ) : The power ac state to be set . Use `. AC_OFF `, `. AC_ON ` Usage : self . driver . set_power_ac ( Power . AC_OFF ) self . driver . set_power_ac ( Power . AC_ON ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SET_POWER_AC , { ' state ' : ac_state } ) return self # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . SET_POWER_CAPACITY ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/power_capacity ' ) self . command_executor . _commands [ Command . SET_POWER_AC ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/power_ac ' )","title":"Power"},{"location":"reference/appium/webdriver/extensions/android/power/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/android/power/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/android/power/#class-variables","text":"AC_OFF AC_ON","title":"Class variables"},{"location":"reference/appium/webdriver/extensions/android/power/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/android/power/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/android/power/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/android/power/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/android/power/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/android/power/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/android/power/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/android/power/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/android/power/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/android/power/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/android/power/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/android/power/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/android/power/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/android/power/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/android/power/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/android/power/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/android/power/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/android/power/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/android/power/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/android/power/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/android/power/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/android/power/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/android/power/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/android/power/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/android/power/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/android/power/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/android/power/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/android/power/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/android/power/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/android/power/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/android/power/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/android/power/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/android/power/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/android/power/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/android/power/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/android/power/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/android/power/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/android/power/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/android/power/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/android/power/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/android/power/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/android/power/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/android/power/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/android/power/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/android/power/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/android/power/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/android/power/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/android/power/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/android/power/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/android/power/#set_power_ac","text":"def set_power_ac ( self , ac_state ) Emulate power state change on the connected emulator. Android only. Args: ac_state (str): The power ac state to be set. Use .AC_OFF , .AC_ON Usage: self.driver.set_power_ac(Power.AC_OFF) self.driver.set_power_ac(Power.AC_ON) Returns: appium.webdriver.webdriver.WebDriver View Source def set_power_ac ( self , ac_state ) : \"\"\" Emulate power state change on the connected emulator. Android only . Args : ac_state ( str ) : The power ac state to be set . Use `. AC_OFF `, `. AC_ON ` Usage : self . driver . set_power_ac ( Power . AC_OFF ) self . driver . set_power_ac ( Power . AC_ON ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SET_POWER_AC , { ' state ' : ac_state } ) return self","title":"set_power_ac"},{"location":"reference/appium/webdriver/extensions/android/power/#set_power_capacity","text":"def set_power_capacity ( self , percent ) Emulate power capacity change on the connected emulator. Android only. Args: percent (int): The power capacity to be set. Can be set from 0 to 100 Usage: self.driver.set_power_capacity(50) Returns: appium.webdriver.webdriver.WebDriver View Source def set_power_capacity ( self , percent ) : \"\"\" Emulate power capacity change on the connected emulator. Android only . Args : percent ( int ) : The power capacity to be set . Can be set from 0 to 100 Usage : self . driver . set_power_capacity ( 50 ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SET_POWER_CAPACITY , { ' percent ' : percent } ) return self","title":"set_power_capacity"},{"location":"reference/appium/webdriver/extensions/android/power/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/android/power/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/android/power/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/android/power/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/android/power/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/android/power/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/android/power/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/android/power/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/android/power/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/android/power/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/android/power/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/android/power/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/android/sms/","text":"Module appium.webdriver.extensions.android.sms View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from appium.webdriver.mobilecommand import MobileCommand as Command class Sms ( webdriver . Remote ): def send_sms ( self , phone_number , message ): \"\"\"Emulate send SMS event on the connected emulator. Android only. Args: phone_number (str): The phone number of message sender message (str): The message to send Usage: self.driver.send_sms('555-123-4567', 'Hey lol') Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . SEND_SMS , { 'phoneNumber' : phone_number , 'message' : message }) return self # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . SEND_SMS ] = \\ ( 'POST' , '/session/$sessionId/appium/device/send_sms' ) Classes Sms class Sms ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Sms ( webdriver . Remote ) : def send_sms ( self , phone_number , message ) : \"\"\" Emulate send SMS event on the connected emulator. Android only . Args : phone_number ( str ) : The phone number of message sender message ( str ) : The message to send Usage : self . driver . send_sms ( ' 555-123-4567 ' , ' Hey lol ' ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SEND_SMS , { ' phoneNumber ' : phone_number , ' message ' : message } ) return self # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . SEND_SMS ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/send_sms ' ) Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) send_sms def send_sms ( self , phone_number , message ) Emulate send SMS event on the connected emulator. Android only. Args: phone_number (str): The phone number of message sender message (str): The message to send Usage: self.driver.send_sms('555-123-4567', 'Hey lol') Returns: appium.webdriver.webdriver.WebDriver View Source def send_sms ( self , phone_number , message ) : \"\"\" Emulate send SMS event on the connected emulator. Android only . Args : phone_number ( str ) : The phone number of message sender message ( str ) : The message to send Usage : self . driver . send_sms ( ' 555-123-4567 ' , ' Hey lol ' ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SEND_SMS , { ' phoneNumber ' : phone_number , ' message ' : message } ) return self set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"Sms"},{"location":"reference/appium/webdriver/extensions/android/sms/#module-appiumwebdriverextensionsandroidsms","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from appium.webdriver.mobilecommand import MobileCommand as Command class Sms ( webdriver . Remote ): def send_sms ( self , phone_number , message ): \"\"\"Emulate send SMS event on the connected emulator. Android only. Args: phone_number (str): The phone number of message sender message (str): The message to send Usage: self.driver.send_sms('555-123-4567', 'Hey lol') Returns: `appium.webdriver.webdriver.WebDriver` \"\"\" self . execute ( Command . SEND_SMS , { 'phoneNumber' : phone_number , 'message' : message }) return self # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . SEND_SMS ] = \\ ( 'POST' , '/session/$sessionId/appium/device/send_sms' )","title":"Module appium.webdriver.extensions.android.sms"},{"location":"reference/appium/webdriver/extensions/android/sms/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/android/sms/#sms","text":"class Sms ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class Sms ( webdriver . Remote ) : def send_sms ( self , phone_number , message ) : \"\"\" Emulate send SMS event on the connected emulator. Android only . Args : phone_number ( str ) : The phone number of message sender message ( str ) : The message to send Usage : self . driver . send_sms ( ' 555-123-4567 ' , ' Hey lol ' ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SEND_SMS , { ' phoneNumber ' : phone_number , ' message ' : message } ) return self # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . SEND_SMS ] = \\ ( ' POST ' , ' /session/$sessionId/appium/device/send_sms ' )","title":"Sms"},{"location":"reference/appium/webdriver/extensions/android/sms/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/android/sms/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/android/sms/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/android/sms/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/android/sms/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/android/sms/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/android/sms/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/android/sms/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/android/sms/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/android/sms/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/android/sms/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/android/sms/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/android/sms/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/android/sms/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/android/sms/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/android/sms/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/android/sms/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/android/sms/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/android/sms/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/android/sms/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/android/sms/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/android/sms/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/android/sms/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/android/sms/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/android/sms/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/android/sms/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/android/sms/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/android/sms/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/android/sms/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/android/sms/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/android/sms/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/android/sms/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/android/sms/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/android/sms/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/android/sms/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/android/sms/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/android/sms/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/android/sms/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/android/sms/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/android/sms/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/android/sms/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/android/sms/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/android/sms/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/android/sms/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/android/sms/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/android/sms/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/android/sms/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/android/sms/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/android/sms/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/android/sms/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/android/sms/#send_sms","text":"def send_sms ( self , phone_number , message ) Emulate send SMS event on the connected emulator. Android only. Args: phone_number (str): The phone number of message sender message (str): The message to send Usage: self.driver.send_sms('555-123-4567', 'Hey lol') Returns: appium.webdriver.webdriver.WebDriver View Source def send_sms ( self , phone_number , message ) : \"\"\" Emulate send SMS event on the connected emulator. Android only . Args : phone_number ( str ) : The phone number of message sender message ( str ) : The message to send Usage : self . driver . send_sms ( ' 555-123-4567 ' , ' Hey lol ' ) Returns : ` appium . webdriver . webdriver . WebDriver ` \"\"\" self . execute ( Command . SEND_SMS , { ' phoneNumber ' : phone_number , ' message ' : message } ) return self","title":"send_sms"},{"location":"reference/appium/webdriver/extensions/android/sms/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/android/sms/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/android/sms/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/android/sms/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/android/sms/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/android/sms/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/android/sms/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/android/sms/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/android/sms/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/android/sms/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/android/sms/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/android/sms/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/android/sms/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"},{"location":"reference/appium/webdriver/extensions/android/system_bars/","text":"Module appium.webdriver.extensions.android.system_bars View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from appium.webdriver.mobilecommand import MobileCommand as Command class SystemBars ( webdriver . Remote ): def get_system_bars ( self ): \"\"\"Retrieve visibility and bounds information of the status and navigation bars. Android only. Returns: A dictionary whose keys are - statusBar - visible - x - y - width - height - navigationBar - visible - x - y - width - height \"\"\" return self . execute ( Command . GET_SYSTEM_BARS )[ 'value' ] # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . GET_SYSTEM_BARS ] = \\ ( 'GET' , '/session/$sessionId/appium/device/system_bars' ) Classes SystemBars class SystemBars ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class SystemBars ( webdriver . Remote ) : def get_system_bars ( self ) : \"\"\" Retrieve visibility and bounds information of the status and navigation bars. Android only . Returns : A dictionary whose keys are - statusBar - visible - x - y - width - height - navigationBar - visible - x - y - width - height \"\"\" return self . execute ( Command . GET_SYSTEM_BARS ) [ ' value ' ] # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . GET_SYSTEM_BARS ] = \\ ( ' GET ' , ' /session/$sessionId/appium/device/system_bars ' ) Ancestors (in MRO) selenium.webdriver.remote.webdriver.WebDriver Descendants appium.webdriver.webdriver.WebDriver Instance variables application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles Methods add_cookie def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } ) back def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK ) close def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE ) create_web_element def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c ) delete_all_cookies def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES ) delete_cookie def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } ) execute def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id } execute_async_script def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] execute_script def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ] file_detector_context def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector find_element def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ] find_element_by_class_name def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name ) find_element_by_css_selector def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector ) find_element_by_id def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ ) find_element_by_link_text def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text ) find_element_by_name def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name ) find_element_by_partial_link_text def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_element_by_tag_name def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name ) find_element_by_xpath def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath ) find_elements def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or [] find_elements_by_class_name def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name ) find_elements_by_css_selector def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector ) find_elements_by_id def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ ) find_elements_by_link_text def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text ) find_elements_by_name def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name ) find_elements_by_partial_link_text def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text ) find_elements_by_tag_name def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name ) find_elements_by_xpath def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath ) forward def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD ) fullscreen_window def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW ) get def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } ) get_cookie def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None get_cookies def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ] get_log def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ] get_screenshot_as_base64 def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ] get_screenshot_as_file def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True get_screenshot_as_png def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' )) get_system_bars def get_system_bars ( self ) Retrieve visibility and bounds information of the status and navigation bars. Android only. Returns: A dictionary whose keys are - statusBar - visible - x - y - width - height - navigationBar - visible - x - y - width - height View Source def get_system_bars ( self ) : \"\"\" Retrieve visibility and bounds information of the status and navigation bars. Android only . Returns : A dictionary whose keys are - statusBar - visible - x - y - width - height - navigationBar - visible - x - y - width - height \"\"\" return self . execute ( Command . GET_SYSTEM_BARS ) [ ' value ' ] get_window_position def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) } get_window_rect def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ] get_window_size def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) } implicitly_wait def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } ) maximize_window def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params ) minimize_window def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW ) quit def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client () refresh def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH ) save_screenshot def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename ) set_page_load_timeout def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } ) set_script_timeout def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } ) set_window_position def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } ) set_window_rect def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ] set_window_size def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } ) start_client def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass start_session def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c stop_client def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass switch_to_active_element def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element switch_to_alert def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert switch_to_default_content def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content () switch_to_frame def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference ) switch_to_window def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"System Bars"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#module-appiumwebdriverextensionsandroidsystem_bars","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #!/usr/bin/env python # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. from selenium import webdriver from appium.webdriver.mobilecommand import MobileCommand as Command class SystemBars ( webdriver . Remote ): def get_system_bars ( self ): \"\"\"Retrieve visibility and bounds information of the status and navigation bars. Android only. Returns: A dictionary whose keys are - statusBar - visible - x - y - width - height - navigationBar - visible - x - y - width - height \"\"\" return self . execute ( Command . GET_SYSTEM_BARS )[ 'value' ] # pylint: disable=protected-access def _addCommands ( self ): self . command_executor . _commands [ Command . GET_SYSTEM_BARS ] = \\ ( 'GET' , '/session/$sessionId/appium/device/system_bars' )","title":"Module appium.webdriver.extensions.android.system_bars"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#classes","text":"","title":"Classes"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#systembars","text":"class SystemBars ( command_executor = 'http://127.0.0.1:4444/wd/hub' , desired_capabilities = None , browser_profile = None , proxy = None , keep_alive = False , file_detector = None , options = None ) Controls a browser by sending commands to a remote server. This server is expected to be running the WebDriver wire protocol as defined at https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol :Attributes: - session_id - String ID of the browser session started and controlled by this WebDriver. - capabilities - Dictionaty of effective capabilities of this browser session as returned by the remote server. See https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities - command_executor - remote_connection.RemoteConnection object used to execute commands. - error_handler - errorhandler.ErrorHandler object used to handle errors. View Source class SystemBars ( webdriver . Remote ) : def get_system_bars ( self ) : \"\"\" Retrieve visibility and bounds information of the status and navigation bars. Android only . Returns : A dictionary whose keys are - statusBar - visible - x - y - width - height - navigationBar - visible - x - y - width - height \"\"\" return self . execute ( Command . GET_SYSTEM_BARS ) [ ' value ' ] # pylint : disable = protected - access def _addCommands ( self ) : self . command_executor . _commands [ Command . GET_SYSTEM_BARS ] = \\ ( ' GET ' , ' /session/$sessionId/appium/device/system_bars ' )","title":"SystemBars"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#ancestors-in-mro","text":"selenium.webdriver.remote.webdriver.WebDriver","title":"Ancestors (in MRO)"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#descendants","text":"appium.webdriver.webdriver.WebDriver","title":"Descendants"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#instance-variables","text":"application_cache Returns a ApplicationCache Object to interact with the browser app cache current_url Gets the URL of the current page. :Usage: driver.current_url current_window_handle Returns the handle of the current window. :Usage: driver.current_window_handle desired_capabilities returns the drivers current desired capabilities being used file_detector log_types Gets a list of the available log types :Usage: driver.log_types mobile name Returns the name of the underlying browser for this instance. :Usage: name = driver.name orientation Gets the current orientation of the device :Usage: orientation = driver.orientation page_source Gets the source of the current page. :Usage: driver.page_source switch_to :Returns: - SwitchTo: an object containing all options to switch focus into :Usage: element = driver.switch_to.active_element alert = driver.switch_to.alert driver.switch_to.default_content() driver.switch_to.frame('frame_name') driver.switch_to.frame(1) driver.switch_to.frame(driver.find_elements_by_tag_name(\"iframe\")[0]) driver.switch_to.parent_frame() driver.switch_to.window('main') title Returns the title of the current page. :Usage: title = driver.title window_handles Returns the handles of all windows within the current session. :Usage: driver.window_handles","title":"Instance variables"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#methods","text":"","title":"Methods"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#add_cookie","text":"def add_cookie ( self , cookie_dict ) Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \"name\" and \"value\"; optional keys - \"path\", \"domain\", \"secure\", \"expiry\" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) View Source def add_cookie ( self , cookie_dict ): \"\"\" Adds a cookie to your current session. :Args: - cookie_dict: A dictionary object, with required keys - \" name \" and \" value \"; optional keys - \" path \", \" domain \", \" secure \", \" expiry \" Usage: driver.add_cookie({'name' : 'foo', 'value' : 'bar'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/'}) driver.add_cookie({'name' : 'foo', 'value' : 'bar', 'path' : '/', 'secure':True}) \"\"\" self . execute ( Command . ADD_COOKIE , { 'cookie': cookie_dict } )","title":"add_cookie"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#back","text":"def back ( self ) Goes one step backward in the browser history. :Usage: driver.back() View Source def back ( self ): \"\"\" Goes one step backward in the browser history. :Usage: driver.back() \"\"\" self . execute ( Command . GO_BACK )","title":"back"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#close","text":"def close ( self ) Closes the current window. :Usage: driver.close() View Source def close ( self ): \"\"\" Closes the current window. :Usage: driver.close() \"\"\" self . execute ( Command . CLOSE )","title":"close"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#create_web_element","text":"def create_web_element ( self , element_id ) Creates a web element with the specified element_id . View Source def create_web_element ( self , element_id ) : \"\"\" Creates a web element with the specified `element_id`. \"\"\" return self . _web_element_cls ( self , element_id , w3c = self . w3c )","title":"create_web_element"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#delete_all_cookies","text":"def delete_all_cookies ( self ) Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() View Source def delete_all_cookies ( self ): \"\"\" Delete all cookies in the scope of the session. :Usage: driver.delete_all_cookies() \"\"\" self . execute ( Command . DELETE_ALL_COOKIES )","title":"delete_all_cookies"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#delete_cookie","text":"def delete_cookie ( self , name ) Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') View Source def delete_cookie ( self , name ): \"\"\" Deletes a single cookie with the given name. :Usage: driver.delete_cookie('my_cookie') \"\"\" self . execute ( Command . DELETE_COOKIE , { 'name' : name } )","title":"delete_cookie"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#execute","text":"def execute ( self , driver_command , params = None ) Sends a command to be executed by a command.CommandExecutor. :Args: - driver_command: The name of the command to execute as a string. - params: A dictionary of named parameters to send with the command. :Returns: The command's JSON response loaded into a dictionary object. View Source def execute ( self , driver_command , params = None ) : \"\"\" Sends a command to be executed by a command . CommandExecutor . : Args : - driver_command : The name of the command to execute as a string . - params : A dictionary of named parameters to send with the command . : Returns : The command ' s JSON response loaded into a dictionary object. \"\"\" if self . session_id is not None : if not params : params = { ' sessionId ' : self . session_id } elif ' sessionId ' not in params : params [ ' sessionId ' ] = self . session_id params = self . _wrap_value ( params ) response = self . command_executor . execute ( driver_command , params ) if response : self . error_handler . check_response ( response ) response [ ' value ' ] = self . _unwrap_value ( response . get ( ' value ' , None )) return response # If the server doesn ' t send a response, assume the command was # a success return { ' success ' : 0 , ' value ' : None , ' sessionId ' : self . session_id }","title":"execute"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#execute_async_script","text":"def execute_async_script ( self , script , * args ) Asynchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: script = \"var callback = arguments[arguments.length - 1]; \" \"window.setTimeout(function(){ callback('timeout') }, 3000);\" driver.execute_async_script(script) View Source def execute_async_script ( self , script , * args ) : \"\"\" Asynchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : script = \" var callback = arguments[arguments.length - 1]; \" \\ \" window.setTimeout(function(){ callback('timeout') }, 3000); \" driver . execute_async_script ( script ) \"\"\" converted_args = list ( args ) if self . w3c : command = Command . W3C_EXECUTE_SCRIPT_ASYNC else : command = Command . EXECUTE_ASYNC_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_async_script"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#execute_script","text":"def execute_script ( self , script , * args ) Synchronously Executes JavaScript in the current window/frame. :Args: - script: The JavaScript to execute. - *args: Any applicable arguments for your JavaScript. :Usage: driver.execute_script('return document.title;') View Source def execute_script ( self , script , * args ) : \"\"\" Synchronously Executes JavaScript in the current window / frame . : Args : - script : The JavaScript to execute . - \\ * args : Any applicable arguments for your JavaScript . : Usage : driver . execute_script ( ' return document.title; ' ) \"\"\" converted_args = list ( args ) command = None if self . w3c : command = Command . W3C_EXECUTE_SCRIPT else : command = Command . EXECUTE_SCRIPT return self . execute ( command , { ' script ' : script , ' args ' : converted_args } ) [ ' value ' ]","title":"execute_script"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#file_detector_context","text":"def file_detector_context ( self , file_detector_class , * args , ** kwargs ) Overrides the current file detector (if necessary) in limited context. Ensures the original file detector is set afterwards. Example: with webdriver.file_detector_context(UselessFileDetector): someinput.send_keys('/etc/hosts') :Args: - file_detector_class - Class of the desired file detector. If the class is different from the current file_detector, then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager. - args - Optional arguments that get passed to the file detector class during instantiation. - kwargs - Keyword arguments, passed the same way as args. View Source @ contextmanager def file_detector_context ( self , file_detector_class , * args , ** kwargs ) : \"\"\" Overrides the current file detector ( if necessary ) in limited context . Ensures the original file detector is set afterwards . Example : with webdriver . file_detector_context ( UselessFileDetector ) : someinput . send_keys ( ' /etc/hosts ' ) : Args : - file_detector_class - Class of the desired file detector . If the class is different from the current file_detector , then the class is instantiated with args and kwargs and used as a file detector during the duration of the context manager . - args - Optional arguments that get passed to the file detector class during instantiation . - kwargs - Keyword arguments , passed the same way as args . \"\"\" last_detector = None if not isinstance ( self . file_detector , file_detector_class ) : last_detector = self . file_detector self . file_detector = file_detector_class ( * args , ** kwargs ) try : yield finally : if last_detector is not None : self . file_detector = last_detector","title":"file_detector_context"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#find_element","text":"def find_element ( self , by = 'id' , value = None ) Find an element given a By strategy and locator. Prefer the find_element_by_* methods when possible. :Usage: element = driver.find_element(By.ID, 'foo') :rtype: WebElement View Source def find_element ( self , by = By . ID , value = None ) : \"\"\" Find an element given a By strategy and locator . Prefer the find_element_by_ * methods when possible . : Usage : element = driver . find_element ( By . ID , ' foo ' ) : rtype : WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value return self . execute ( Command . FIND_ELEMENT , { ' using ' : by , ' value ' : value } ) [ ' value ' ]","title":"find_element"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#find_element_by_class_name","text":"def find_element_by_class_name ( self , name ) Finds an element by class name. :Args: - name: The class name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_class_name('foo') View Source def find_element_by_class_name ( self , name ) : \"\"\" Finds an element by class name . : Args : - name : The class name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_class_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . CLASS_NAME , value = name )","title":"find_element_by_class_name"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#find_element_by_css_selector","text":"def find_element_by_css_selector ( self , css_selector ) Finds an element by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_css_selector('#foo') View Source def find_element_by_css_selector ( self , css_selector ) : \"\"\" Finds an element by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_css_selector ( ' #foo ' ) \"\"\" return self . find_element ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_element_by_css_selector"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#find_element_by_id","text":"def find_element_by_id ( self , id_ ) Finds an element by id. :Args: - id_ - The id of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_id('foo') View Source def find_element_by_id ( self , id_ ) : \"\"\" Finds an element by id. :Args : - id \\ _ - The id of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_id ( ' foo ' ) \"\"\" return self . find_element ( by = By . ID , value = id_ )","title":"find_element_by_id"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#find_element_by_link_text","text":"def find_element_by_link_text ( self , link_text ) Finds an element by link text. :Args: - link_text: The text of the element to be found. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_link_text('Sign In') View Source def find_element_by_link_text ( self , link_text ) : \"\"\" Finds an element by link text . : Args : - link_text : The text of the element to be found . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_link_text ( ' Sign In ' ) \"\"\" return self . find_element ( by = By . LINK_TEXT , value = link_text )","title":"find_element_by_link_text"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#find_element_by_name","text":"def find_element_by_name ( self , name ) Finds an element by name. :Args: - name: The name of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_name('foo') View Source def find_element_by_name ( self , name ) : \"\"\" Finds an element by name . : Args : - name : The name of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_name ( ' foo ' ) \"\"\" return self . find_element ( by = By . NAME , value = name )","title":"find_element_by_name"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#find_element_by_partial_link_text","text":"def find_element_by_partial_link_text ( self , link_text ) Finds an element by a partial match of its link text. :Args: - link_text: The text of the element to partially match on. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_partial_link_text('Sign') View Source def find_element_by_partial_link_text ( self , link_text ) : \"\"\" Finds an element by a partial match of its link text . : Args : - link_text : The text of the element to partially match on . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_element ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_element_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#find_element_by_tag_name","text":"def find_element_by_tag_name ( self , name ) Finds an element by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_tag_name('h1') View Source def find_element_by_tag_name ( self , name ) : \"\"\" Finds an element by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_tag_name ( ' h1 ' ) \"\"\" return self . find_element ( by = By . TAG_NAME , value = name )","title":"find_element_by_tag_name"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#find_element_by_xpath","text":"def find_element_by_xpath ( self , xpath ) Finds an element by xpath. :Args: - xpath - The xpath locator of the element to find. :Returns: - WebElement - the element if it was found :Raises: - NoSuchElementException - if the element wasn't found :Usage: element = driver.find_element_by_xpath('//div/td[1]') View Source def find_element_by_xpath ( self , xpath ) : \"\"\" Finds an element by xpath . : Args : - xpath - The xpath locator of the element to find . : Returns : - WebElement - the element if it was found : Raises : - NoSuchElementException - if the element wasn ' t found :Usage : element = driver . find_element_by_xpath ( ' //div/td[1] ' ) \"\"\" return self . find_element ( by = By . XPATH , value = xpath )","title":"find_element_by_xpath"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#find_elements","text":"def find_elements ( self , by = 'id' , value = None ) Find elements given a By strategy and locator. Prefer the find_elements_by_* methods when possible. :Usage: elements = driver.find_elements(By.CLASS_NAME, 'foo') :rtype: list of WebElement View Source def find_elements ( self , by = By . ID , value = None ) : \"\"\" Find elements given a By strategy and locator . Prefer the find_elements_by_ * methods when possible . : Usage : elements = driver . find_elements ( By . CLASS_NAME , ' foo ' ) : rtype : list of WebElement \"\"\" if self . w3c : if by == By . ID : by = By . CSS_SELECTOR value = ' [id=\"%s\"] ' % value elif by == By . TAG_NAME : by = By . CSS_SELECTOR elif by == By . CLASS_NAME : by = By . CSS_SELECTOR value = \" .%s \" % value elif by == By . NAME : by = By . CSS_SELECTOR value = ' [name=\"%s\"] ' % value # Return empty list if driver returns null # See https : // github . com / SeleniumHQ / selenium / issues / 4555 return self . execute ( Command . FIND_ELEMENTS , { ' using ' : by , ' value ' : value } ) [ ' value ' ] or []","title":"find_elements"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#find_elements_by_class_name","text":"def find_elements_by_class_name ( self , name ) Finds elements by class name. :Args: - name: The class name of the elements to find. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_class_name('foo') View Source def find_elements_by_class_name ( self , name ) : \"\"\" Finds elements by class name . : Args : - name : The class name of the elements to find . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_class_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . CLASS_NAME , value = name )","title":"find_elements_by_class_name"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#find_elements_by_css_selector","text":"def find_elements_by_css_selector ( self , css_selector ) Finds elements by css selector. :Args: - css_selector - CSS selector string, ex: 'a.nav#home' :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_css_selector('.foo') View Source def find_elements_by_css_selector ( self , css_selector ) : \"\"\" Finds elements by css selector . : Args : - css_selector - CSS selector string , ex : ' a.nav#home ' : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_css_selector ( ' .foo ' ) \"\"\" return self . find_elements ( by = By . CSS_SELECTOR , value = css_selector )","title":"find_elements_by_css_selector"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#find_elements_by_id","text":"def find_elements_by_id ( self , id_ ) Finds multiple elements by id. :Args: - id_ - The id of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_id('foo') View Source def find_elements_by_id ( self , id_ ) : \"\"\" Finds multiple elements by id . : Args : - id \\ _ - The id of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_id ( ' foo ' ) \"\"\" return self . find_elements ( by = By . ID , value = id_ )","title":"find_elements_by_id"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#find_elements_by_link_text","text":"def find_elements_by_link_text ( self , text ) Finds elements by link text. :Args: - link_text: The text of the elements to be found. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_link_text('Sign In') View Source def find_elements_by_link_text ( self , text ) : \"\"\" Finds elements by link text . : Args : - link_text : The text of the elements to be found . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_link_text ( ' Sign In ' ) \"\"\" return self . find_elements ( by = By . LINK_TEXT , value = text )","title":"find_elements_by_link_text"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#find_elements_by_name","text":"def find_elements_by_name ( self , name ) Finds elements by name. :Args: - name: The name of the elements to find. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_name('foo') View Source def find_elements_by_name ( self , name ) : \"\"\" Finds elements by name . : Args : - name : The name of the elements to find . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_name ( ' foo ' ) \"\"\" return self . find_elements ( by = By . NAME , value = name )","title":"find_elements_by_name"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#find_elements_by_partial_link_text","text":"def find_elements_by_partial_link_text ( self , link_text ) Finds elements by a partial match of their link text. :Args: - link_text: The text of the element to partial match on. :Returns: - list of webelement - a list with elements if any was found. an empty list if not :Usage: elements = driver.find_elements_by_partial_link_text('Sign') View Source def find_elements_by_partial_link_text ( self , link_text ) : \"\"\" Finds elements by a partial match of their link text . : Args : - link_text : The text of the element to partial match on . : Returns : - list of webelement - a list with elements if any was found . an empty list if not : Usage : elements = driver . find_elements_by_partial_link_text ( ' Sign ' ) \"\"\" return self . find_elements ( by = By . PARTIAL_LINK_TEXT , value = link_text )","title":"find_elements_by_partial_link_text"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#find_elements_by_tag_name","text":"def find_elements_by_tag_name ( self , name ) Finds elements by tag name. :Args: - name - name of html tag (eg: h1, a, span) :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_tag_name('h1') View Source def find_elements_by_tag_name ( self , name ) : \"\"\" Finds elements by tag name . : Args : - name - name of html tag ( eg : h1 , a , span ) : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_tag_name ( ' h1 ' ) \"\"\" return self . find_elements ( by = By . TAG_NAME , value = name )","title":"find_elements_by_tag_name"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#find_elements_by_xpath","text":"def find_elements_by_xpath ( self , xpath ) Finds multiple elements by xpath. :Args: - xpath - The xpath locator of the elements to be found. :Returns: - list of WebElement - a list with elements if any was found. An empty list if not :Usage: elements = driver.find_elements_by_xpath(\"//div[contains(@class, 'foo')]\") View Source def find_elements_by_xpath ( self , xpath ) : \"\"\" Finds multiple elements by xpath . : Args : - xpath - The xpath locator of the elements to be found . : Returns : - list of WebElement - a list with elements if any was found . An empty list if not : Usage : elements = driver . find_elements_by_xpath ( \" //div[contains(@class, 'foo')] \" ) \"\"\" return self . find_elements ( by = By . XPATH , value = xpath )","title":"find_elements_by_xpath"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#forward","text":"def forward ( self ) Goes one step forward in the browser history. :Usage: driver.forward() View Source def forward ( self ): \"\"\" Goes one step forward in the browser history. :Usage: driver.forward() \"\"\" self . execute ( Command . GO_FORWARD )","title":"forward"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#fullscreen_window","text":"def fullscreen_window ( self ) Invokes the window manager-specific 'full screen' operation View Source def fullscreen_window ( self ): \"\"\" Invokes the window manager-specific 'full screen' operation \"\"\" self . execute ( Command . FULLSCREEN_WINDOW )","title":"fullscreen_window"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#get","text":"def get ( self , url ) Loads a web page in the current browser session. View Source def get ( self , url ): \"\"\" Loads a web page in the current browser session. \"\"\" self . execute ( Command . GET , { 'url' : url } )","title":"get"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#get_cookie","text":"def get_cookie ( self , name ) Get a single cookie by name. Returns the cookie if found, None if not. :Usage: driver.get_cookie('my_cookie') View Source def get_cookie ( self , name ) : \"\"\" Get a single cookie by name . Returns the cookie if found , None if not . : Usage : driver . get_cookie ( ' my_cookie ' ) \"\"\" if self . w3c : try : return self . execute ( Command . GET_COOKIE , { ' name ' : name } ) [ ' value ' ] except NoSuchCookieException : return None else : cookies = self . get_cookies () for cookie in cookies : if cookie [ ' name ' ] == name : return cookie return None","title":"get_cookie"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#get_cookies","text":"def get_cookies ( self ) Returns a set of dictionaries, corresponding to cookies visible in the current session. :Usage: driver.get_cookies() View Source def get_cookies ( self ) : \"\"\" Returns a set of dictionaries , corresponding to cookies visible in the current session . : Usage : driver . get_cookies () \"\"\" return self . execute ( Command . GET_ALL_COOKIES ) [ ' value ' ]","title":"get_cookies"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#get_log","text":"def get_log ( self , log_type ) Gets the log for a given log type :Args: - log_type: type of log that which will be returned :Usage: driver.get_log('browser') driver.get_log('driver') driver.get_log('client') driver.get_log('server') View Source def get_log ( self , log_type ) : \"\"\" Gets the log for a given log type : Args : - log_type : type of log that which will be returned : Usage : driver . get_log ( ' browser ' ) driver . get_log ( ' driver ' ) driver . get_log ( ' client ' ) driver . get_log ( ' server ' ) \"\"\" return self . execute ( Command . GET_LOG , { ' type ' : log_type } ) [ ' value ' ]","title":"get_log"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#get_screenshot_as_base64","text":"def get_screenshot_as_base64 ( self ) Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML. :Usage: driver.get_screenshot_as_base64() View Source def get_screenshot_as_base64 ( self ) : \"\"\" Gets the screenshot of the current window as a base64 encoded string which is useful in embedded images in HTML . : Usage : driver . get_screenshot_as_base64 () \"\"\" return self . execute ( Command . SCREENSHOT ) [ ' value ' ]","title":"get_screenshot_as_base64"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#get_screenshot_as_file","text":"def get_screenshot_as_file ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.get_screenshot_as_file('/Screenshots/foo.png') View Source def get_screenshot_as_file ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . get_screenshot_as_file ( ' /Screenshots/foo.png ' ) \"\"\" if not filename . lower () . endswith ( ' .png ' ) : warnings . warn ( \" name used for saved screenshot does not match file \" \" type. It should end with a `.png` extension \" , UserWarning ) png = self . get_screenshot_as_png () try : with open ( filename , ' wb ' ) as f : f . write ( png ) except IOError : return False finally : del png return True","title":"get_screenshot_as_file"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#get_screenshot_as_png","text":"def get_screenshot_as_png ( self ) Gets the screenshot of the current window as a binary data. :Usage: driver.get_screenshot_as_png() View Source def get_screenshot_as_png ( self ) : \"\"\" Gets the screenshot of the current window as a binary data . : Usage : driver . get_screenshot_as_png () \"\"\" return base64 . b64decode ( self . get_screenshot_as_base64 () . encode ( ' ascii ' ))","title":"get_screenshot_as_png"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#get_system_bars","text":"def get_system_bars ( self ) Retrieve visibility and bounds information of the status and navigation bars. Android only. Returns: A dictionary whose keys are - statusBar - visible - x - y - width - height - navigationBar - visible - x - y - width - height View Source def get_system_bars ( self ) : \"\"\" Retrieve visibility and bounds information of the status and navigation bars. Android only . Returns : A dictionary whose keys are - statusBar - visible - x - y - width - height - navigationBar - visible - x - y - width - height \"\"\" return self . execute ( Command . GET_SYSTEM_BARS ) [ ' value ' ]","title":"get_system_bars"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#get_window_position","text":"def get_window_position ( self , windowHandle = 'current' ) Gets the x,y position of the current window. :Usage: driver.get_window_position() View Source def get_window_position ( self , windowHandle = ' current ' ) : \"\"\" Gets the x , y position of the current window . : Usage : driver . get_window_position () \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) position = self . get_window_rect () else : position = self . execute ( Command . GET_WINDOW_POSITION , { ' windowHandle ' : windowHandle } ) [ ' value ' ] return { k : position [ k ] for k in ( ' x ' , ' y ' ) }","title":"get_window_position"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#get_window_rect","text":"def get_window_rect ( self ) Gets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.get_window_rect() View Source def get_window_rect ( self ) : \"\"\" Gets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . get_window_rect () \"\"\" return self . execute ( Command . GET_WINDOW_RECT ) [ ' value ' ]","title":"get_window_rect"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#get_window_size","text":"def get_window_size ( self , windowHandle = 'current' ) Gets the width and height of the current window. :Usage: driver.get_window_size() View Source def get_window_size ( self , windowHandle = ' current ' ) : \"\"\" Gets the width and height of the current window . : Usage : driver . get_window_size () \"\"\" command = Command . GET_WINDOW_SIZE if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) size = self . get_window_rect () else : size = self . execute ( command , { ' windowHandle ' : windowHandle } ) if size . get ( ' value ' , None ) is not None : size = size [ ' value ' ] return { k : size [ k ] for k in ( ' width ' , ' height ' ) }","title":"get_window_size"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#implicitly_wait","text":"def implicitly_wait ( self , time_to_wait ) Sets a sticky timeout to implicitly wait for an element to be found, or a command to complete. This method only needs to be called one time per session. To set the timeout for calls to execute_async_script, see set_script_timeout. :Args: - time_to_wait: Amount of time to wait (in seconds) :Usage: driver.implicitly_wait(30) View Source def implicitly_wait ( self , time_to_wait ) : \"\"\" Sets a sticky timeout to implicitly wait for an element to be found , or a command to complete . This method only needs to be called one time per session . To set the timeout for calls to execute_async_script , see set_script_timeout . : Args : - time_to_wait : Amount of time to wait ( in seconds ) : Usage : driver . implicitly_wait ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' implicit ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . IMPLICIT_WAIT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"implicitly_wait"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#maximize_window","text":"def maximize_window ( self ) Maximizes the current window that webdriver is using View Source def maximize_window ( self ) : \"\"\" Maximizes the current window that webdriver is using \"\"\" params = None command = Command . W3C_MAXIMIZE_WINDOW if not self . w3c : command = Command . MAXIMIZE_WINDOW params = { ' windowHandle ' : ' current ' } self . execute ( command , params )","title":"maximize_window"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#minimize_window","text":"def minimize_window ( self ) Invokes the window manager-specific 'minimize' operation View Source def minimize_window ( self ): \"\"\" Invokes the window manager-specific 'minimize' operation \"\"\" self . execute ( Command . MINIMIZE_WINDOW )","title":"minimize_window"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#quit","text":"def quit ( self ) Quits the driver and closes every associated window. :Usage: driver.quit() View Source def quit ( self ): \"\"\" Quits the driver and closes every associated window. :Usage: driver.quit() \"\"\" try : self . execute ( Command . QUIT ) finally : self . stop_client ()","title":"quit"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#refresh","text":"def refresh ( self ) Refreshes the current page. :Usage: driver.refresh() View Source def refresh ( self ): \"\"\" Refreshes the current page. :Usage: driver.refresh() \"\"\" self . execute ( Command . REFRESH )","title":"refresh"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#save_screenshot","text":"def save_screenshot ( self , filename ) Saves a screenshot of the current window to a PNG image file. Returns False if there is any IOError, else returns True. Use full paths in your filename. :Args: - filename: The full path you wish to save your screenshot to. This should end with a .png extension. :Usage: driver.save_screenshot('/Screenshots/foo.png') View Source def save_screenshot ( self , filename ) : \"\"\" Saves a screenshot of the current window to a PNG image file . Returns False if there is any IOError , else returns True . Use full paths in your filename . : Args : - filename : The full path you wish to save your screenshot to . This should end with a `. png ` extension . : Usage : driver . save_screenshot ( ' /Screenshots/foo.png ' ) \"\"\" return self . get_screenshot_as_file ( filename )","title":"save_screenshot"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#set_page_load_timeout","text":"def set_page_load_timeout ( self , time_to_wait ) Set the amount of time to wait for a page load to complete before throwing an error. :Args: - time_to_wait: The amount of time to wait :Usage: driver.set_page_load_timeout(30) View Source def set_page_load_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time to wait for a page load to complete before throwing an error . : Args : - time_to_wait : The amount of time to wait : Usage : driver . set_page_load_timeout ( 30 ) \"\"\" try : self . execute ( Command . SET_TIMEOUTS , { ' pageLoad ' : int ( float ( time_to_wait ) * 1000 ) } ) except WebDriverException : self . execute ( Command . SET_TIMEOUTS , { ' ms ' : float ( time_to_wait ) * 1000 , ' type ' : ' page load ' } )","title":"set_page_load_timeout"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#set_script_timeout","text":"def set_script_timeout ( self , time_to_wait ) Set the amount of time that the script should wait during an execute_async_script call before throwing an error. :Args: - time_to_wait: The amount of time to wait (in seconds) :Usage: driver.set_script_timeout(30) View Source def set_script_timeout ( self , time_to_wait ) : \"\"\" Set the amount of time that the script should wait during an execute_async_script call before throwing an error . : Args : - time_to_wait : The amount of time to wait ( in seconds ) : Usage : driver . set_script_timeout ( 30 ) \"\"\" if self . w3c : self . execute ( Command . SET_TIMEOUTS , { ' script ' : int ( float ( time_to_wait ) * 1000 ) } ) else : self . execute ( Command . SET_SCRIPT_TIMEOUT , { ' ms ' : float ( time_to_wait ) * 1000 } )","title":"set_script_timeout"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#set_window_position","text":"def set_window_position ( self , x , y , windowHandle = 'current' ) Sets the x,y position of the current window. (window.moveTo) :Args: - x: the x-coordinate in pixels to set the window position - y: the y-coordinate in pixels to set the window position :Usage: driver.set_window_position(0,0) View Source def set_window_position ( self , x , y , windowHandle = ' current ' ) : \"\"\" Sets the x , y position of the current window . ( window . moveTo ) : Args : - x : the x - coordinate in pixels to set the window position - y : the y - coordinate in pixels to set the window position : Usage : driver . set_window_position ( 0 , 0 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) return self . set_window_rect ( x = int ( x ) , y = int ( y )) else : self . execute ( Command . SET_WINDOW_POSITION , { ' x ' : int ( x ) , ' y ' : int ( y ) , ' windowHandle ' : windowHandle } )","title":"set_window_position"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#set_window_rect","text":"def set_window_rect ( self , x = None , y = None , width = None , height = None ) Sets the x, y coordinates of the window as well as height and width of the current window. :Usage: driver.set_window_rect(x=10, y=10) driver.set_window_rect(width=100, height=200) driver.set_window_rect(x=10, y=10, width=100, height=200) View Source def set_window_rect ( self , x = None , y = None , width = None , height = None ) : \"\"\" Sets the x , y coordinates of the window as well as height and width of the current window . : Usage : driver . set_window_rect ( x = 10 , y = 10 ) driver . set_window_rect ( width = 100 , height = 200 ) driver . set_window_rect ( x = 10 , y = 10 , width = 100 , height = 200 ) \"\"\" if ( x is None and y is None ) and ( height is None and width is None ) : raise InvalidArgumentException ( \" x and y or height and width need values \" ) return self . execute ( Command . SET_WINDOW_RECT , { \" x \" : x , \" y \" : y , \" width \" : width , \" height \" : height } ) [ ' value ' ]","title":"set_window_rect"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#set_window_size","text":"def set_window_size ( self , width , height , windowHandle = 'current' ) Sets the width and height of the current window. (window.resizeTo) :Args: - width: the width in pixels to set the window to - height: the height in pixels to set the window to :Usage: driver.set_window_size(800,600) View Source def set_window_size ( self , width , height , windowHandle = ' current ' ) : \"\"\" Sets the width and height of the current window . ( window . resizeTo ) : Args : - width : the width in pixels to set the window to - height : the height in pixels to set the window to : Usage : driver . set_window_size ( 800 , 600 ) \"\"\" if self . w3c : if windowHandle != ' current ' : warnings . warn ( \" Only 'current' window is supported for W3C compatibile browsers. \" ) self . set_window_rect ( width = int ( width ) , height = int ( height )) else : self . execute ( Command . SET_WINDOW_SIZE , { ' width ' : int ( width ) , ' height ' : int ( height ) , ' windowHandle ' : windowHandle } )","title":"set_window_size"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#start_client","text":"def start_client ( self ) Called before starting a new session. This method may be overridden to define custom startup behavior. View Source def start_client ( self ): \"\"\" Called before starting a new session. This method may be overridden to define custom startup behavior. \"\"\" pass","title":"start_client"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#start_session","text":"def start_session ( self , capabilities , browser_profile = None ) Creates a new session with the desired capabilities. :Args: - browser_name - The name of the browser to request. - version - Which browser version to request. - platform - Which platform to request the browser on. - javascript_enabled - Whether the new session should support JavaScript. - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested. View Source def start_session ( self , capabilities , browser_profile = None ) : \"\"\" Creates a new session with the desired capabilities . : Args : - browser_name - The name of the browser to request . - version - Which browser version to request . - platform - Which platform to request the browser on . - javascript_enabled - Whether the new session should support JavaScript . - browser_profile - A selenium . webdriver . firefox . firefox_profile . FirefoxProfile object . Only used if Firefox is requested . \"\"\" if not isinstance ( capabilities , dict ) : raise InvalidArgumentException ( \" Capabilities must be a dictionary \" ) if browser_profile : if \" moz:firefoxOptions \" in capabilities : capabilities [ \" moz:firefoxOptions \" ][ \" profile \" ] = browser_profile . encoded else : capabilities . update ( { ' firefox_profile ' : browser_profile . encoded } ) w3c_caps = _make_w3c_caps ( capabilities ) parameters = { \" capabilities \" : w3c_caps , \" desiredCapabilities \" : capabilities } response = self . execute ( Command . NEW_SESSION , parameters ) if ' sessionId ' not in response : response = response [ ' value ' ] self . session_id = response [ ' sessionId ' ] self . capabilities = response . get ( ' value ' ) # if capabilities is none we are probably speaking to # a W3C endpoint if self . capabilities is None : self . capabilities = response . get ( ' capabilities ' ) # Double check to see if we have a W3C Compliant browser self . w3c = response . get ( ' status ' ) is None self . command_executor . w3c = self . w3c","title":"start_session"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#stop_client","text":"def stop_client ( self ) Called after executing a quit command. This method may be overridden to define custom shutdown behavior. View Source def stop_client ( self ): \"\"\" Called after executing a quit command. This method may be overridden to define custom shutdown behavior. \"\"\" pass","title":"stop_client"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#switch_to_active_element","text":"def switch_to_active_element ( self ) Deprecated use driver.switch_to.active_element View Source def switch_to_active_element ( self ) : \"\"\" Deprecated use driver.switch_to.active_element \"\"\" warnings . warn ( \" use driver.switch_to.active_element instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . active_element","title":"switch_to_active_element"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#switch_to_alert","text":"def switch_to_alert ( self ) Deprecated use driver.switch_to.alert View Source def switch_to_alert ( self ) : \"\"\" Deprecated use driver.switch_to.alert \"\"\" warnings . warn ( \" use driver.switch_to.alert instead \" , DeprecationWarning , stacklevel = 2 ) return self . _switch_to . alert","title":"switch_to_alert"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#switch_to_default_content","text":"def switch_to_default_content ( self ) Deprecated use driver.switch_to.default_content View Source def switch_to_default_content ( self ): \"\"\" Deprecated use driver.switch_to.default_content \"\"\" warnings . warn ( \"use driver.switch_to.default_content instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . default_content ()","title":"switch_to_default_content"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#switch_to_frame","text":"def switch_to_frame ( self , frame_reference ) Deprecated use driver.switch_to.frame View Source def switch_to_frame ( self , frame_reference ): \"\"\" Deprecated use driver.switch_to.frame \"\"\" warnings . warn ( \"use driver.switch_to.frame instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . frame ( frame_reference )","title":"switch_to_frame"},{"location":"reference/appium/webdriver/extensions/android/system_bars/#switch_to_window","text":"def switch_to_window ( self , window_name ) Deprecated use driver.switch_to.window View Source def switch_to_window ( self , window_name ): \"\"\" Deprecated use driver.switch_to.window \"\"\" warnings . warn ( \"use driver.switch_to.window instead\" , DeprecationWarning , stacklevel = 2 ) self . _switch_to . window ( window_name )","title":"switch_to_window"}]}